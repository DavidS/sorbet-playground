# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class Addrinfo
  extend ::T::Sig
end

class ArgumentError
  extend ::T::Sig
end

class Array
  include ::PSON::Pure::Generator::GeneratorMethods::Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def append(*_); end

  def bsearch(); end

  def bsearch_index(); end

  def collect!(); end

  def dig(*_); end

  def flatten!(*_); end

  def pack(*_); end

  def prepend(*_); end

  def replace(_); end

  def shelljoin(); end

  def to_h(); end
end

class Array
  extend ::T::Sig
  def self.try_convert(_); end
end

module Base64
  extend ::T::Sig
end

BasicObject::BasicObject = BasicObject

class BasicObject
  extend ::T::Sig
end

class BasicSocket
  def read_nonblock(len, str=T.unsafe(nil), exception: T.unsafe(nil)); end
end

class BasicSocket
  extend ::T::Sig
end

class Benchmark::Job
  def initialize(width); end

  def item(label=T.unsafe(nil), &blk); end

  def list(); end

  def report(label=T.unsafe(nil), &blk); end

  def width(); end
end

class Benchmark::Job
  extend ::T::Sig
end

class Benchmark::Report
  def initialize(width=T.unsafe(nil), format=T.unsafe(nil)); end

  def item(label=T.unsafe(nil), *format, &blk); end

  def list(); end

  def report(label=T.unsafe(nil), *format, &blk); end
end

class Benchmark::Report
  extend ::T::Sig
end

class Benchmark::Tms
  def *(x); end

  def +(other); end

  def -(other); end

  def /(x); end

  def add(&blk); end

  def add!(&blk); end

  def cstime(); end

  def cutime(); end

  def format(format=T.unsafe(nil), *args); end

  def initialize(utime=T.unsafe(nil), stime=T.unsafe(nil), cutime=T.unsafe(nil), cstime=T.unsafe(nil), real=T.unsafe(nil), label=T.unsafe(nil)); end

  def label(); end

  def memberwise(op, x); end

  def real(); end

  def stime(); end

  def to_a(); end

  def total(); end

  def utime(); end
end

class Benchmark::Tms
  extend ::T::Sig
end

module Benchmark
  extend ::T::Sig
end

class BigDecimal
  def clone(); end

  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  SIGN_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  extend ::T::Sig
  def self._load(_); end

  def self.double_fig(); end

  def self.limit(*_); end

  def self.mode(*_); end

  def self.save_exception_mode(); end

  def self.save_limit(); end

  def self.save_rounding_mode(); end

  def self.ver(); end
end

module BigMath
  extend ::T::Sig
end

class Binding
  def clone(); end

  def irb(); end

  def local_variable_defined?(_); end

  def local_variable_get(_); end

  def local_variable_set(_, _1); end

  def receiver(); end
end

class Binding
  extend ::T::Sig
end

module Bundler::BuildMetadata
  extend ::T::Sig
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::FeatureFlag
  def github_https?(); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::AuthenticationRequiredError
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CertificateFailureError
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::FallbackError
end

class Bundler::Fetcher::FallbackError
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::NetworkDownError
end

class Bundler::Fetcher::NetworkDownError
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::SSLError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils::DryRun
  extend ::T::Sig
end

module Bundler::FileUtils::LowMethods
  extend ::T::Sig
end

module Bundler::FileUtils::NoWrite
  extend ::T::Sig
end

module Bundler::FileUtils::StreamUtils_
  extend ::T::Sig
end

module Bundler::FileUtils::Verbose
  extend ::T::Sig
end

module Bundler::FileUtils
  extend ::T::Sig
end

class Bundler::GemHelper
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_code(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

module Bundler::GemHelpers
  extend ::T::Sig
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

module Bundler::MatchPlatform
  extend ::T::Sig
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
  extend ::T::Sig
end

class Bundler::Plugin::DSL
  def _gem(name, *args); end

  def inferred_plugins(); end

  def plugin(name, *args); end
end

class Bundler::Plugin::DSL::PluginGemfileError
end

class Bundler::Plugin::DSL::PluginGemfileError
end

class Bundler::Plugin::DSL
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

module Bundler::Plugin::Events
  extend ::T::Sig
  def self.defined_event?(event); end
end

class Bundler::Plugin::Index
  def command_plugin(command); end

  def commands(); end

  def global_index_file(); end

  def hook_plugins(event); end

  def index_file(); end

  def installed?(name); end

  def load_paths(name); end

  def local_index_file(); end

  def plugin_path(name); end

  def register_plugin(name, path, load_paths, commands, sources, hooks); end

  def source?(source); end

  def source_plugin(name); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Index
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  extend ::T::Sig
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Resolver
  include ::Molinillo::UI
  include ::Molinillo::SpecificationProvider
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

module Bundler::RubyDsl
  extend ::T::Sig
end

class Bundler::RubyGemsGemInstaller
  def initialize(gem, options=T.unsafe(nil)); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

module Bundler::SharedHelpers
  extend ::T::Sig
end

class Bundler::UI::RGProxy
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::UI
  extend ::T::Sig
end

module Bundler::URICredentialsFilter
  extend ::T::Sig
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  extend ::T::Sig
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Bundler::YAMLSerializer
  extend ::T::Sig
end

module Bundler
  extend ::T::Sig
end

class CGI::Cookie
  extend ::T::Sig
end

module CGI::Escape
  extend ::T::Sig
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
  extend ::T::Sig
end

class CGI::InvalidEncoding
  extend ::T::Sig
end

module CGI::QueryExtension
  extend ::T::Sig
end

module CGI::Util
  extend ::T::Sig
end

class CGI
  extend ::T::Sig
end

class Class
  def json_creatable?(); end

  def pson_creatable?(); end
end

class Class
  extend ::T::Sig
end

class ClosedQueueError
  extend ::T::Sig
end

module Comparable
  extend ::T::Sig
end

class Complex
  extend ::T::Sig
  def self.polar(*_); end

  def self.rect(*_); end

  def self.rectangular(*_); end
end

ConditionVariable = Thread::ConditionVariable

module DOT
  def change_tab(t); end
  EDGE_OPTS = ::T.let(nil, ::T.untyped)
  GRAPH_OPTS = ::T.let(nil, ::T.untyped)
  NODE_OPTS = ::T.let(nil, ::T.untyped)
end

class DOT::DOTDigraph
end

class DOT::DOTDigraph
end

class DOT::DOTDirectedEdge
end

class DOT::DOTDirectedEdge
end

class DOT::DOTEdge
  def edge_link(); end

  def from(); end

  def from=(from); end

  def to(); end

  def to=(to); end

  def to_s(t=T.unsafe(nil)); end
end

class DOT::DOTEdge
end

class DOT::DOTElement
  def each_option(); end

  def each_option_pair(); end

  def initialize(params=T.unsafe(nil), option_list=T.unsafe(nil)); end

  def options(); end

  def options=(options); end
end

class DOT::DOTElement
end

class DOT::DOTNode
  def <<(thing); end

  def each_port(); end

  def pop(); end

  def push(thing); end

  def to_s(t=T.unsafe(nil)); end
end

class DOT::DOTNode
end

class DOT::DOTPort
  def label(); end

  def label=(label); end
end

class DOT::DOTPort
end

class DOT::DOTSimpleElement
  def initialize(params=T.unsafe(nil)); end

  def name(); end

  def name=(name); end
end

class DOT::DOTSimpleElement
end

class DOT::DOTSubgraph
  def <<(thing); end

  def each_node(); end

  def pop(); end

  def push(thing); end

  def to_s(t=T.unsafe(nil)); end
end

class DOT::DOTSubgraph
end

module DOT
  extend ::T::Sig
end

class Data
  extend ::T::Sig
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class Date::Infinity
  extend ::T::Sig
end

class Date
  extend ::T::Sig
end

class DateTime
  extend ::T::Sig
end

module DeepMerge
  DEFAULT_FIELD_KNOCKOUT_PREFIX = ::T.let(nil, ::T.untyped)
end

class DeepMerge::InvalidParameter
end

class DeepMerge::InvalidParameter
end

module DeepMerge
  extend ::T::Sig
  def self.clear_or_nil(obj); end

  def self.deep_merge!(source, dest, options=T.unsafe(nil)); end

  def self.overwrite_unmergeables(source, dest, options); end
end

class Delegator
  def !=(obj); end

  def ==(obj); end

  def __getobj__(); end

  def __setobj__(obj); end

  def eql?(obj); end

  def initialize(obj); end

  def marshal_dump(); end

  def marshal_load(data); end

  def method_missing(m, *args, &block); end

  def methods(all=T.unsafe(nil)); end

  def protected_methods(all=T.unsafe(nil)); end

  def public_methods(all=T.unsafe(nil)); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Delegator
  extend ::T::Sig
  def self.const_missing(n); end

  def self.delegating_block(mid); end

  def self.public_api(); end
end

module DidYouMean
  extend ::T::Sig
end

class Digest::Base
  extend ::T::Sig
end

class Digest::Class
  extend ::T::Sig
end

module Digest::Instance
  extend ::T::Sig
end

class Digest::MD5
  extend ::T::Sig
end

class Digest::SHA1
  extend ::T::Sig
end

module Digest
  extend ::T::Sig
end

module Dir::Tmpname
  extend ::T::Sig
end

class Dir
  extend ::T::Sig
  def self.children(*_); end

  def self.each_child(*_); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.tmpdir(); end
end

class EOFError
  extend ::T::Sig
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end

  def result_with_hash(hash); end
end

class ERB::Compiler::Buffer
  extend ::T::Sig
end

class ERB::Compiler::ExplicitScanner
  extend ::T::Sig
end

class ERB::Compiler::PercentLine
  extend ::T::Sig
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

class ERB::Compiler::Scanner
  extend ::T::Sig
end

class ERB::Compiler::SimpleScanner
  extend ::T::Sig
end

class ERB::Compiler::TrimScanner
  extend ::T::Sig
end

class ERB::Compiler
  extend ::T::Sig
end

module ERB::DefMethod
  extend ::T::Sig
end

module ERB::Util
  extend ::T::Sig
end

class ERB
  extend ::T::Sig
end

Emitter = Psych::Stream::Emitter

class Encoding
  def _dump(*_); end
end

class Encoding::CompatibilityError
  extend ::T::Sig
end

class Encoding::Converter
  def convert(_); end

  def convpath(); end

  def destination_encoding(); end

  def finish(); end

  def initialize(*_); end

  def insert_output(_); end

  def last_error(); end

  def primitive_convert(*_); end

  def primitive_errinfo(); end

  def putback(*_); end

  def replacement(); end

  def replacement=(replacement); end

  def source_encoding(); end
end

class Encoding::Converter
  extend ::T::Sig
  def self.asciicompat_encoding(_); end

  def self.search_convpath(*_); end
end

class Encoding::ConverterNotFoundError
  extend ::T::Sig
end

class Encoding::InvalidByteSequenceError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_bytes(); end

  def incomplete_input?(); end

  def readagain_bytes(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding::InvalidByteSequenceError
  extend ::T::Sig
end

class Encoding::UndefinedConversionError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_char(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding::UndefinedConversionError
  extend ::T::Sig
end

class Encoding
  extend ::T::Sig
  def self._load(_); end

  def self.locale_charmap(); end
end

class EncodingError
  extend ::T::Sig
end

module Enumerable
  def chunk(); end

  def chunk_while(); end

  def each_entry(*_); end

  def each_with_object(_); end

  def grep_v(_); end

  def lazy(); end

  def slice_after(*_); end

  def slice_before(*_); end

  def slice_when(); end

  def sum(*_); end

  def to_set(klass=T.unsafe(nil), *args, &block); end

  def uniq(); end

  def zip(*_); end
end

module Enumerable
  extend ::T::Sig
end

class Enumerator::Generator
  def each(*_); end

  def initialize(*_); end
end

class Enumerator::Generator
  extend ::T::Sig
end

class Enumerator::Lazy
  def chunk(*_); end

  def chunk_while(*_); end

  def force(*_); end

  def slice_when(*_); end
end

class Enumerator::Lazy
  extend ::T::Sig
end

class Enumerator::Yielder
  extend ::T::Sig
end

class Enumerator
  extend ::T::Sig
end

class Errno::E2BIG
  extend ::T::Sig
end

class Errno::EACCES
  extend ::T::Sig
end

class Errno::EADDRINUSE
  extend ::T::Sig
end

class Errno::EADDRNOTAVAIL
  extend ::T::Sig
end

class Errno::EADV
  extend ::T::Sig
end

class Errno::EAFNOSUPPORT
  extend ::T::Sig
end

class Errno::EAGAIN
  extend ::T::Sig
end

class Errno::EALREADY
  extend ::T::Sig
end

Errno::EAUTH = Errno::NOERROR

class Errno::EBADE
  extend ::T::Sig
end

class Errno::EBADF
  extend ::T::Sig
end

class Errno::EBADFD
  extend ::T::Sig
end

class Errno::EBADMSG
  extend ::T::Sig
end

class Errno::EBADR
  extend ::T::Sig
end

Errno::EBADRPC = Errno::NOERROR

class Errno::EBADRQC
  extend ::T::Sig
end

class Errno::EBADSLT
  extend ::T::Sig
end

class Errno::EBFONT
  extend ::T::Sig
end

class Errno::EBUSY
  extend ::T::Sig
end

class Errno::ECANCELED
  extend ::T::Sig
end

Errno::ECAPMODE = Errno::NOERROR

class Errno::ECHILD
  extend ::T::Sig
end

class Errno::ECHRNG
  extend ::T::Sig
end

class Errno::ECOMM
  extend ::T::Sig
end

class Errno::ECONNABORTED
  extend ::T::Sig
end

class Errno::ECONNREFUSED
  extend ::T::Sig
end

class Errno::ECONNRESET
  extend ::T::Sig
end

class Errno::EDEADLK
  extend ::T::Sig
end

Errno::EDEADLOCK = Errno::EDEADLK

class Errno::EDESTADDRREQ
  extend ::T::Sig
end

class Errno::EDOM
  extend ::T::Sig
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EDOTDOT
  extend ::T::Sig
end

class Errno::EDQUOT
  extend ::T::Sig
end

class Errno::EEXIST
  extend ::T::Sig
end

class Errno::EFAULT
  extend ::T::Sig
end

class Errno::EFBIG
  extend ::T::Sig
end

Errno::EFTYPE = Errno::NOERROR

class Errno::EHOSTDOWN
  extend ::T::Sig
end

class Errno::EHOSTUNREACH
  extend ::T::Sig
end

class Errno::EHWPOISON
  extend ::T::Sig
end

class Errno::EIDRM
  extend ::T::Sig
end

class Errno::EILSEQ
  extend ::T::Sig
end

class Errno::EINPROGRESS
  extend ::T::Sig
end

class Errno::EINTR
  extend ::T::Sig
end

class Errno::EINVAL
  extend ::T::Sig
end

class Errno::EIO
  extend ::T::Sig
end

Errno::EIPSEC = Errno::NOERROR

class Errno::EISCONN
  extend ::T::Sig
end

class Errno::EISDIR
  extend ::T::Sig
end

class Errno::EISNAM
  extend ::T::Sig
end

class Errno::EKEYEXPIRED
  extend ::T::Sig
end

class Errno::EKEYREJECTED
  extend ::T::Sig
end

class Errno::EKEYREVOKED
  extend ::T::Sig
end

class Errno::EL2HLT
  extend ::T::Sig
end

class Errno::EL2NSYNC
  extend ::T::Sig
end

class Errno::EL3HLT
  extend ::T::Sig
end

class Errno::EL3RST
  extend ::T::Sig
end

class Errno::ELIBACC
  extend ::T::Sig
end

class Errno::ELIBBAD
  extend ::T::Sig
end

class Errno::ELIBEXEC
  extend ::T::Sig
end

class Errno::ELIBMAX
  extend ::T::Sig
end

class Errno::ELIBSCN
  extend ::T::Sig
end

class Errno::ELNRNG
  extend ::T::Sig
end

class Errno::ELOOP
  extend ::T::Sig
end

class Errno::EMEDIUMTYPE
  extend ::T::Sig
end

class Errno::EMFILE
  extend ::T::Sig
end

class Errno::EMLINK
  extend ::T::Sig
end

class Errno::EMSGSIZE
  extend ::T::Sig
end

class Errno::EMULTIHOP
  extend ::T::Sig
end

class Errno::ENAMETOOLONG
  extend ::T::Sig
end

class Errno::ENAVAIL
  extend ::T::Sig
end

Errno::ENEEDAUTH = Errno::NOERROR

class Errno::ENETDOWN
  extend ::T::Sig
end

class Errno::ENETRESET
  extend ::T::Sig
end

class Errno::ENETUNREACH
  extend ::T::Sig
end

class Errno::ENFILE
  extend ::T::Sig
end

class Errno::ENOANO
  extend ::T::Sig
end

Errno::ENOATTR = Errno::NOERROR

class Errno::ENOBUFS
  extend ::T::Sig
end

class Errno::ENOCSI
  extend ::T::Sig
end

class Errno::ENODATA
  extend ::T::Sig
end

class Errno::ENODEV
  extend ::T::Sig
end

class Errno::ENOENT
  extend ::T::Sig
end

class Errno::ENOEXEC
  extend ::T::Sig
end

class Errno::ENOKEY
  extend ::T::Sig
end

class Errno::ENOLCK
  extend ::T::Sig
end

class Errno::ENOLINK
  extend ::T::Sig
end

class Errno::ENOMEDIUM
  extend ::T::Sig
end

class Errno::ENOMEM
  extend ::T::Sig
end

class Errno::ENOMSG
  extend ::T::Sig
end

class Errno::ENONET
  extend ::T::Sig
end

class Errno::ENOPKG
  extend ::T::Sig
end

class Errno::ENOPROTOOPT
  extend ::T::Sig
end

class Errno::ENOSPC
  extend ::T::Sig
end

class Errno::ENOSR
  extend ::T::Sig
end

class Errno::ENOSTR
  extend ::T::Sig
end

class Errno::ENOSYS
  extend ::T::Sig
end

class Errno::ENOTBLK
  extend ::T::Sig
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTCONN
  extend ::T::Sig
end

class Errno::ENOTDIR
  extend ::T::Sig
end

class Errno::ENOTEMPTY
  extend ::T::Sig
end

class Errno::ENOTNAM
  extend ::T::Sig
end

class Errno::ENOTRECOVERABLE
  extend ::T::Sig
end

class Errno::ENOTSOCK
  extend ::T::Sig
end

Errno::ENOTSUP = Errno::EOPNOTSUPP

class Errno::ENOTTY
  extend ::T::Sig
end

class Errno::ENOTUNIQ
  extend ::T::Sig
end

class Errno::ENXIO
  extend ::T::Sig
end

class Errno::EOPNOTSUPP
  extend ::T::Sig
end

class Errno::EOVERFLOW
  extend ::T::Sig
end

class Errno::EOWNERDEAD
  extend ::T::Sig
end

class Errno::EPERM
  extend ::T::Sig
end

class Errno::EPFNOSUPPORT
  extend ::T::Sig
end

class Errno::EPIPE
  extend ::T::Sig
end

Errno::EPROCLIM = Errno::NOERROR

Errno::EPROCUNAVAIL = Errno::NOERROR

Errno::EPROGMISMATCH = Errno::NOERROR

Errno::EPROGUNAVAIL = Errno::NOERROR

class Errno::EPROTO
  extend ::T::Sig
end

class Errno::EPROTONOSUPPORT
  extend ::T::Sig
end

class Errno::EPROTOTYPE
  extend ::T::Sig
end

class Errno::ERANGE
  extend ::T::Sig
end

class Errno::EREMCHG
  extend ::T::Sig
end

class Errno::EREMOTE
  extend ::T::Sig
end

class Errno::EREMOTEIO
  extend ::T::Sig
end

class Errno::ERESTART
  extend ::T::Sig
end

class Errno::ERFKILL
  extend ::T::Sig
end

class Errno::EROFS
  extend ::T::Sig
end

Errno::ERPCMISMATCH = Errno::NOERROR

class Errno::ESHUTDOWN
  extend ::T::Sig
end

class Errno::ESOCKTNOSUPPORT
  extend ::T::Sig
end

class Errno::ESPIPE
  extend ::T::Sig
end

class Errno::ESRCH
  extend ::T::Sig
end

class Errno::ESRMNT
  extend ::T::Sig
end

class Errno::ESTALE
  extend ::T::Sig
end

class Errno::ESTRPIPE
  extend ::T::Sig
end

class Errno::ETIME
  extend ::T::Sig
end

class Errno::ETIMEDOUT
  extend ::T::Sig
end

class Errno::ETOOMANYREFS
  extend ::T::Sig
end

class Errno::ETXTBSY
  extend ::T::Sig
end

class Errno::EUCLEAN
  extend ::T::Sig
end

class Errno::EUNATCH
  extend ::T::Sig
end

class Errno::EUSERS
  extend ::T::Sig
end

class Errno::EXDEV
  extend ::T::Sig
end

class Errno::EXFULL
  extend ::T::Sig
end

class Errno::NOERROR
  extend ::T::Sig
end

module Errno
  extend ::T::Sig
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::T::Sig
  extend ::Enumerable
  def self.[](*_); end

  def self.each(); end

  def self.members(); end
end

class Etc::Passwd
  def dir(); end

  def dir=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid(); end

  def gid=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end

  def shell(); end

  def shell=(_); end

  def uid(); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::T::Sig
  extend ::Enumerable
  def self.[](*_); end

  def self.each(); end

  def self.members(); end
end

module Etc
  extend ::T::Sig
  def self.confstr(_); end

  def self.endgrent(); end

  def self.endpwent(); end

  def self.getgrent(); end

  def self.getgrgid(*_); end

  def self.getgrnam(_); end

  def self.getlogin(); end

  def self.getpwent(); end

  def self.getpwnam(_); end

  def self.getpwuid(*_); end

  def self.group(); end

  def self.nprocessors(); end

  def self.passwd(); end

  def self.setgrent(); end

  def self.setpwent(); end

  def self.sysconf(_); end

  def self.sysconfdir(); end

  def self.systmpdir(); end

  def self.uname(); end
end

class Exception
  def full_message(*_); end

end

class Exception
  extend ::T::Sig
  def self.exception(*_); end

  def self.to_tty?(); end
end

class ExitCalledError
end

class ExitCalledError
end

module Facter
  include ::Comparable
  include ::Enumerable
  FACTERVERSION = ::T.let(nil, ::T.untyped)
end

module Facter::Core
end

class Facter::Core::Aggregate
  include ::Facter::Core::Suitable
  include ::Facter::Core::Resolvable
  def aggregate(&block); end

  def chunk(name, opts=T.unsafe(nil), &block); end

  def confines(); end

  def deps(); end

  def evaluate(&block); end

  def fact(); end

  def initialize(name, fact); end

  def name(); end

  def resolution_type(); end

  def set_options(options); end
end

class Facter::Core::Aggregate::DependencyError
end

class Facter::Core::Aggregate::DependencyError
end

class Facter::Core::Aggregate
end

class Facter::Core::DirectedGraph
  include ::TSort
  def acyclic?(); end

  def cycles(); end
end

class Facter::Core::DirectedGraph::CycleError
end

class Facter::Core::DirectedGraph::CycleError
end

class Facter::Core::DirectedGraph::MissingVertex
end

class Facter::Core::DirectedGraph::MissingVertex
end

class Facter::Core::DirectedGraph
end

module Facter::Core::Execution
end

class Facter::Core::Execution::Base
  def execute(command, options=T.unsafe(nil)); end

  def with_env(values); end
end

class Facter::Core::Execution::Base
end

class Facter::Core::Execution::ExecutionFailure
end

class Facter::Core::Execution::ExecutionFailure
end

class Facter::Core::Execution::Posix
  def absolute_path?(path); end

  def expand_command(command); end

  def search_paths(); end

  def which(bin); end
  ABSOLUTE_PATH_REGEX = ::T.let(nil, ::T.untyped)
  DEFAULT_SEARCH_PATHS = ::T.let(nil, ::T.untyped)
  DOUBLE_QUOTED_COMMAND = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTED_COMMAND = ::T.let(nil, ::T.untyped)
end

class Facter::Core::Execution::Posix
end

class Facter::Core::Execution::Windows
  def absolute_path?(path); end

  def expand_command(command); end

  def search_paths(); end

  def which(bin); end
  ABSOLUTE_PATH_REGEX = ::T.let(nil, ::T.untyped)
  DEFAULT_COMMAND_EXTENSIONS = ::T.let(nil, ::T.untyped)
  DOUBLE_QUOTED_COMMAND = ::T.let(nil, ::T.untyped)
end

class Facter::Core::Execution::Windows
end

module Facter::Core::Execution
  extend ::T::Sig
  def self.absolute_path?(path, platform=T.unsafe(nil)); end

  def self.exec(command); end

  def self.execute(command, options=T.unsafe(nil)); end

  def self.expand_command(command); end

  def self.impl(); end

  def self.search_paths(); end

  def self.which(bin); end

  def self.with_env(values, &block); end
end

module Facter::Core::Logging
  def clear_messages(); end

  def debug(msg); end

  def debugging(bool); end

  def debugging?(); end

  def debugonce(msg); end

  def format_exception(exception, message, trace); end

  def log_exception(exception, message=T.unsafe(nil)); end

  def on_message(&block); end

  def show_time(string); end

  def timing(bool); end

  def timing?(); end

  def trace(bool); end

  def trace?(); end

  def warn(msg); end

  def warnonce(msg); end
  GREEN = ::T.let(nil, ::T.untyped)
  RESET = ::T.let(nil, ::T.untyped)
end

module Facter::Core::Logging
  extend ::Facter::Core::Logging
  extend ::T::Sig
end

module Facter::Core::Resolvable
  def flush(); end

  def limit(); end

  def on_flush(&block); end

  def timeout(); end

  def timeout=(timeout); end

  def value(); end
end

module Facter::Core::Resolvable
  extend ::T::Sig
end

module Facter::Core::Suitable
  def confine(confines=T.unsafe(nil), &block); end

  def has_weight(weight); end

  def suitable?(); end

  def weight(); end

  def weight=(weight); end
end

module Facter::Core::Suitable
  extend ::T::Sig
end

module Facter::Core
  extend ::T::Sig
end

module Facter::Util
end

class Facter::Util::Collection
  include ::Enumerable
  def [](name); end

  def add(name, options=T.unsafe(nil), &block); end

  def define_fact(name, options=T.unsafe(nil), &block); end

  def each(); end

  def external_loader(); end

  def fact(name); end

  def flush(); end

  def initialize(internal_loader, external_loader); end

  def internal_loader(); end

  def list(); end

  def load(name); end

  def load_all(); end

  def to_hash(); end

  def value(name); end
end

class Facter::Util::Collection
end

class Facter::Util::CompositeLoader
  def initialize(loaders); end

  def load(collection); end
end

class Facter::Util::CompositeLoader
end

module Facter::Util::Config
end

module Facter::Util::Config
  extend ::T::Sig
  def self.ext_fact_loader(); end

  def self.ext_fact_loader=(loader); end

  def self.external_facts_dirs(); end

  def self.external_facts_dirs=(dir); end

  def self.is_mac?(); end

  def self.is_windows?(); end

  def self.override_binary_dir(); end

  def self.override_binary_dir=(dir); end

  def self.setup_default_ext_facts_dirs(); end

  def self.setup_default_override_binary_dir(); end

  def self.windows_data_dir(); end
end

class Facter::Util::Confine
  include ::Facter::Util::Values
  def fact(); end

  def fact=(fact); end

  def initialize(fact=T.unsafe(nil), *values, &block); end

  def true?(); end

  def values(); end

  def values=(values); end
end

class Facter::Util::Confine
end

class Facter::Util::DirectoryLoader
  def directory(); end

  def initialize(dir, weight=T.unsafe(nil)); end

  def load(collection); end
  EXTERNAL_FACT_WEIGHT = ::T.let(nil, ::T.untyped)
end

class Facter::Util::DirectoryLoader::NoSuchDirectoryError
end

class Facter::Util::DirectoryLoader::NoSuchDirectoryError
end

class Facter::Util::DirectoryLoader
  def self.default_loader(); end

  def self.loader_for(dir); end
end

class Facter::Util::Fact
  def add(options=T.unsafe(nil), &block); end

  def define_resolution(resolution_name, options=T.unsafe(nil), &block); end

  def extract_ldapname_option!(options); end

  def flush(); end

  def initialize(name, options=T.unsafe(nil)); end

  def ldapname(); end

  def ldapname=(ldapname); end

  def name(); end

  def name=(name); end

  def resolution(name); end

  def value(); end
end

class Facter::Util::Fact
end

class Facter::Util::Loader
  def initialize(environment_vars=T.unsafe(nil)); end

  def load(fact); end

  def load_all(); end

  def search_path(); end
end

class Facter::Util::Loader
end

module Facter::Util::Normalization
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Facter::Util::Normalization::NormalizationError
end

class Facter::Util::Normalization::NormalizationError
end

module Facter::Util::Normalization
  extend ::T::Sig
  def self.normalize(value); end

  def self.normalize_array(value); end

  def self.normalize_hash(value); end

  def self.normalize_string(value); end
end

module Facter::Util::Parser
end

class Facter::Util::Parser::Base
  def content(); end

  def filename(); end

  def initialize(filename, content=T.unsafe(nil)); end

  def parse_results(); end

  def results(); end
end

class Facter::Util::Parser::Base
end

class Facter::Util::Parser::JsonParser
end

class Facter::Util::Parser::JsonParser
end

module Facter::Util::Parser::KeyValuePairOutputFormat
end

module Facter::Util::Parser::KeyValuePairOutputFormat
  extend ::T::Sig
  def self.parse(output); end
end

class Facter::Util::Parser::NothingParser
  def results(); end
end

class Facter::Util::Parser::NothingParser
end

class Facter::Util::Parser::PowershellParser
end

class Facter::Util::Parser::PowershellParser
end

class Facter::Util::Parser::ScriptParser
end

class Facter::Util::Parser::ScriptParser
end

class Facter::Util::Parser::TextParser
end

class Facter::Util::Parser::TextParser
end

class Facter::Util::Parser::YamlParser
end

class Facter::Util::Parser::YamlParser
end

module Facter::Util::Parser
  extend ::T::Sig
  def self.extension_matches?(filename, ext); end

  def self.file_extension(filename); end

  def self.parser_for(filename); end

  def self.register(klass, &suitable); end
end

class Facter::Util::Resolution
  include ::Facter::Core::Resolvable
  include ::Facter::Core::Suitable
  def code(); end

  def code=(code); end

  def evaluate(&block); end

  def fact(); end

  def initialize(name, fact); end

  def name(); end

  def name=(name); end

  def resolution_type(); end

  def set_options(options); end

  def setcode(string=T.unsafe(nil), &block); end

  def value=(value); end
end

class Facter::Util::Resolution
  extend ::Facter::Core::Execution
end

module Facter::Util::Root
end

module Facter::Util::Root
  extend ::T::Sig
  def self.root?(); end
end

module Facter::Util::Values
end

class Facter::Util::Values::DeepFreezeError
end

class Facter::Util::Values::DeepFreezeError
end

class Facter::Util::Values::DeepMergeError
end

class Facter::Util::Values::DeepMergeError
end

module Facter::Util::Values
  extend ::T::Sig
  def self.convert(value); end

  def self.deep_freeze(value); end

  def self.deep_merge(left, right, path=T.unsafe(nil), &block); end

  def self.flatten_structure(path, structure); end
end

module Facter::Util
  extend ::T::Sig
end

module Facter
  extend ::Facter::Core::Logging
  extend ::T::Sig
  def self.[](name); end

  def self.add(name, options=T.unsafe(nil), &block); end

  def self.clear(); end

  def self.collection(); end

  def self.define_fact(name, options=T.unsafe(nil), &block); end

  def self.each(); end

  def self.fact(name); end

  def self.flush(); end

  def self.json?(); end

  def self.list(); end

  def self.loadfacts(); end

  def self.reset(); end

  def self.reset_search_path!(); end

  def self.search(*dirs); end

  def self.search_external(dirs); end

  def self.search_external_path(); end

  def self.search_path(); end

  def self.to_hash(); end

  def self.value(name); end

  def self.version(); end

  def self.version=(version); end
end

class FalseClass
  include ::PSON::Pure::Generator::GeneratorMethods::FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

class FalseClass
  extend ::T::Sig
end

module FastGettext
  include ::FastGettext::Storage
  def N_(*args); end

  def Nn_(*args); end

  def _(*args); end

  def add_text_domain(name, options); end

  def locale_path(); end

  def n_(*args); end

  def ns_(*args); end

  def p_(*args); end

  def s_(*args); end
  LOCALE_REX = ::T.let(nil, ::T.untyped)
  NAMESPACE_SEPARATOR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class FastGettext::Cache
  def []=(key, value); end

  def delete(key); end

  def fetch(key); end

  def reload!(); end

  def switch_to(text_domain, locale); end
end

class FastGettext::Cache
end

module FastGettext::GetText
end

class FastGettext::GetText::MOFile
  def charset(); end

  def filename(); end

  def hash_string(str); end

  def initialize(output_charset=T.unsafe(nil)); end

  def last_modified(); end

  def last_modified=(last_modified); end

  def little_endian(); end

  def little_endian=(little_endian); end

  def load(arg); end

  def load_from_file(filename); end

  def load_from_stream(io); end

  def next_prime(seed); end

  def nplurals(); end

  def path(); end

  def path=(path); end

  def plural(); end

  def plural_as_proc(); end

  def prime?(number); end

  def save_to_file(filename); end

  def save_to_stream(io); end

  def set_comment(msgid_or_sym, comment); end

  def update!(); end
  HASHWORDBITS = ::T.let(nil, ::T.untyped)
  MAGIC_BIG_ENDIAN = ::T.let(nil, ::T.untyped)
  MAGIC_LITTLE_ENDIAN = ::T.let(nil, ::T.untyped)
end

class FastGettext::GetText::MOFile::Header
  def hash_table_offset(); end

  def hash_table_offset=(_); end

  def hash_table_size(); end

  def hash_table_size=(_); end

  def magic(); end

  def magic=(_); end

  def nstrings(); end

  def nstrings=(_); end

  def orig_table_offset(); end

  def orig_table_offset=(_); end

  def revision(); end

  def revision=(_); end

  def translated_table_offset(); end

  def translated_table_offset=(_); end
end

class FastGettext::GetText::MOFile::Header
  def self.[](*_); end

  def self.members(); end
end

class FastGettext::GetText::MOFile::HeaderRev1
  def n_sysdep_segments(); end

  def n_sysdep_segments=(n_sysdep_segments); end

  def n_sysdep_strings(); end

  def n_sysdep_strings=(n_sysdep_strings); end

  def orig_sysdep_tab_offset(); end

  def orig_sysdep_tab_offset=(orig_sysdep_tab_offset); end

  def sysdep_segments_offset(); end

  def sysdep_segments_offset=(sysdep_segments_offset); end

  def trans_sysdep_tab_offset(); end

  def trans_sysdep_tab_offset=(trans_sysdep_tab_offset); end
end

class FastGettext::GetText::MOFile::HeaderRev1
end

class FastGettext::GetText::MOFile::InvalidFormat
end

class FastGettext::GetText::MOFile::InvalidFormat
end

class FastGettext::GetText::MOFile
  def self.open(arg=T.unsafe(nil), output_charset=T.unsafe(nil)); end
end

module FastGettext::GetText
  extend ::T::Sig
end

class FastGettext::MoFile
  def [](key); end

  def data(); end

  def initialize(file, options=T.unsafe(nil)); end

  def plural(*msgids); end

  def pluralisation_rule(); end
  PLURAL_SEPERATOR = ::T.let(nil, ::T.untyped)
end

class FastGettext::MoFile
  def self.empty(); end
end

class FastGettext::PoFile
end

class FastGettext::PoFile
  def self.parse_po_file(file, options=T.unsafe(nil)); end

  def self.to_mo_file(file, options=T.unsafe(nil)); end
end

module FastGettext::Storage
  def available_locales(); end

  def available_locales=(value); end

  def best_locale_in(locales); end

  def cache(); end

  def cache_class(); end

  def cache_class=(value); end

  def cached_find(key); end

  def cached_plural_find(*keys); end

  def current_repository(); end

  def default_available_locales(); end

  def default_available_locales=(value); end

  def default_locale(); end

  def default_locale=(new_locale); end

  def default_text_domain(); end

  def default_text_domain=(value); end

  def expire_cache_for(key); end

  def key_exist?(key); end

  def locale(); end

  def locale=(new_locale); end

  def pluralisation_rule(); end

  def pluralisation_rule=(value); end

  def reload!(); end

  def set_locale(new_locale); end

  def silence_errors(); end

  def text_domain(); end

  def text_domain=(value); end

  def translation_repositories(); end

  def with_locale(temp_locale); end
end

class FastGettext::Storage::NoTextDomainConfigured
end

class FastGettext::Storage::NoTextDomainConfigured
end

module FastGettext::Storage
  extend ::T::Sig
end

module FastGettext::Translation
  def N_(translate); end

  def Nn_(*keys); end

  def _(key, &block); end

  def n_(*keys, &block); end

  def ns_(*args, &block); end

  def p_(namespace, key, separator=T.unsafe(nil), &block); end

  def s_(key, separator=T.unsafe(nil), &block); end
end

module FastGettext::Translation
  extend ::T::Sig
  def self.included(klas); end
end

module FastGettext::TranslationMultidomain
  def D_(key); end

  def Dn_(*keys); end

  def Dns_(*keys); end

  def Ds_(key, separator=T.unsafe(nil)); end

  def _in_domain(domain); end

  def d_(domain, key, &block); end

  def dn_(domain, *keys, &block); end

  def dns_(domain, *keys, &block); end

  def ds_(domain, key, separator=T.unsafe(nil), &block); end
end

module FastGettext::TranslationMultidomain
  extend ::FastGettext::TranslationMultidomain
  extend ::T::Sig
  def self.included(klas); end
end

module FastGettext::TranslationRepository
  def build(name, options); end
end

class FastGettext::TranslationRepository::Base
  def [](key); end

  def available_locales(); end

  def current_translations(); end

  def find_files_in_locale_folders(relative_file_path, path); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def options(); end

  def plural(*keys); end

  def pluralisation_rule(); end

  def reload(); end
end

class FastGettext::TranslationRepository::Base
end

class FastGettext::TranslationRepository::Chain
  def chain(); end

  def chain=(chain); end
end

class FastGettext::TranslationRepository::Chain
end

class FastGettext::TranslationRepository::Mo
  def all_translations(); end

  def find_and_store_files(name, options); end
end

class FastGettext::TranslationRepository::Mo
end

class FastGettext::TranslationRepository::Po
end

class FastGettext::TranslationRepository::Po
end

module FastGettext::TranslationRepository
  extend ::FastGettext::TranslationRepository
  extend ::T::Sig
end

module FastGettext
  extend ::FastGettext
  extend ::FastGettext::Storage
  extend ::T::Sig
end

class Fiber
  def resume(*_); end
end

class Fiber
  extend ::T::Sig
  def self.yield(*_); end
end

class FiberError
  extend ::T::Sig
end

class File
  Separator = ::T.let(nil, ::T.untyped)
end

module File::Constants
  extend ::T::Sig
end

class File::Stat
  def size?(); end
end

class File::Stat
  extend ::T::Sig
end

class File
  extend ::T::Sig
  def self.empty?(_); end

  def self.exists?(_); end

  def self.lutime(*_); end

  def self.mkfifo(*_); end

end

module FileTest
  extend ::T::Sig
  def self.blockdev?(_); end

  def self.chardev?(_); end

  def self.directory?(_); end

  def self.empty?(_); end

  def self.executable?(_); end

  def self.executable_real?(_); end

  def self.exist?(_); end

  def self.exists?(_); end

  def self.file?(_); end

  def self.grpowned?(_); end

  def self.identical?(_, _1); end

  def self.owned?(_); end

  def self.pipe?(_); end

  def self.readable?(_); end

  def self.readable_real?(_); end

  def self.setgid?(_); end

  def self.setuid?(_); end

  def self.size(_); end

  def self.size?(_); end

  def self.socket?(_); end

  def self.sticky?(_); end

  def self.symlink?(_); end

  def self.world_readable?(_); end

  def self.world_writable?(_); end

  def self.writable?(_); end

  def self.writable_real?(_); end

  def self.zero?(_); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
  VERSION = ::T.let(nil, ::T.untyped)
end

module FileUtils::DryRun
  include ::FileUtils::LowMethods
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  extend ::T::Sig
  extend ::FileUtils::DryRun
  extend ::FileUtils::LowMethods
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

class FileUtils::Entry_
  def blockdev?(); end

  def chardev?(); end

  def chmod(mode); end

  def chown(uid, gid); end

  def copy(dest); end

  def copy_file(dest); end

  def copy_metadata(path); end

  def dereference?(); end

  def directory?(); end

  def door?(); end

  def entries(); end

  def exist?(); end

  def file?(); end

  def initialize(a, b=T.unsafe(nil), deref=T.unsafe(nil)); end

  def lstat(); end

  def lstat!(); end

  def path(); end

  def pipe?(); end

  def platform_support(); end

  def postorder_traverse(); end

  def prefix(); end

  def preorder_traverse(); end

  def rel(); end

  def remove(); end

  def remove_dir1(); end

  def remove_file(); end

  def socket?(); end

  def stat(); end

  def stat!(); end

  def symlink?(); end

  def traverse(); end

  def wrap_traverse(pre, post); end
end

class FileUtils::Entry_
  extend ::T::Sig
end

module FileUtils::LowMethods
  extend ::T::Sig
end

module FileUtils::NoWrite
  include ::FileUtils::LowMethods
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::NoWrite
  extend ::T::Sig
  extend ::FileUtils::NoWrite
  extend ::FileUtils::LowMethods
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils::StreamUtils_
  extend ::T::Sig
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::T::Sig
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::T::Sig
  extend ::FileUtils::StreamUtils_
  def self.cd(dir, verbose: T.unsafe(nil), &block); end

  def self.chdir(dir, verbose: T.unsafe(nil), &block); end

  def self.chmod(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.chmod_R(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end

  def self.chown(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.chown_R(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end

  def self.cmp(a, b); end

  def self.collect_method(opt); end

  def self.commands(); end

  def self.compare_file(a, b); end

  def self.compare_stream(a, b); end

  def self.copy(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.copy_entry(src, dest, preserve=T.unsafe(nil), dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end

  def self.copy_file(src, dest, preserve=T.unsafe(nil), dereference=T.unsafe(nil)); end

  def self.copy_stream(src, dest); end

  def self.cp(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.getwd(); end

  def self.have_option?(mid, opt); end

  def self.identical?(a, b); end

  def self.install(src, dest, mode: T.unsafe(nil), owner: T.unsafe(nil), group: T.unsafe(nil), preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.link(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.ln(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.ln_s(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.ln_sf(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.makedirs(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.mkdir(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.mkpath(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.move(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  def self.mv(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  def self.options(); end

  def self.options_of(mid); end

  def self.private_module_function(name); end

  def self.pwd(); end

  def self.remove(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.remove_dir(path, force=T.unsafe(nil)); end

  def self.remove_entry(path, force=T.unsafe(nil)); end

  def self.remove_entry_secure(path, force=T.unsafe(nil)); end

  def self.remove_file(path, force=T.unsafe(nil)); end

  def self.rm(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.rm_f(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.rm_rf(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  def self.rmdir(list, parents: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.rmtree(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  def self.safe_unlink(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.symlink(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.uptodate?(new, old_list); end
end

module Find
end

module Find
  extend ::T::Sig
  def self.find(*paths, ignore_error: T.unsafe(nil)); end

  def self.prune(); end
end

class Float
  include ::PSON::Pure::Generator::GeneratorMethods::Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

class Float
  extend ::T::Sig
end

class FloatDomainError
  extend ::T::Sig
end

module Forwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_instance_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_instance_delegators(accessor, *methods); end

  def delegate(hash); end

  def instance_delegate(hash); end
end

module Forwardable
  extend ::T::Sig
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

class FrozenError
end

class FrozenError
end

module GC
  def garbage_collect(*_); end
end

module GC::Profiler
  extend ::T::Sig
end

module GC
  extend ::T::Sig
  def self.latest_gc_info(*_); end

  def self.stress=(stress); end

  def self.verify_internal_consistency(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsPackageVersion = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
  USE_BUNDLER_FOR_GEMDEPS = ::T.let(nil, ::T.untyped)
end

class Gem::AvailableSet
  include ::Enumerable
  def <<(o); end

  def add(spec, source); end

  def all_specs(); end

  def each(); end

  def each_spec(); end

  def empty?(); end

  def find_all(req); end

  def inject_into_list(dep_list); end

  def match_platform!(); end

  def pick_best!(); end

  def prefetch(reqs); end

  def remote(); end

  def remote=(remote); end

  def remove_installed!(dep); end

  def set(); end

  def size(); end

  def sorted(); end

  def source_for(spec); end

  def to_request_set(development=T.unsafe(nil)); end
end

class Gem::AvailableSet::Tuple
  def source(); end

  def source=(_); end

  def spec(); end

  def spec=(_); end
end

class Gem::AvailableSet::Tuple
  def self.[](*_); end

  def self.members(); end
end

class Gem::AvailableSet
end

class Gem::BasicSpecification
  def activated?(); end

  def base_dir(); end

  def base_dir=(base_dir); end

  def contains_requirable_file?(file); end

  def datadir(); end

  def default_gem?(); end

  def extension_dir(); end

  def extension_dir=(extension_dir); end

  def extensions_dir(); end

  def full_gem_path(); end

  def full_gem_path=(full_gem_path); end

  def full_name(); end

  def full_require_paths(); end

  def gem_build_complete_path(); end

  def gem_dir(); end

  def gems_dir(); end

  def ignored=(ignored); end

  def internal_init(); end

  def lib_dirs_glob(); end

  def loaded_from(); end

  def loaded_from=(loaded_from); end

  def matches_for_glob(glob); end

  def name(); end

  def platform(); end

  def raw_require_paths(); end

  def require_paths(); end

  def source_paths(); end

  def stubbed?(); end

  def this(); end

  def to_fullpath(path); end

  def to_spec(); end

  def version(); end
end

class Gem::BasicSpecification
  extend ::T::Sig
  def self.default_specifications_dir(); end

  def self.upstream_default_specifications_dir(); end
end

module Gem::BundlerVersionFinder
end

module Gem::BundlerVersionFinder
  extend ::T::Sig
  def self.bundler_version(); end

  def self.bundler_version_with_reason(); end

  def self.compatible?(spec); end

  def self.filter!(specs); end

  def self.missing_version_message(); end
end

class Gem::Command
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def add_extra_args(args); end

  def add_option(*opts, &handler); end

  def arguments(); end

  def begins?(long, short); end

  def command(); end

  def defaults(); end

  def defaults=(defaults); end

  def defaults_str(); end

  def description(); end

  def execute(); end

  def get_all_gem_names(); end

  def get_all_gem_names_and_versions(); end

  def get_one_gem_name(); end

  def get_one_optional_argument(); end

  def handle_options(args); end

  def handles?(args); end

  def initialize(command, summary=T.unsafe(nil), defaults=T.unsafe(nil)); end

  def invoke(*args); end

  def invoke_with_build_args(args, build_args); end

  def merge_options(new_options); end

  def options(); end

  def program_name(); end

  def program_name=(program_name); end

  def remove_option(name); end

  def show_help(); end

  def show_lookup_failure(gem_name, version, errors, domain); end

  def summary(); end

  def summary=(summary); end

  def usage(); end

  def when_invoked(&block); end
  HELP = ::T.let(nil, ::T.untyped)
end

class Gem::Command
  def self.add_common_option(*args, &handler); end

  def self.add_specific_extra_args(cmd, args); end

  def self.build_args(); end

  def self.build_args=(value); end

  def self.common_options(); end

  def self.extra_args(); end

  def self.extra_args=(value); end

  def self.specific_extra_args(cmd); end

  def self.specific_extra_args_hash(); end
end

class Gem::CommandLineError
  extend ::T::Sig
end

module Gem::Commands
end

module Gem::Commands
  extend ::T::Sig
end

class Gem::ConfigFile
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def api_keys(); end

  def args(); end

  def backtrace(); end

  def backtrace=(backtrace); end

  def bulk_threshold(); end

  def bulk_threshold=(bulk_threshold); end

  def check_credentials_permissions(); end

  def config_file_name(); end

  def credentials_path(); end

  def disable_default_gem_server(); end

  def disable_default_gem_server=(disable_default_gem_server); end

  def each(&block); end

  def handle_arguments(arg_list); end

  def home(); end

  def home=(home); end

  def initialize(args); end

  def load_api_keys(); end

  def load_file(filename); end

  def path(); end

  def path=(path); end

  def really_verbose(); end

  def rubygems_api_key(); end

  def rubygems_api_key=(api_key); end

  def set_api_key(host, api_key); end

  def sources(); end

  def sources=(sources); end

  def ssl_ca_cert(); end

  def ssl_ca_cert=(ssl_ca_cert); end

  def ssl_client_cert(); end

  def ssl_verify_mode(); end

  def to_yaml(); end

  def unset_api_key!(); end

  def update_sources(); end

  def update_sources=(update_sources); end

  def verbose(); end

  def verbose=(verbose); end

  def write(); end
  DEFAULT_BACKTRACE = ::T.let(nil, ::T.untyped)
  DEFAULT_BULK_THRESHOLD = ::T.let(nil, ::T.untyped)
  DEFAULT_UPDATE_SOURCES = ::T.let(nil, ::T.untyped)
  DEFAULT_VERBOSITY = ::T.let(nil, ::T.untyped)
  OPERATING_SYSTEM_DEFAULTS = ::T.let(nil, ::T.untyped)
  PLATFORM_DEFAULTS = ::T.let(nil, ::T.untyped)
  SYSTEM_CONFIG_PATH = ::T.let(nil, ::T.untyped)
  SYSTEM_WIDE_CONFIG_FILE = ::T.let(nil, ::T.untyped)
end

class Gem::ConfigFile
end

class Gem::ConflictError
  def conflicts(); end

  def initialize(target, conflicts); end

  def target(); end
end

class Gem::ConflictError
  extend ::T::Sig
end

class Gem::ConsoleUI
  def initialize(); end
end

class Gem::ConsoleUI
end

module Gem::DefaultUserInteraction
  include ::Gem::Text
  def ui(); end

  def ui=(new_ui); end

  def use_ui(new_ui, &block); end
end

module Gem::DefaultUserInteraction
  extend ::T::Sig
  def self.ui(); end

  def self.ui=(new_ui); end

  def self.use_ui(new_ui); end
end

class Gem::Dependency
  def ==(other); end

  def ===(other); end

  def =~(other); end

  def all_sources(); end

  def all_sources=(all_sources); end

  def encode_with(coder); end

  def eql?(other); end

  def groups(); end

  def groups=(groups); end

  def initialize(name, *requirements); end

  def latest_version?(); end

  def match?(obj, version=T.unsafe(nil), allow_prerelease=T.unsafe(nil)); end

  def matches_spec?(spec); end

  def matching_specs(platform_only=T.unsafe(nil)); end

  def merge(other); end

  def name(); end

  def name=(name); end

  def prerelease=(prerelease); end

  def prerelease?(); end

  def pretty_print(q); end

  def requirement(); end

  def requirements_list(); end

  def runtime?(); end

  def source(); end

  def source=(source); end

  def specific?(); end

  def to_lock(); end

  def to_spec(); end

  def to_specs(); end

  def to_yaml_properties(); end

  def type(); end
end

class Gem::Dependency
  extend ::T::Sig
end

class Gem::DependencyError
  extend ::T::Sig
end

class Gem::DependencyInstaller
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def _deprecated_gems_to_install(); end

  def add_found_dependencies(to_do, dependency_list); end

  def available_set_for(dep_or_name, version); end

  def consider_local?(); end

  def consider_remote?(); end

  def document(); end

  def errors(); end

  def find_gems_with_sources(dep, best_only=T.unsafe(nil)); end

  def find_spec_by_name_and_version(gem_name, version=T.unsafe(nil), prerelease=T.unsafe(nil)); end

  def gather_dependencies(); end

  def gems_to_install(*args, &block); end

  def in_background(what); end

  def initialize(options=T.unsafe(nil)); end

  def install(dep_or_name, version=T.unsafe(nil)); end

  def install_development_deps(); end

  def installed_gems(); end

  def resolve_dependencies(dep_or_name, version); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Gem::DependencyInstaller
  extend ::Gem::Deprecate
end

class Gem::DependencyList
  include ::Enumerable
  include ::TSort
  def add(*gemspecs); end

  def clear(); end

  def dependency_order(); end

  def development(); end

  def development=(development); end

  def each(&block); end

  def find_name(full_name); end

  def initialize(development=T.unsafe(nil)); end

  def ok?(); end

  def ok_to_remove?(full_name, check_dev=T.unsafe(nil)); end

  def remove_by_name(full_name); end

  def remove_specs_unsatisfied_by(dependencies); end

  def spec_predecessors(); end

  def specs(); end

  def tsort_each_node(&block); end

  def why_not_ok?(quick=T.unsafe(nil)); end
end

class Gem::DependencyList
  def self.from_specs(); end
end

class Gem::DependencyRemovalException
  extend ::T::Sig
end

class Gem::DependencyResolutionError
  def conflict(); end

  def conflicting_dependencies(); end

  def initialize(conflict); end
end

class Gem::DependencyResolutionError
  extend ::T::Sig
end

class Gem::Resolver
end

Gem::DependencyResolver::Conflict = Gem::Resolver::Conflict

Gem::DependencyResolver::DependencyConflict = Gem::Resolver::Conflict

module Gem::Resolver::Molinillo
end

Gem::DependencyResolver::Molinillo::SpecificationProvider = Gem::Resolver::Molinillo::SpecificationProvider

Gem::DependencyResolver::Molinillo::UI = Gem::Resolver::Molinillo::UI

module Gem::Resolver::Molinillo
end

class Gem::Resolver
end

module Gem::Deprecate
  extend ::T::Sig
  def self.deprecate(name, repl, year, month); end

  def self.skip(); end

  def self.skip=(v); end

  def self.skip_during(); end
end

class Gem::DocumentError
  extend ::T::Sig
end

class Gem::EndOfYAMLException
  extend ::T::Sig
end

class Gem::ErrorReason
  extend ::T::Sig
end

class Gem::Exception
  def source_exception(); end

  def source_exception=(source_exception); end
end

class Gem::Exception
  extend ::T::Sig
end

module Gem::Ext
end

class Gem::Ext::BuildError
end

class Gem::Ext::BuildError
end

class Gem::Ext::Builder
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def build_args(); end

  def build_args=(build_args); end

  def build_error(build_dir, output, backtrace=T.unsafe(nil)); end

  def build_extension(extension, dest_path); end

  def build_extensions(); end

  def builder_for(extension); end

  def initialize(spec, build_args=T.unsafe(nil)); end

  def write_gem_make_out(output); end
  CHDIR_MONITOR = ::T.let(nil, ::T.untyped)
  CHDIR_MUTEX = ::T.let(nil, ::T.untyped)
end

class Gem::Ext::Builder
  def self.class_name(); end

  def self.make(dest_path, results); end

  def self.redirector(); end

  def self.run(command, results, command_name=T.unsafe(nil)); end
end

class Gem::Ext::CmakeBuilder
end

class Gem::Ext::CmakeBuilder
  def self.build(extension, directory, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end
end

class Gem::Ext::ConfigureBuilder
end

class Gem::Ext::ConfigureBuilder
  def self.build(extension, directory, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end
end

class Gem::Ext::ExtConfBuilder
end

Gem::Ext::ExtConfBuilder::FileEntry = FileUtils::Entry_

class Gem::Ext::ExtConfBuilder
  def self.build(extension, directory, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end

  def self.get_relative_path(path); end
end

class Gem::Ext::RakeBuilder
end

class Gem::Ext::RakeBuilder
  def self.build(extension, directory, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end
end

module Gem::Ext
  extend ::T::Sig
end

class Gem::FilePermissionError
  def directory(); end

  def initialize(directory); end
end

class Gem::FilePermissionError
  extend ::T::Sig
end

class Gem::FormatException
  def file_path(); end

  def file_path=(file_path); end
end

class Gem::FormatException
  extend ::T::Sig
end

class Gem::GemNotFoundException
  extend ::T::Sig
end

class Gem::GemNotInHomeException
  def spec(); end

  def spec=(spec); end
end

class Gem::GemNotInHomeException
  extend ::T::Sig
end

class Gem::ImpossibleDependenciesError
  def build_message(); end

  def conflicts(); end

  def dependency(); end

  def initialize(request, conflicts); end

  def request(); end
end

class Gem::ImpossibleDependenciesError
  extend ::T::Sig
end

class Gem::InstallError
  extend ::T::Sig
end

class Gem::Installer
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def app_script_text(bin_file_name); end

  def bin_dir(); end

  def build_extensions(); end

  def build_root(); end

  def check_executable_overwrite(filename); end

  def check_that_user_bin_dir_is_in_path(); end

  def default_spec_file(); end

  def dir(); end

  def ensure_dependencies_met(); end

  def ensure_dependency(spec, dependency); end

  def ensure_loadable_spec(); end

  def ensure_required_ruby_version_met(); end

  def ensure_required_rubygems_version_met(); end

  def extension_build_error(build_dir, output, backtrace=T.unsafe(nil)); end

  def extract_bin(); end

  def extract_files(); end

  def formatted_program_filename(filename); end

  def gem(); end

  def gem_dir(); end

  def gem_home(); end

  def generate_bin(); end

  def generate_bin_script(filename, bindir); end

  def generate_bin_symlink(filename, bindir); end

  def generate_windows_script(filename, bindir); end

  def initialize(package, options=T.unsafe(nil)); end

  def install(); end

  def installation_satisfies_dependency?(dependency); end

  def installed_specs(); end

  def options(); end

  def pre_install_checks(); end

  def process_options(); end

  def run_post_build_hooks(); end

  def run_post_install_hooks(); end

  def run_pre_install_hooks(); end

  def shebang(bin_file_name); end

  def spec(); end

  def spec_file(); end

  def unpack(directory); end

  def verify_gem_home(unpack=T.unsafe(nil)); end

  def verify_spec(); end

  def windows_stub_script(bindir, bin_file_name); end

  def write_build_info_file(); end

  def write_cache_file(); end

  def write_default_spec(); end

  def write_spec(); end
  ENV_PATHS = ::T.let(nil, ::T.untyped)
end

class Gem::Installer
  def self.at(path, options=T.unsafe(nil)); end

  def self.exec_format(); end

  def self.exec_format=(exec_format); end

  def self.for_spec(spec, options=T.unsafe(nil)); end

  def self.install_lock(); end

  def self.path_warning(); end

  def self.path_warning=(path_warning); end
end

class Gem::InvalidSpecificationException
  extend ::T::Sig
end

class Gem::Licenses
  IDENTIFIERS = ::T.let(nil, ::T.untyped)
  NONSTANDARD = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
end

class Gem::Licenses
  extend ::Gem::Text
  def self.match?(license); end

  def self.suggestions(license); end
end

class Gem::List
  def each(); end

  def initialize(value=T.unsafe(nil), tail=T.unsafe(nil)); end

  def prepend(value); end

  def pretty_print(q); end

  def tail(); end

  def tail=(tail); end

  def to_a(); end

  def value(); end

  def value=(value); end
end

class Gem::List
  extend ::T::Sig
  def self.prepend(list, value); end
end

class Gem::LoadError
  def name(); end

  def name=(name); end

  def requirement(); end

  def requirement=(requirement); end
end

class Gem::LoadError
  extend ::T::Sig
end

class Gem::MissingSpecError
  def initialize(name, requirement); end
end

class Gem::MissingSpecError
  extend ::T::Sig
end

class Gem::MissingSpecVersionError
  def initialize(name, requirement, specs); end

  def specs(); end
end

class Gem::MissingSpecVersionError
  extend ::T::Sig
end

class Gem::NameTuple
  include ::Comparable
  def ==(other); end

  def eql?(other); end

  def full_name(); end

  def initialize(name, version, platform=T.unsafe(nil)); end

  def match_platform?(); end

  def name(); end

  def platform(); end

  def prerelease?(); end

  def spec_name(); end

  def to_a(); end

  def version(); end
end

class Gem::NameTuple
  def self.from_list(list); end

  def self.null(); end

  def self.to_basic(list); end
end

class Gem::OperationNotSupportedError
  extend ::T::Sig
end

class Gem::Package
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def add_checksums(tar); end

  def add_contents(tar); end

  def add_files(tar); end

  def add_metadata(tar); end

  def build(skip_validation=T.unsafe(nil)); end

  def build_time(); end

  def build_time=(build_time); end

  def checksums(); end

  def contents(); end

  def copy_to(path); end

  def digest(entry); end

  def extract_files(destination_dir, pattern=T.unsafe(nil)); end

  def extract_tar_gz(io, destination_dir, pattern=T.unsafe(nil)); end

  def files(); end

  def gzip_to(io); end

  def initialize(gem, security_policy); end

  def install_location(filename, destination_dir); end

  def load_spec(entry); end

  def mkdir_p_safe(mkdir, mkdir_options, destination_dir, file_name); end

  def open_tar_gz(io); end

  def read_checksums(gem); end

  def realpath(file); end

  def security_policy(); end

  def security_policy=(security_policy); end

  def setup_signer(); end

  def spec(); end

  def spec=(spec); end

  def verify(); end

  def verify_checksums(digests, checksums); end

  def verify_entry(entry); end

  def verify_files(gem); end

  def verify_gz(entry); end
end

class Gem::Package::DigestIO
  def digests(); end

  def initialize(io, digests); end

  def write(data); end
end

class Gem::Package::DigestIO
  def self.wrap(io, digests); end
end

class Gem::Package::Error
end

class Gem::Package::Error
end

class Gem::Package::FileSource
  def initialize(path); end

  def path(); end

  def present?(); end

  def start(); end

  def with_read_io(&block); end

  def with_write_io(&block); end
end

class Gem::Package::FileSource
end

class Gem::Package::FormatError
  def initialize(message, source=T.unsafe(nil)); end

  def path(); end
end

class Gem::Package::FormatError
end

class Gem::Package::IOSource
  def initialize(io); end

  def io(); end

  def path(); end

  def present?(); end

  def start(); end

  def with_read_io(); end

  def with_write_io(); end
end

class Gem::Package::IOSource
end

class Gem::Package::NonSeekableIO
end

class Gem::Package::NonSeekableIO
end

class Gem::Package::Old
  def extract_files(destination_dir); end

  def file_list(io); end

  def read_until_dashes(io); end

  def skip_ruby(io); end
end

class Gem::Package::Old
end

class Gem::Package::PathError
  def initialize(destination, destination_dir); end
end

class Gem::Package::PathError
end

class Gem::Package::Source
end

class Gem::Package::Source
end

class Gem::Package::TarHeader
  def ==(other); end

  def checksum(); end

  def devmajor(); end

  def devminor(); end

  def empty?(); end

  def gid(); end

  def gname(); end

  def initialize(vals); end

  def linkname(); end

  def magic(); end

  def mode(); end

  def mtime(); end

  def name(); end

  def prefix(); end

  def size(); end

  def typeflag(); end

  def uid(); end

  def uname(); end

  def update_checksum(); end

  def version(); end
  FIELDS = ::T.let(nil, ::T.untyped)
  PACK_FORMAT = ::T.let(nil, ::T.untyped)
  UNPACK_FORMAT = ::T.let(nil, ::T.untyped)
end

class Gem::Package::TarHeader
  def self.from(stream); end

  def self.strict_oct(str); end
end

class Gem::Package::TarInvalidError
end

class Gem::Package::TarInvalidError
end

class Gem::Package::TarReader
  include ::Enumerable
  def close(); end

  def each(); end

  def each_entry(); end

  def initialize(io); end

  def rewind(); end

  def seek(name); end
end

class Gem::Package::TarReader::Entry
  def bytes_read(); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def directory?(); end

  def eof?(); end

  def file?(); end

  def full_name(); end

  def getc(); end

  def header(); end

  def initialize(header, io); end

  def pos(); end

  def read(len=T.unsafe(nil)); end

  def readpartial(len=T.unsafe(nil)); end

  def rewind(); end

  def symlink?(); end
end

class Gem::Package::TarReader::Entry
end

class Gem::Package::TarReader::UnexpectedEOF
end

class Gem::Package::TarReader::UnexpectedEOF
end

class Gem::Package::TarReader
  def self.new(io); end
end

class Gem::Package::TarWriter
  def add_file(name, mode); end

  def add_file_digest(name, mode, digest_algorithms); end

  def add_file_signed(name, mode, signer); end

  def add_file_simple(name, mode, size); end

  def add_symlink(name, target, mode); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def flush(); end

  def initialize(io); end

  def mkdir(name, mode); end

  def split_name(name); end
end

class Gem::Package::TarWriter::BoundedStream
  def initialize(io, limit); end

  def limit(); end

  def write(data); end

  def written(); end
end

class Gem::Package::TarWriter::BoundedStream
end

class Gem::Package::TarWriter::FileOverflow
end

class Gem::Package::TarWriter::FileOverflow
end

class Gem::Package::TarWriter::RestrictedStream
  def initialize(io); end

  def write(data); end
end

class Gem::Package::TarWriter::RestrictedStream
end

class Gem::Package::TarWriter
  def self.new(io); end
end

class Gem::Package::TooLongFileName
end

class Gem::Package::TooLongFileName
end

class Gem::Package
  def self.build(spec, skip_validation=T.unsafe(nil)); end

  def self.new(gem, security_policy=T.unsafe(nil)); end
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::PathSupport
  extend ::T::Sig
end

class Gem::Platform
  def ==(other); end

  def ===(other); end

  def =~(other); end

  def cpu(); end

  def cpu=(cpu); end

  def eql?(other); end

  def initialize(arch); end

  def os(); end

  def os=(os); end

  def to_a(); end

  def version(); end

  def version=(version); end
  JAVA = ::T.let(nil, ::T.untyped)
  MINGW = ::T.let(nil, ::T.untyped)
  MSWIN = ::T.let(nil, ::T.untyped)
  MSWIN64 = ::T.let(nil, ::T.untyped)
  X64_MINGW = ::T.let(nil, ::T.untyped)
end

class Gem::Platform
  extend ::T::Sig
  def self.installable?(spec); end

  def self.local(); end

  def self.match(platform); end

  def self.new(arch); end
end

class Gem::PlatformMismatch
  def add_platform(platform); end

  def initialize(name, version); end

  def name(); end

  def platforms(); end

  def version(); end

  def wordy(); end
end

class Gem::PlatformMismatch
  extend ::T::Sig
end

class Gem::RemoteError
  extend ::T::Sig
end

class Gem::RemoteFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def api_endpoint(uri); end

  def cache_update_path(uri, path=T.unsafe(nil), update=T.unsafe(nil)); end

  def close_all(); end

  def correct_for_windows_path(path); end

  def download(spec, source_uri, install_dir=T.unsafe(nil)); end

  def download_to_cache(dependency); end

  def fetch_file(uri, *_); end

  def fetch_http(uri, last_modified=T.unsafe(nil), head=T.unsafe(nil), depth=T.unsafe(nil)); end

  def fetch_https(uri, last_modified=T.unsafe(nil), head=T.unsafe(nil), depth=T.unsafe(nil)); end

  def fetch_path(uri, mtime=T.unsafe(nil), head=T.unsafe(nil)); end

  def fetch_s3(uri, mtime=T.unsafe(nil), head=T.unsafe(nil)); end

  def fetch_size(uri); end

  def headers(); end

  def headers=(headers); end

  def https?(uri); end

  def initialize(proxy=T.unsafe(nil), dns=T.unsafe(nil), headers=T.unsafe(nil)); end

  def request(uri, request_class, last_modified=T.unsafe(nil)); end

  def s3_expiration(); end

  def sign_s3_url(uri, expiration=T.unsafe(nil)); end
  BASE64_URI_TRANSLATE = ::T.let(nil, ::T.untyped)
end

class Gem::RemoteFetcher
  def self.fetcher(); end
end

class Gem::RemoteInstallationCancelled
  extend ::T::Sig
end

class Gem::RemoteInstallationSkipped
  extend ::T::Sig
end

class Gem::RemoteSourceException
  extend ::T::Sig
end

class Gem::Request
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def cert_files(); end

  def connection_for(uri); end

  def fetch(); end

  def initialize(uri, request_class, last_modified, pool); end

  def perform_request(request); end

  def proxy_uri(); end

  def reset(connection); end

  def user_agent(); end
end

class Gem::Request::ConnectionPools
  def close_all(); end

  def initialize(proxy_uri, cert_files); end

  def pool_for(uri); end
end

class Gem::Request::ConnectionPools
  def self.client(); end

  def self.client=(client); end
end

class Gem::Request::HTTPPool
  def cert_files(); end

  def checkin(connection); end

  def checkout(); end

  def close_all(); end

  def initialize(http_args, cert_files, proxy_uri); end

  def proxy_uri(); end
end

class Gem::Request::HTTPPool
end

class Gem::Request::HTTPSPool
end

class Gem::Request::HTTPSPool
end

class Gem::Request
  extend ::Gem::UserInteraction
  extend ::Gem::DefaultUserInteraction
  extend ::Gem::Text
  def self.configure_connection_for_https(connection, cert_files); end

  def self.create_with_proxy(uri, request_class, last_modified, proxy); end

  def self.get_cert_files(); end

  def self.get_proxy_from_env(scheme=T.unsafe(nil)); end

  def self.proxy_uri(proxy); end

  def self.verify_certificate(store_context); end

  def self.verify_certificate_message(error_number, cert); end
end

class Gem::RequestSet
  include ::TSort
  def always_install(); end

  def always_install=(always_install); end

  def dependencies(); end

  def development(); end

  def development=(development); end

  def development_shallow(); end

  def development_shallow=(development_shallow); end

  def errors(); end

  def gem(name, *reqs); end

  def git_set(); end

  def ignore_dependencies(); end

  def ignore_dependencies=(ignore_dependencies); end

  def import(deps); end

  def initialize(*deps); end

  def install(options, &block); end

  def install_dir(); end

  def install_from_gemdeps(options, &block); end

  def install_into(dir, force=T.unsafe(nil), options=T.unsafe(nil)); end

  def load_gemdeps(path, without_groups=T.unsafe(nil), installing=T.unsafe(nil)); end

  def prerelease(); end

  def prerelease=(prerelease); end

  def pretty_print(q); end

  def remote(); end

  def remote=(remote); end

  def resolve(set=T.unsafe(nil)); end

  def resolve_current(); end

  def resolver(); end

  def sets(); end

  def soft_missing(); end

  def soft_missing=(soft_missing); end

  def sorted_requests(); end

  def source_set(); end

  def specs(); end

  def specs_in(dir); end

  def tsort_each_node(&block); end

  def vendor_set(); end
end

Gem::RequestSet::GemDepedencyAPI = Gem::RequestSet::GemDependencyAPI

class Gem::RequestSet::GemDependencyAPI
  def dependencies(); end

  def find_gemspec(name, path); end

  def gem(name, *requirements); end

  def gem_deps_file(); end

  def gem_git_reference(options); end

  def gemspec(options=T.unsafe(nil)); end

  def git(repository); end

  def git_set(); end

  def git_source(name, &callback); end

  def group(*groups); end

  def initialize(set, path); end

  def installing=(installing); end

  def load(); end

  def platform(*platforms); end

  def platforms(*platforms); end

  def requires(); end

  def ruby(version, options=T.unsafe(nil)); end

  def source(url); end

  def vendor_set(); end

  def without_groups(); end

  def without_groups=(without_groups); end
  ENGINE_MAP = ::T.let(nil, ::T.untyped)
  PLATFORM_MAP = ::T.let(nil, ::T.untyped)
  VERSION_MAP = ::T.let(nil, ::T.untyped)
  WINDOWS = ::T.let(nil, ::T.untyped)
end

class Gem::RequestSet::GemDependencyAPI
end

class Gem::RequestSet::Lockfile
  def add_DEPENDENCIES(out); end

  def add_GEM(out, spec_groups); end

  def add_GIT(out, git_requests); end

  def add_PATH(out, path_requests); end

  def add_PLATFORMS(out); end

  def initialize(request_set, gem_deps_file, dependencies); end

  def platforms(); end

  def relative_path_from(dest, base); end

  def spec_groups(); end

  def write(); end
end

class Gem::RequestSet::Lockfile::ParseError
  def column(); end

  def initialize(message, column, line, path); end

  def line(); end

  def path(); end
end

class Gem::RequestSet::Lockfile::ParseError
end

class Gem::RequestSet::Lockfile::Parser
  def get(expected_types=T.unsafe(nil), expected_value=T.unsafe(nil)); end

  def initialize(tokenizer, set, platforms, filename=T.unsafe(nil)); end

  def parse(); end

  def parse_DEPENDENCIES(); end

  def parse_GEM(); end

  def parse_GIT(); end

  def parse_PATH(); end

  def parse_PLATFORMS(); end

  def parse_dependency(name, op); end
end

class Gem::RequestSet::Lockfile::Parser
end

class Gem::RequestSet::Lockfile::Tokenizer
  def empty?(); end

  def initialize(input, filename=T.unsafe(nil), line=T.unsafe(nil), pos=T.unsafe(nil)); end

  def make_parser(set, platforms); end

  def next_token(); end

  def peek(); end

  def shift(); end

  def skip(type); end

  def to_a(); end

  def token_pos(byte_offset); end

  def unshift(token); end
  EOF = ::T.let(nil, ::T.untyped)
end

class Gem::RequestSet::Lockfile::Tokenizer::Token
  def column(); end

  def column=(_); end

  def line(); end

  def line=(_); end

  def type(); end

  def type=(_); end

  def value(); end

  def value=(_); end
end

class Gem::RequestSet::Lockfile::Tokenizer::Token
  def self.[](*_); end

  def self.members(); end
end

class Gem::RequestSet::Lockfile::Tokenizer
  def self.from_file(file); end
end

class Gem::RequestSet::Lockfile
  def self.build(request_set, gem_deps_file, dependencies=T.unsafe(nil)); end

  def self.requests_to_deps(requests); end
end

class Gem::RequestSet
end

class Gem::Requirement
  def ==(other); end

  def ===(version); end

  def =~(version); end

  def as_list(); end

  def concat(new); end

  def encode_with(coder); end

  def exact?(); end

  def for_lockfile(); end

  def init_with(coder); end

  def initialize(*requirements); end

  def marshal_dump(); end

  def marshal_load(array); end

  def none?(); end

  def prerelease?(); end

  def pretty_print(q); end

  def requirements(); end

  def satisfied_by?(version); end

  def specific?(); end

  def to_yaml_properties(); end

  def yaml_initialize(tag, vals); end
  DefaultRequirement = ::T.let(nil, ::T.untyped)
end

class Gem::Requirement::BadRequirementError
  extend ::T::Sig
end

class Gem::Requirement
  extend ::T::Sig
  def self.create(*inputs); end

  def self.default(); end

  def self.parse(obj); end

  def self.source_set(); end
end

class Gem::Resolver
  include ::Gem::Resolver::Molinillo::UI
  include ::Gem::Resolver::Molinillo::SpecificationProvider
  def activation_request(dep, possible); end

  def development(); end

  def development=(development); end

  def development_shallow(); end

  def development_shallow=(development_shallow); end

  def explain(stage, *data); end

  def explain_list(stage); end

  def find_possible(dependency); end

  def ignore_dependencies(); end

  def ignore_dependencies=(ignore_dependencies); end

  def initialize(needed, set=T.unsafe(nil)); end

  def missing(); end

  def requests(s, act, reqs=T.unsafe(nil)); end

  def resolve(); end

  def select_local_platforms(specs); end

  def skip_gems(); end

  def skip_gems=(skip_gems); end

  def soft_missing(); end

  def soft_missing=(soft_missing); end

  def stats(); end
  DEBUG_RESOLVER = ::T.let(nil, ::T.untyped)
end

class Gem::Resolver::APISet
  def dep_uri(); end

  def initialize(dep_uri=T.unsafe(nil)); end

  def prefetch_now(); end

  def pretty_print(q); end

  def source(); end

  def uri(); end

  def versions(name); end
end

class Gem::Resolver::APISet
end

class Gem::Resolver::APISpecification
  def ==(other); end

  def initialize(set, api_data); end

  def pretty_print(q); end
end

class Gem::Resolver::APISpecification
end

class Gem::Resolver::ActivationRequest
  def ==(other); end

  def development?(); end

  def download(path); end

  def full_name(); end

  def full_spec(); end

  def initialize(spec, request, others_possible=T.unsafe(nil)); end

  def installed?(); end

  def name(); end

  def others_possible?(); end

  def parent(); end

  def pretty_print(q); end

  def request(); end

  def spec(); end

  def version(); end
end

class Gem::Resolver::ActivationRequest
end

class Gem::Resolver::BestSet
  def initialize(sources=T.unsafe(nil)); end

  def pick_sets(); end

  def pretty_print(q); end

  def replace_failed_api_set(error); end
end

class Gem::Resolver::BestSet
end

class Gem::Resolver::ComposedSet
  def initialize(*sets); end

  def prerelease=(allow_prerelease); end

  def remote=(remote); end

  def sets(); end
end

class Gem::Resolver::ComposedSet
end

class Gem::Resolver::Conflict
  def ==(other); end

  def activated(); end

  def conflicting_dependencies(); end

  def dependency(); end

  def explain(); end

  def explanation(); end

  def failed_dep(); end

  def for_spec?(spec); end

  def initialize(dependency, activated, failed_dep=T.unsafe(nil)); end

  def pretty_print(q); end

  def request_path(current); end

  def requester(); end
end

class Gem::Resolver::Conflict
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::DependencyRequest
  def ==(other); end

  def dependency(); end

  def development?(); end

  def explicit?(); end

  def implicit?(); end

  def initialize(dependency, requester); end

  def match?(spec, allow_prerelease=T.unsafe(nil)); end

  def matches_spec?(spec); end

  def name(); end

  def pretty_print(q); end

  def request_context(); end

  def requester(); end

  def requirement(); end

  def type(); end
end

class Gem::Resolver::DependencyRequest
end

class Gem::Resolver::GitSet
  def add_git_gem(name, repository, reference, submodules); end

  def add_git_spec(name, version, repository, reference, submodules); end

  def need_submodules(); end

  def pretty_print(q); end

  def repositories(); end

  def root_dir(); end

  def root_dir=(root_dir); end

  def specs(); end
end

class Gem::Resolver::GitSet
end

class Gem::Resolver::GitSpecification
  def ==(other); end

  def add_dependency(dependency); end

  def pretty_print(q); end
end

class Gem::Resolver::GitSpecification
end

class Gem::Resolver::IndexSet
  def initialize(source=T.unsafe(nil)); end

  def pretty_print(q); end
end

class Gem::Resolver::IndexSet
end

class Gem::Resolver::IndexSpecification
  def initialize(set, name, version, source, platform); end

  def pretty_print(q); end
end

class Gem::Resolver::IndexSpecification
end

class Gem::Resolver::InstalledSpecification
  def ==(other); end

  def pretty_print(q); end
end

class Gem::Resolver::InstalledSpecification
end

class Gem::Resolver::InstallerSet
  def add_always_install(dependency); end

  def add_local(dep_name, spec, source); end

  def always_install(); end

  def consider_local?(); end

  def consider_remote?(); end

  def ignore_dependencies(); end

  def ignore_dependencies=(ignore_dependencies); end

  def ignore_installed(); end

  def ignore_installed=(ignore_installed); end

  def initialize(domain); end

  def load_spec(name, ver, platform, source); end

  def local?(dep_name); end

  def prerelease=(allow_prerelease); end

  def pretty_print(q); end

  def remote=(remote); end

  def remote_set(); end
end

class Gem::Resolver::InstallerSet
end

class Gem::Resolver::LocalSpecification
  def pretty_print(q); end
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LockSet
  def add(name, version, platform); end

  def initialize(sources); end

  def load_spec(name, version, platform, source); end

  def pretty_print(q); end

  def specs(); end
end

class Gem::Resolver::LockSet
end

class Gem::Resolver::LockSpecification
  def add_dependency(dependency); end

  def initialize(set, name, version, sources, platform); end

  def pretty_print(q); end

  def sources(); end
end

class Gem::Resolver::LockSpecification
end

module Gem::Resolver::Molinillo
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Resolver::Molinillo::CircularDependencyError
  def dependencies(); end

  def initialize(nodes); end
end

class Gem::Resolver::Molinillo::CircularDependencyError
end

module Gem::Resolver::Molinillo::Delegates
end

module Gem::Resolver::Molinillo::Delegates::ResolutionState
  def activated(); end

  def conflicts(); end

  def depth(); end

  def name(); end

  def possibilities(); end

  def requirement(); end

  def requirements(); end
end

module Gem::Resolver::Molinillo::Delegates::ResolutionState
  extend ::T::Sig
end

module Gem::Resolver::Molinillo::Delegates::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Gem::Resolver::Molinillo::Delegates::SpecificationProvider
  extend ::T::Sig
end

module Gem::Resolver::Molinillo::Delegates
  extend ::T::Sig
end

class Gem::Resolver::Molinillo::DependencyGraph
  include ::Enumerable
  include ::TSort
  def ==(other); end

  def add_child_vertex(name, payload, parent_names, requirement); end

  def add_edge(origin, destination, requirement); end

  def add_vertex(name, payload, root=T.unsafe(nil)); end

  def delete_edge(edge); end

  def detach_vertex_named(name); end

  def each(); end

  def log(); end

  def rewind_to(tag); end

  def root_vertex_named(name); end

  def set_payload(name, payload); end

  def tag(tag); end

  def to_dot(options=T.unsafe(nil)); end

  def tsort_each_child(vertex, &block); end

  def vertex_named(name); end

  def vertices(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Action
  def down(graph); end

  def next(); end

  def next=(_); end

  def previous(); end

  def previous=(previous); end

  def up(graph); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Action
  def self.action_name(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::AddEdgeNoCircular
  def destination(); end

  def initialize(origin, destination, requirement); end

  def make_edge(graph); end

  def origin(); end

  def requirement(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::AddEdgeNoCircular
end

class Gem::Resolver::Molinillo::DependencyGraph::AddVertex
  def initialize(name, payload, root); end

  def name(); end

  def payload(); end

  def root(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::AddVertex
end

class Gem::Resolver::Molinillo::DependencyGraph::DeleteEdge
  def destination_name(); end

  def initialize(origin_name, destination_name, requirement); end

  def make_edge(graph); end

  def origin_name(); end

  def requirement(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::DeleteEdge
end

class Gem::Resolver::Molinillo::DependencyGraph::DetachVertexNamed
  def initialize(name); end

  def name(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::DetachVertexNamed
end

class Gem::Resolver::Molinillo::DependencyGraph::Edge
  def destination(); end

  def destination=(_); end

  def origin(); end

  def origin=(_); end

  def requirement(); end

  def requirement=(_); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Edge
  def self.[](*_); end

  def self.members(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::Resolver::Molinillo::DependencyGraph::SetPayload
  def initialize(name, payload); end

  def name(); end

  def payload(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::SetPayload
end

class Gem::Resolver::Molinillo::DependencyGraph::Tag
  def down(_graph); end

  def initialize(tag); end

  def tag(); end

  def up(_graph); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Tag
end

class Gem::Resolver::Molinillo::DependencyGraph::Vertex
  def ==(other); end

  def ancestor?(other); end

  def descendent?(other); end

  def eql?(other); end

  def explicit_requirements(); end

  def incoming_edges(); end

  def incoming_edges=(incoming_edges); end

  def initialize(name, payload); end

  def is_reachable_from?(other); end

  def name(); end

  def name=(name); end

  def outgoing_edges(); end

  def outgoing_edges=(outgoing_edges); end

  def path_to?(other); end

  def payload(); end

  def payload=(payload); end

  def predecessors(); end

  def recursive_predecessors(); end

  def recursive_successors(); end

  def requirements(); end

  def root(); end

  def root=(root); end

  def root?(); end

  def shallow_eql?(other); end

  def successors(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Vertex
end

class Gem::Resolver::Molinillo::DependencyGraph
  def self.tsort(vertices); end
end

class Gem::Resolver::Molinillo::DependencyState
  def pop_possibility_state(); end
end

class Gem::Resolver::Molinillo::DependencyState
end

class Gem::Resolver::Molinillo::NoSuchDependencyError
  def dependency(); end

  def dependency=(dependency); end

  def initialize(dependency, required_by=T.unsafe(nil)); end

  def required_by(); end

  def required_by=(required_by); end
end

class Gem::Resolver::Molinillo::NoSuchDependencyError
end

class Gem::Resolver::Molinillo::PossibilityState
end

class Gem::Resolver::Molinillo::PossibilityState
end

class Gem::Resolver::Molinillo::ResolutionState
  def activated(); end

  def activated=(_); end

  def conflicts(); end

  def conflicts=(_); end

  def depth(); end

  def depth=(_); end

  def name(); end

  def name=(_); end

  def possibilities(); end

  def possibilities=(_); end

  def requirement(); end

  def requirement=(_); end

  def requirements(); end

  def requirements=(_); end
end

class Gem::Resolver::Molinillo::ResolutionState
  def self.[](*_); end

  def self.empty(); end

  def self.members(); end
end

class Gem::Resolver::Molinillo::Resolver
  def initialize(specification_provider, resolver_ui); end

  def resolve(requested, base=T.unsafe(nil)); end

  def resolver_ui(); end

  def specification_provider(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution
  include ::Gem::Resolver::Molinillo::Delegates::ResolutionState
  include ::Gem::Resolver::Molinillo::Delegates::SpecificationProvider
  def base(); end

  def initialize(specification_provider, resolver_ui, requested, base); end

  def iteration_rate=(iteration_rate); end

  def original_requested(); end

  def resolve(); end

  def resolver_ui(); end

  def specification_provider(); end

  def started_at=(started_at); end

  def states=(states); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::Conflict
  def activated_by_name(); end

  def activated_by_name=(_); end

  def existing(); end

  def existing=(_); end

  def locked_requirement(); end

  def locked_requirement=(_); end

  def possibility(); end

  def possibility=(_); end

  def requirement(); end

  def requirement=(_); end

  def requirement_trees(); end

  def requirement_trees=(_); end

  def requirements(); end

  def requirements=(_); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::Conflict
  def self.[](*_); end

  def self.members(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution
end

class Gem::Resolver::Molinillo::Resolver
end

class Gem::Resolver::Molinillo::ResolverError
end

class Gem::Resolver::Molinillo::ResolverError
end

module Gem::Resolver::Molinillo::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Gem::Resolver::Molinillo::SpecificationProvider
  extend ::T::Sig
end

module Gem::Resolver::Molinillo::UI
  def after_resolution(); end

  def before_resolution(); end

  def debug(depth=T.unsafe(nil)); end

  def debug?(); end

  def indicate_progress(); end

  def output(); end

  def progress_rate(); end
end

module Gem::Resolver::Molinillo::UI
  extend ::T::Sig
end

class Gem::Resolver::Molinillo::VersionConflict
  def conflicts(); end

  def initialize(conflicts); end
end

class Gem::Resolver::Molinillo::VersionConflict
end

module Gem::Resolver::Molinillo
  extend ::T::Sig
end

class Gem::Resolver::RequirementList
  include ::Enumerable
  def add(req); end

  def each(); end

  def empty?(); end

  def next5(); end

  def remove(); end

  def size(); end
end

class Gem::Resolver::RequirementList
end

class Gem::Resolver::Set
  def errors(); end

  def errors=(errors); end

  def find_all(req); end

  def prefetch(reqs); end

  def prerelease(); end

  def prerelease=(prerelease); end

  def remote(); end

  def remote=(remote); end

  def remote?(); end
end

class Gem::Resolver::Set
end

class Gem::Resolver::SourceSet
  def add_source_gem(name, source); end
end

class Gem::Resolver::SourceSet
end

class Gem::Resolver::SpecSpecification
  def initialize(set, spec, source=T.unsafe(nil)); end
end

class Gem::Resolver::SpecSpecification
end

class Gem::Resolver::Specification
  def dependencies(); end

  def fetch_development_dependencies(); end

  def full_name(); end

  def install(options=T.unsafe(nil)); end

  def installable_platform?(); end

  def local?(); end

  def name(); end

  def platform(); end

  def set(); end

  def source(); end

  def spec(); end

  def version(); end
end

class Gem::Resolver::Specification
end

class Gem::Resolver::Stats
  def backtracking!(); end

  def display(); end

  def iteration!(); end

  def record_depth(stack); end

  def record_requirements(reqs); end

  def requirement!(); end
  PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::Resolver::Stats
end

class Gem::Resolver::VendorSet
  def add_vendor_gem(name, directory); end

  def load_spec(name, version, platform, source); end

  def pretty_print(q); end

  def specs(); end
end

class Gem::Resolver::VendorSet
end

class Gem::Resolver::VendorSpecification
  def ==(other); end
end

class Gem::Resolver::VendorSpecification
end

class Gem::Resolver
  def self.compose_sets(*sets); end

  def self.for_current_gems(needed); end
end

class Gem::RubyVersionMismatch
  extend ::T::Sig
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

module Gem::Security
  AlmostNoSecurity = ::T.let(nil, ::T.untyped)
  DIGEST_NAME = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  HighSecurity = ::T.let(nil, ::T.untyped)
  KEY_CIPHER = ::T.let(nil, ::T.untyped)
  KEY_LENGTH = ::T.let(nil, ::T.untyped)
  LowSecurity = ::T.let(nil, ::T.untyped)
  MediumSecurity = ::T.let(nil, ::T.untyped)
  NoSecurity = ::T.let(nil, ::T.untyped)
  ONE_DAY = ::T.let(nil, ::T.untyped)
  ONE_YEAR = ::T.let(nil, ::T.untyped)
  Policies = ::T.let(nil, ::T.untyped)
  SigningPolicy = ::T.let(nil, ::T.untyped)
end

class Gem::Security::DIGEST_ALGORITHM
  def initialize(data=T.unsafe(nil)); end
end

class Gem::Security::DIGEST_ALGORITHM
  def self.digest(data); end

  def self.hexdigest(data); end
end

class Gem::Security::Exception
end

class Gem::Security::Exception
end

Gem::Security::KEY_ALGORITHM = OpenSSL::PKey::RSA

class Gem::Security::Policy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def check_cert(signer, issuer, time); end

  def check_chain(chain, time); end

  def check_data(public_key, digest, signature, data); end

  def check_key(signer, key); end

  def check_root(chain, time); end

  def check_trust(chain, digester, trust_dir); end

  def initialize(name, policy=T.unsafe(nil), opt=T.unsafe(nil)); end

  def name(); end

  def only_signed(); end

  def only_signed=(only_signed); end

  def only_trusted(); end

  def only_trusted=(only_trusted); end

  def subject(certificate); end

  def verify(chain, key=T.unsafe(nil), digests=T.unsafe(nil), signatures=T.unsafe(nil), full_name=T.unsafe(nil)); end

  def verify_chain(); end

  def verify_chain=(verify_chain); end

  def verify_data(); end

  def verify_data=(verify_data); end

  def verify_root(); end

  def verify_root=(verify_root); end

  def verify_signatures(spec, digests, signatures); end

  def verify_signer(); end

  def verify_signer=(verify_signer); end
end

class Gem::Security::Policy
end

class Gem::Security::Signer
  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def digest_algorithm(); end

  def digest_name(); end

  def extract_name(cert); end

  def initialize(key, cert_chain, passphrase=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def load_cert_chain(); end

  def re_sign_key(); end

  def sign(data); end
end

class Gem::Security::Signer
end

class Gem::Security::TrustDir
  def cert_path(certificate); end

  def dir(); end

  def each_certificate(); end

  def initialize(dir, permissions=T.unsafe(nil)); end

  def issuer_of(certificate); end

  def load_certificate(certificate_file); end

  def name_path(name); end

  def trust_cert(certificate); end

  def verify(); end
  DEFAULT_PERMISSIONS = ::T.let(nil, ::T.untyped)
end

class Gem::Security::TrustDir
end

module Gem::Security
  extend ::T::Sig
  def self.alt_name_or_x509_entry(certificate, x509_entry); end

  def self.create_cert(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_cert_email(email, key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.create_cert_self_signed(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_key(length=T.unsafe(nil), algorithm=T.unsafe(nil)); end

  def self.email_to_name(email_address); end

  def self.re_sign(expired_certificate, private_key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.reset(); end

  def self.sign(certificate, signing_key, signing_cert, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.trust_dir(); end

  def self.trusted_certificates(&block); end

  def self.write(pemmable, path, permissions=T.unsafe(nil), passphrase=T.unsafe(nil), cipher=T.unsafe(nil)); end
end

class Gem::SilentUI
  def initialize(); end
end

class Gem::SilentUI
end

class Gem::Source
  include ::Comparable
  def ==(other); end

  def api_uri(); end

  def cache_dir(uri); end

  def dependency_resolver_set(); end

  def download(spec, dir=T.unsafe(nil)); end

  def eql?(other); end

  def fetch_spec(name_tuple); end

  def initialize(uri); end

  def load_specs(type); end

  def pretty_print(q); end

  def update_cache?(); end

  def uri(); end
  FILES = ::T.let(nil, ::T.untyped)
end

class Gem::Source::Git
  def base_dir(); end

  def cache(); end

  def checkout(); end

  def dir_shortref(); end

  def download(full_spec, path); end

  def initialize(name, repository, reference, submodules=T.unsafe(nil)); end

  def install_dir(); end

  def name(); end

  def need_submodules(); end

  def reference(); end

  def remote(); end

  def remote=(remote); end

  def repo_cache_dir(); end

  def repository(); end

  def rev_parse(); end

  def root_dir(); end

  def root_dir=(root_dir); end

  def specs(); end

  def uri_hash(); end
end

class Gem::Source::Git
end

class Gem::Source::Installed
  def download(spec, path); end

  def initialize(); end
end

class Gem::Source::Installed
end

class Gem::Source::Local
  def download(spec, cache_dir=T.unsafe(nil)); end

  def fetch_spec(name); end

  def find_gem(gem_name, version=T.unsafe(nil), prerelease=T.unsafe(nil)); end

  def initialize(); end
end

class Gem::Source::Local
end

class Gem::Source::Lock
  def initialize(source); end

  def wrapped(); end
end

class Gem::Source::Lock
end

class Gem::Source::SpecificFile
  def fetch_spec(name); end

  def initialize(file); end

  def load_specs(*a); end

  def path(); end

  def spec(); end
end

class Gem::Source::SpecificFile
end

class Gem::Source::Vendor
  def initialize(path); end
end

class Gem::Source::Vendor
end

class Gem::Source
end

class Gem::SourceFetchProblem
  def error(); end

  def exception(); end

  def initialize(source, error); end

  def source(); end

  def wordy(); end
end

class Gem::SourceFetchProblem
  extend ::T::Sig
end

class Gem::SourceList
  include ::Enumerable
  def <<(obj); end

  def ==(other); end

  def clear(); end

  def delete(source); end

  def each(); end

  def each_source(&b); end

  def empty?(); end

  def first(); end

  def include?(other); end

  def replace(other); end

  def sources(); end

  def to_a(); end

  def to_ary(); end
end

class Gem::SourceList
  def self.from(ary); end
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::SpecificGemNotFoundException
  def errors(); end

  def initialize(name, version, errors=T.unsafe(nil)); end

  def name(); end

  def version(); end
end

class Gem::SpecificGemNotFoundException
  extend ::T::Sig
end

class Gem::Specification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def ==(other); end

  def _dump(limit); end

  def abbreviate(); end

  def activate(); end

  def activate_dependencies(); end

  def activated(); end

  def activated=(activated); end

  def add_bindir(executables); end

  def add_dependency(gem, *requirements); end

  def add_development_dependency(gem, *requirements); end

  def add_runtime_dependency(gem, *requirements); end

  def add_self_to_load_path(); end

  def author(); end

  def author=(o); end

  def authors(); end

  def authors=(value); end

  def autorequire(); end

  def autorequire=(autorequire); end

  def bin_dir(); end

  def bin_file(name); end

  def bindir(); end

  def bindir=(bindir); end

  def build_args(); end

  def build_extensions(); end

  def build_info_dir(); end

  def build_info_file(); end

  def bundled_gem_in_old_ruby?(); end

  def cache_dir(); end

  def cache_file(); end

  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def conficts_when_loaded_with?(list_of_specs); end

  def conflicts(); end

  def date(); end

  def date=(date); end

  def default_executable(); end

  def default_executable=(default_executable); end

  def default_value(name); end

  def dependencies(); end

  def dependent_gems(); end

  def dependent_specs(); end

  def description(); end

  def description=(str); end

  def development_dependencies(); end

  def doc_dir(type=T.unsafe(nil)); end

  def email(); end

  def email=(email); end

  def encode_with(coder); end

  def eql?(other); end

  def executable(); end

  def executable=(o); end

  def executables(); end

  def executables=(value); end

  def extensions(); end

  def extensions=(extensions); end

  def extra_rdoc_files(); end

  def extra_rdoc_files=(files); end

  def file_name(); end

  def files(); end

  def files=(files); end

  def for_cache(); end

  def git_version(); end

  def groups(); end

  def has_conflicts?(); end

  def has_rdoc(); end

  def has_rdoc=(ignored); end

  def has_rdoc?(); end

  def has_test_suite?(); end

  def has_unit_tests?(); end

  def homepage(); end

  def homepage=(homepage); end

  def init_with(coder); end

  def initialize(name=T.unsafe(nil), version=T.unsafe(nil)); end

  def installed_by_version(); end

  def installed_by_version=(version); end

  def lib_files(); end

  def license(); end

  def license=(o); end

  def licenses(); end

  def licenses=(licenses); end

  def load_paths(); end

  def location(); end

  def location=(location); end

  def mark_version(); end

  def metadata(); end

  def metadata=(metadata); end

  def method_missing(sym, *a, &b); end

  def missing_extensions?(); end

  def name=(name); end

  def name_tuple(); end

  def nondevelopment_dependencies(); end

  def normalize(); end

  def original_name(); end

  def original_platform(); end

  def original_platform=(original_platform); end

  def platform=(platform); end

  def post_install_message(); end

  def post_install_message=(post_install_message); end

  def pretty_print(q); end

  def raise_if_conflicts(); end

  def rdoc_options(); end

  def rdoc_options=(options); end

  def relative_loaded_from(); end

  def relative_loaded_from=(relative_loaded_from); end

  def remote(); end

  def remote=(remote); end

  def require_path(); end

  def require_path=(path); end

  def require_paths=(val); end

  def required_ruby_version(); end

  def required_ruby_version=(req); end

  def required_rubygems_version(); end

  def required_rubygems_version=(req); end

  def requirements(); end

  def requirements=(req); end

  def reset_nil_attributes_to_default(); end

  def rg_extension_dir(); end

  def rg_full_gem_path(); end

  def rg_loaded_from(); end

  def ri_dir(); end

  def rubyforge_project(); end

  def rubyforge_project=(rubyforge_project); end

  def rubygems_version(); end

  def rubygems_version=(rubygems_version); end

  def runtime_dependencies(); end

  def sanitize(); end

  def sanitize_string(string); end

  def satisfies_requirement?(dependency); end

  def signing_key(); end

  def signing_key=(signing_key); end

  def sort_obj(); end

  def source(); end

  def source=(source); end

  def spec_dir(); end

  def spec_file(); end

  def spec_name(); end

  def specification_version(); end

  def specification_version=(specification_version); end

  def summary(); end

  def summary=(str); end

  def test_file(); end

  def test_file=(file); end

  def test_files(); end

  def test_files=(files); end

  def to_gemfile(path=T.unsafe(nil)); end

  def to_ruby(); end

  def to_ruby_for_cache(); end

  def to_yaml(opts=T.unsafe(nil)); end

  def traverse(trail=T.unsafe(nil), visited=T.unsafe(nil), &block); end

  def validate(packaging=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_metadata(); end

  def validate_permissions(); end

  def version=(version); end

  def warning(statement); end

  def yaml_initialize(tag, vals); end
  DateLike = ::T.let(nil, ::T.untyped)
  DateTimeFormat = ::T.let(nil, ::T.untyped)
  INITIALIZE_CODE_FOR_DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Gem::Specification
  extend ::T::Sig
  extend ::Gem::Deprecate
  extend ::Enumerable
  def self._all(); end

  def self._clear_load_cache(); end

  def self._latest_specs(specs, prerelease=T.unsafe(nil)); end

  def self._load(str); end

  def self._resort!(specs); end

  def self.add_spec(spec); end

  def self.add_specs(*specs); end

  def self.all(); end

  def self.all=(specs); end

  def self.all_names(); end

  def self.array_attributes(); end

  def self.attribute_names(); end

  def self.dirs(); end

  def self.dirs=(dirs); end

  def self.each(); end

  def self.each_gemspec(dirs); end

  def self.each_spec(dirs); end

  def self.find_active_stub_by_path(path); end

  def self.find_all_by_full_name(full_name); end

  def self.find_all_by_name(name, *requirements); end

  def self.find_by_name(name, *requirements); end

  def self.find_by_path(path); end

  def self.find_in_unresolved(path); end

  def self.find_in_unresolved_tree(path); end

  def self.find_inactive_by_path(path); end

  def self.from_yaml(input); end

  def self.latest_specs(prerelease=T.unsafe(nil)); end

  def self.load(file); end

  def self.load_defaults(); end

  def self.non_nil_attributes(); end

  def self.normalize_yaml_input(input); end

  def self.outdated(); end

  def self.outdated_and_latest_version(); end

  def self.remove_spec(spec); end

  def self.required_attribute?(name); end

  def self.required_attributes(); end

  def self.reset(); end

  def self.stubs(); end

  def self.stubs_for(name); end

  def self.unresolved_deps(); end
end

class Gem::StreamUI
  def _gets_noecho(); end

  def alert(statement, question=T.unsafe(nil)); end

  def alert_error(statement, question=T.unsafe(nil)); end

  def alert_warning(statement, question=T.unsafe(nil)); end

  def ask(question); end

  def ask_for_password(question); end

  def ask_yes_no(question, default=T.unsafe(nil)); end

  def backtrace(exception); end

  def choose_from_list(question, list); end

  def close(); end

  def debug(statement); end

  def download_reporter(*args); end

  def errs(); end

  def initialize(in_stream, out_stream, err_stream=T.unsafe(nil), usetty=T.unsafe(nil)); end

  def ins(); end

  def outs(); end

  def progress_reporter(*args); end

  def require_io_console(); end

  def say(statement=T.unsafe(nil)); end

  def terminate_interaction(status=T.unsafe(nil)); end

  def tty?(); end
end

class Gem::StreamUI
end

class Gem::StubSpecification
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification::StubLine
  extend ::T::Sig
end

class Gem::StubSpecification
  extend ::T::Sig
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

class Gem::SystemExitException
  def exit_code(); end

  def exit_code=(exit_code); end

  def initialize(exit_code); end
end

class Gem::SystemExitException
  extend ::T::Sig
end

module Gem::Text
  def clean_text(text); end

  def format_text(text, wrap, indent=T.unsafe(nil)); end

  def levenshtein_distance(str1, str2); end

  def min3(a, b, c); end

  def truncate_text(text, description, max_length=T.unsafe(nil)); end
end

module Gem::Text
  extend ::T::Sig
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

class Gem::UnsatisfiableDependencyError
  def dependency(); end

  def errors(); end

  def errors=(errors); end

  def initialize(dep, platform_mismatch=T.unsafe(nil)); end

  def name(); end

  def version(); end
end

class Gem::UnsatisfiableDependencyError
  extend ::T::Sig
end

class Gem::UriFormatter
  def escape(); end

  def initialize(uri); end

  def normalize(); end

  def unescape(); end

  def uri(); end
end

class Gem::UriFormatter
end

module Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def alert(statement, question=T.unsafe(nil)); end

  def alert_error(statement, question=T.unsafe(nil)); end

  def alert_warning(statement, question=T.unsafe(nil)); end

  def ask(question); end

  def ask_for_password(prompt); end

  def ask_yes_no(question, default=T.unsafe(nil)); end

  def choose_from_list(question, list); end

  def say(statement=T.unsafe(nil)); end

  def terminate_interaction(exit_code=T.unsafe(nil)); end

  def verbose(msg=T.unsafe(nil)); end
end

module Gem::UserInteraction
  extend ::T::Sig
end

module Gem::Util
  NULL_DEVICE = ::T.let(nil, ::T.untyped)
end

module Gem::Util
  extend ::T::Sig
  def self.gunzip(data); end

  def self.gzip(data); end

  def self.inflate(data); end

  def self.popen(*command); end

  def self.silent_system(*command); end

  def self.traverse_parents(directory, &block); end
end

class Gem::VerificationError
  extend ::T::Sig
end

class Gem::Version
  def _segments(); end

  def _split_segments(); end

  def _version(); end

  def approximate_recommendation(); end

  def bump(); end

  def canonical_segments(); end

  def encode_with(coder); end

  def eql?(other); end

  def init_with(coder); end

  def marshal_dump(); end

  def marshal_load(array); end

  def prerelease?(); end

  def pretty_print(q); end

  def release(); end

  def segments(); end

  def to_yaml_properties(); end

  def version(); end

  def yaml_initialize(tag, map); end
end

Gem::Version::Requirement = Gem::Requirement

class Gem::Version
  extend ::T::Sig
  def self.correct?(version); end

  def self.create(input); end

  def self.new(version); end
end

module Gem
  extend ::T::Sig
  def self._deprecated_datadir(gem_name); end

  def self.activate_bin_path(name, *args); end

  def self.default_ext_dir_for(base_dir); end

  def self.default_gems_use_full_paths?(); end

  def self.default_spec_cache_dir(); end

  def self.deflate(data); end

  def self.detect_gemdeps(path=T.unsafe(nil)); end

  def self.dir(); end

  def self.done_installing(&hook); end

  def self.done_installing_hooks(); end

  def self.ensure_default_gem_subdirectories(dir=T.unsafe(nil), mode=T.unsafe(nil)); end

  def self.ensure_gem_subdirectories(dir=T.unsafe(nil), mode=T.unsafe(nil)); end

  def self.ensure_subdirectories(dir, mode, subdirs); end

  def self.env_requirement(gem_name); end

  def self.extension_api_version(); end

  def self.find_files(glob, check_load_path=T.unsafe(nil)); end

  def self.find_files_from_load_path(glob); end

  def self.find_latest_files(glob, check_load_path=T.unsafe(nil)); end

  def self.find_unresolved_default_spec(path); end

  def self.finish_resolve(*_); end

  def self.gemdeps(); end

  def self.gunzip(data); end

  def self.gzip(data); end

  def self.host(); end

  def self.host=(host); end

  def self.inflate(data); end

  def self.install(name, version=T.unsafe(nil), *options); end

  def self.install_extension_in_lib(); end

  def self.latest_rubygems_version(); end

  def self.latest_spec_for(name); end

  def self.latest_version_for(name); end

  def self.load_env_plugins(); end

  def self.load_path_insert_index(); end

  def self.load_plugin_files(plugins); end

  def self.load_plugins(); end

  def self.load_yaml(); end

  def self.loaded_specs(); end

  def self.location_of_caller(depth=T.unsafe(nil)); end

  def self.marshal_version(); end

  def self.needs(); end

  def self.path(); end

  def self.path_separator(); end

  def self.paths(); end

  def self.paths=(env); end

  def self.platform_defaults(); end

  def self.platforms(); end

  def self.platforms=(platforms); end

  def self.post_build(&hook); end

  def self.post_build_hooks(); end

  def self.post_install(&hook); end

  def self.post_install_hooks(); end

  def self.post_reset(&hook); end

  def self.post_reset_hooks(); end

  def self.post_uninstall(&hook); end

  def self.post_uninstall_hooks(); end

  def self.pre_install(&hook); end

  def self.pre_install_hooks(); end

  def self.pre_reset(&hook); end

  def self.pre_reset_hooks(); end

  def self.pre_uninstall(&hook); end

  def self.pre_uninstall_hooks(); end

  def self.prefix(); end

  def self.read_binary(path); end

  def self.refresh(); end

  def self.register_default_spec(spec); end

  def self.remove_unresolved_default_spec(spec); end

  def self.ruby(); end

  def self.ruby_api_version(); end

  def self.ruby_engine(); end

  def self.ruby_version(); end

  def self.rubygems_version(); end

  def self.sources(); end

  def self.sources=(new_sources); end

  def self.spec_cache_dir(); end

  def self.suffix_pattern(); end

  def self.suffixes(); end

  def self.time(msg, width=T.unsafe(nil), display=T.unsafe(nil)); end

  def self.try_activate(path); end

  def self.ui(); end

  def self.upstream_default_bindir(); end

  def self.upstream_default_dir(); end

  def self.upstream_default_path(); end

  def self.use_gemdeps(path=T.unsafe(nil)); end

  def self.use_paths(home, *paths); end

  def self.user_dir(); end

  def self.user_home(); end

  def self.vendor_dir(); end

  def self.win_platform?(); end

  def self.write_binary(path, data); end
end

class GetoptLong
  def each(); end

  def each_option(); end

  def error(); end

  def error?(); end

  def error_message(); end

  def get(); end

  def get_option(); end

  def initialize(*arguments); end

  def ordering(); end

  def ordering=(ordering); end

  def quiet(); end

  def quiet=(quiet); end

  def quiet?(); end

  def set_error(type, message); end

  def set_options(*arguments); end

  def terminate(); end

  def terminated?(); end
  ARGUMENT_FLAGS = ::T.let(nil, ::T.untyped)
  NO_ARGUMENT = ::T.let(nil, ::T.untyped)
  OPTIONAL_ARGUMENT = ::T.let(nil, ::T.untyped)
  ORDERINGS = ::T.let(nil, ::T.untyped)
  PERMUTE = ::T.let(nil, ::T.untyped)
  REQUIRED_ARGUMENT = ::T.let(nil, ::T.untyped)
  REQUIRE_ORDER = ::T.let(nil, ::T.untyped)
  RETURN_IN_ORDER = ::T.let(nil, ::T.untyped)
  STATUS_STARTED = ::T.let(nil, ::T.untyped)
  STATUS_TERMINATED = ::T.let(nil, ::T.untyped)
  STATUS_YET = ::T.let(nil, ::T.untyped)
end

class GetoptLong::AmbiguousOption
end

class GetoptLong::AmbiguousOption
end

class GetoptLong::Error
end

class GetoptLong::Error
end

class GetoptLong::InvalidOption
end

class GetoptLong::InvalidOption
end

class GetoptLong::MissingArgument
end

class GetoptLong::MissingArgument
end

class GetoptLong::NeedlessArgument
end

class GetoptLong::NeedlessArgument
end

class GetoptLong
end

class Hash
  include ::PSON::Pure::Generator::GeneratorMethods::Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def <(_); end

  def <=(_); end

  def >(_); end

  def >=(_); end

  def compact(); end

  def compact!(); end

  def default_proc(); end

  def default_proc=(default_proc); end

  def dig(*_); end

  def fetch_values(*_); end

  def flatten(*_); end

  def index(_); end

  def merge!(_); end

  def replace(_); end

  def slice(*_); end

  def to_h(); end

  def to_proc(); end

  def transform_keys(); end

  def transform_keys!(); end

  def transform_values(); end

  def transform_values!(); end

  def update(_); end
end

class Hash
  extend ::T::Sig
  def self.try_convert(_); end
end

class Hiera
end

class Hiera::Scope
  def [](key); end

  def call_function(*args, &block); end

  def catalog(); end

  def compiler(); end

  def exist?(key); end

  def include?(key); end

  def initialize(real); end

  def real(); end

  def resource(); end
  CALLING_CLASS = ::T.let(nil, ::T.untyped)
  CALLING_CLASS_PATH = ::T.let(nil, ::T.untyped)
  CALLING_KEYS = ::T.let(nil, ::T.untyped)
  CALLING_MODULE = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  MODULE_NAME = ::T.let(nil, ::T.untyped)
end

class Hiera::Scope
  extend ::Forwardable
end

class Hiera
end

class IO
  def external_encoding(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def pathconf(_); end

  def pread(*_); end

  def pwrite(_, _1); end

  def ready?(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def write_nonblock(buf, exception: T.unsafe(nil)); end
end

class IO::EAGAINWaitReadable
  extend ::T::Sig
end

class IO::EAGAINWaitWritable
  extend ::T::Sig
end

class IO::EINPROGRESSWaitReadable
  extend ::T::Sig
end

class IO::EINPROGRESSWaitWritable
  extend ::T::Sig
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

module IO::WaitReadable
  extend ::T::Sig
end

module IO::WaitWritable
  extend ::T::Sig
end

class IO
  extend ::T::Sig
  def self.foreach(*_); end

  def self.pipe(*_); end

end

class IOError
  extend ::T::Sig
end

class IPAddr
  include ::Comparable
  def &(other); end

  def <<(num); end

  def ==(other); end

  def ===(other); end

  def >>(num); end

  def eql?(other); end

  def family(); end

  def hton(); end

  def include?(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def ip6_arpa(); end

  def ip6_int(); end

  def ipv4?(); end

  def ipv4_compat(); end

  def ipv4_compat?(); end

  def ipv4_mapped(); end

  def ipv4_mapped?(); end

  def ipv6?(); end

  def link_local?(); end

  def loopback?(); end

  def mask(prefixlen); end

  def mask!(mask); end

  def native(); end

  def prefix(); end

  def prefix=(prefix); end

  def private?(); end

  def reverse(); end

  def set(addr, *family); end

  def succ(); end

  def to_i(); end

  def to_range(); end

  def to_string(); end

  def |(other); end

  def ~(); end
  IN4MASK = ::T.let(nil, ::T.untyped)
  IN6FORMAT = ::T.let(nil, ::T.untyped)
  IN6MASK = ::T.let(nil, ::T.untyped)
  RE_IPV4ADDRLIKE = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_COMPRESSED = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_FULL = ::T.let(nil, ::T.untyped)
end

class IPAddr::AddressFamilyError
end

class IPAddr::AddressFamilyError
end

class IPAddr::Error
end

class IPAddr::Error
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidPrefixError
end

class IPAddr::InvalidPrefixError
end

class IPAddr
  def self.new_ntoh(addr); end

  def self.ntop(addr); end
end

class IPSocket
  extend ::T::Sig
end

class IndexError
  extend ::T::Sig
end

class Integer
  include ::PSON::Pure::Generator::GeneratorMethods::Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def allbits?(_); end

  def anybits?(_); end

  def digits(*_); end

  def nobits?(_); end

  def pow(*_); end

  def prime?(); end

  def prime_division(generator=T.unsafe(nil)); end

  def to_bn(); end

  GMP_VERSION = ::T.let(nil, ::T.untyped)
end

class Integer
  extend ::T::Sig
  def self.each_prime(ubound, &block); end

  def self.from_prime_division(pd); end

  def self.sqrt(_); end
end

class Interrupt
  extend ::T::Sig
end

class JSON::CircularDatastructure
  extend ::T::Sig
end

module JSON::Ext
end

module JSON::Ext::Generator
end

module JSON::Ext::Generator::GeneratorMethods
end

module JSON::Ext::Generator::GeneratorMethods::Array
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::Array
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::FalseClass
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::FalseClass
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::Float
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::Float
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::Hash
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::Hash
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::Integer
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::Integer
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::NilClass
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::Object
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::Object
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::String
  def to_json(*_); end

  def to_json_raw(*_); end

  def to_json_raw_object(); end
end

module JSON::Ext::Generator::GeneratorMethods::String::Extend
  def json_create(_); end
end

module JSON::Ext::Generator::GeneratorMethods::String::Extend
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::String
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::TrueClass
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::TrueClass
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods
  extend ::T::Sig
end

class JSON::Ext::Generator::State
  def [](_); end

  def []=(_, _1); end

  def allow_nan?(); end

  def array_nl(); end

  def array_nl=(array_nl); end

  def ascii_only?(); end

  def buffer_initial_length(); end

  def buffer_initial_length=(buffer_initial_length); end

  def check_circular?(); end

  def configure(_); end

  def depth(); end

  def depth=(depth); end

  def generate(_); end

  def indent(); end

  def indent=(indent); end

  def initialize(*_); end

  def max_nesting(); end

  def max_nesting=(max_nesting); end

  def merge(_); end

  def object_nl(); end

  def object_nl=(object_nl); end

  def space(); end

  def space=(space); end

  def space_before(); end

  def space_before=(space_before); end

  def to_h(); end

  def to_hash(); end
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

module JSON::Ext::Generator
  extend ::T::Sig
end

class JSON::Ext::Parser
  def initialize(*_); end

  def parse(); end

  def source(); end
end

class JSON::Ext::Parser
end

module JSON::Ext
  extend ::T::Sig
end

class JSON::GeneratorError
  extend ::T::Sig
end

class JSON::GenericObject
  extend ::T::Sig
end

class JSON::JSONError
  extend ::T::Sig
end

class JSON::MissingUnicodeSupport
  extend ::T::Sig
end

class JSON::NestingError
  extend ::T::Sig
end

JSON::Parser = JSON::Ext::Parser

class JSON::ParserError
  extend ::T::Sig
end

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module JSON
  extend ::T::Sig
end

JSONTree = Psych::Visitors::JSONTree

class JsonCatalogEncoder
  def encode(); end

  def encode_resource(type, title); end

  def exclude_virtual(); end

  def initialize(catalog, pretty: T.unsafe(nil), exclude_virtual: T.unsafe(nil)); end

  def pretty(); end
end

class JsonCatalogEncoder
end

module Kernel
  def class(); end

  def gem(dep, *reqs); end

  def itself(); end

  def object_id(); end

  def pp(*objs); end

  def respond_to?(*_); end

  def yield_self(); end
end

module Kernel
  extend ::T::Sig
  def self.at_exit(); end
end

class KeyError
  def key(); end

  def receiver(); end
end

class KeyError
  extend ::T::Sig
end

class LoadError
  def path(); end
end

class LoadError
  extend ::T::Sig
end

class LocalJumpError
  def exit_value(); end

  def reason(); end
end

class LocalJumpError
  extend ::T::Sig
end

module Locale
  DEFAULT_LANGUAGE_TAG = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Locale::Driver
  MODULES = ::T.let(nil, ::T.untyped)
end

module Locale::Driver::Env
end

module Locale::Driver::Env::Private
end

module Locale::Driver::Env::Private
  extend ::T::Sig
  def self.parse(env_value); end
end

module Locale::Driver::Env
  extend ::T::Sig
  def self.charset(); end

  def self.locale(); end

  def self.locales(); end
end

module Locale::Driver::Posix
end

module Locale::Driver::Posix
  extend ::T::Sig
  def self.charset(); end

  def self.locales(); end
end

module Locale::Driver
  extend ::T::Sig
end

module Locale::Tag
end

class Locale::Tag::Cldr
  def extensions(); end

  def extensions=(val); end

  def initialize(language, script=T.unsafe(nil), region=T.unsafe(nil), variants=T.unsafe(nil), extensions=T.unsafe(nil)); end
  EXTENSION = ::T.let(nil, ::T.untyped)
  TAG_RE = ::T.let(nil, ::T.untyped)
  VARIANT = ::T.let(nil, ::T.untyped)
end

class Locale::Tag::Cldr
end

class Locale::Tag::Common
  def initialize(language, script=T.unsafe(nil), region=T.unsafe(nil), variants=T.unsafe(nil)); end

  def script(); end

  def script=(val); end

  def variants(); end

  def variants=(val); end
  LANGUAGE = ::T.let(nil, ::T.untyped)
  SCRIPT = ::T.let(nil, ::T.untyped)
  TAG_RE = ::T.let(nil, ::T.untyped)
  VARIANT = ::T.let(nil, ::T.untyped)
end

class Locale::Tag::Common
end

class Locale::Tag::Irregular
  def initialize(tag); end
end

class Locale::Tag::Irregular
end

class Locale::Tag::Posix
  def charset(); end

  def charset=(val); end

  def initialize(language, region=T.unsafe(nil), charset=T.unsafe(nil), modifier=T.unsafe(nil)); end

  def modifier(); end

  def modifier=(val); end
  LANGUAGE = ::T.let(nil, ::T.untyped)
  TAG_RE = ::T.let(nil, ::T.untyped)
end

class Locale::Tag::Posix
end

class Locale::Tag::Rfc
  def extensions(); end

  def extensions=(val); end

  def initialize(language, script=T.unsafe(nil), region=T.unsafe(nil), variants=T.unsafe(nil), extensions=T.unsafe(nil), privateuse=T.unsafe(nil)); end

  def privateuse(); end

  def privateuse=(val); end
  EXTENSION = ::T.let(nil, ::T.untyped)
  GRANDFATHERED = ::T.let(nil, ::T.untyped)
  PRIVATEUSE = ::T.let(nil, ::T.untyped)
  SINGLETON = ::T.let(nil, ::T.untyped)
  TAG_RE = ::T.let(nil, ::T.untyped)
  VARIANT = ::T.let(nil, ::T.untyped)
end

class Locale::Tag::Rfc
end

class Locale::Tag::Simple
  def ==(other); end

  def candidates(); end

  def country(); end

  def eql?(other); end

  def initialize(language, region=T.unsafe(nil)); end

  def language(); end

  def language=(val); end

  def region(); end

  def region=(val); end

  def tag(); end

  def tag=(tag); end

  def to_cldr(); end

  def to_common(); end

  def to_posix(); end

  def to_rfc(); end

  def to_simple(); end

  def to_str(); end
  ALPHA = ::T.let(nil, ::T.untyped)
  ALPHANUM = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  LANGUAGE = ::T.let(nil, ::T.untyped)
  REGION = ::T.let(nil, ::T.untyped)
  TAG_RE = ::T.let(nil, ::T.untyped)
end

class Locale::Tag::Simple
  def self.parse(tag); end
end

module Locale::Tag
  extend ::T::Sig
  def self.parse(tag); end
end

class Locale::TagList
  def charset(); end

  def country(); end

  def extensions(); end

  def language(); end

  def modifier(); end

  def privateuse(); end

  def region(); end

  def script(); end

  def to_cldr(); end

  def to_common(); end

  def to_posix(); end

  def to_rfc(); end

  def to_simple(); end

  def to_str(); end

  def variants(); end
end

class Locale::TagList
end

module Locale
  extend ::T::Sig
  def self.app_language_tags(); end

  def self.candidates(options=T.unsafe(nil)); end

  def self.charset(); end

  def self.clear(); end

  def self.clear_all(); end

  def self.collect_candidates(type, tags, supported_tags); end

  def self.create_language_tag(tag); end

  def self.current(); end

  def self.current=(tag); end

  def self.default(); end

  def self.default=(tag); end

  def self.driver_module(); end

  def self.get(); end

  def self.init(opts=T.unsafe(nil)); end

  def self.require_driver(name); end

  def self.set(tag); end

  def self.set_app_language_tags(*tags); end

  def self.set_current(*tags); end

  def self.set_default(tag); end
end

module Marshal
  extend ::T::Sig
  def self.restore(*_); end
end

class MatchData
  def named_captures(); end
end

class MatchData
  extend ::T::Sig
end

class Math::DomainError
  extend ::T::Sig
end

module Math
  extend ::T::Sig
end

class Method
  def ===(*_); end

  def [](*_); end

  def arity(); end

  def clone(); end

  def curry(*_); end

  def name(); end

  def original_name(); end

  def owner(); end

  def parameters(); end

  def receiver(); end

  def source_location(); end

  def super_method(); end

  def unbind(); end
end

class Method
  extend ::T::Sig
end

Methods = T::Private::Methods

class Module
  def deprecate_constant(*_); end

  def undef_method(*_); end
end

class Module
  extend ::T::Sig
  def self.used_modules(); end
end

module Molinillo
  VERSION = ::T.let(nil, ::T.untyped)
end

class Molinillo::CircularDependencyError
  def dependencies(); end

  def initialize(vertices); end
end

class Molinillo::CircularDependencyError
end

module Molinillo::Compatibility
end

module Molinillo::Compatibility
  extend ::T::Sig
  def self.flat_map(enum, &blk); end
end

module Molinillo::Delegates
end

module Molinillo::Delegates::ResolutionState
  def activated(); end

  def conflicts(); end

  def depth(); end

  def name(); end

  def possibilities(); end

  def requirement(); end

  def requirements(); end

  def unused_unwind_options(); end
end

module Molinillo::Delegates::ResolutionState
  extend ::T::Sig
end

module Molinillo::Delegates::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Molinillo::Delegates::SpecificationProvider
  extend ::T::Sig
end

module Molinillo::Delegates
  extend ::T::Sig
end

class Molinillo::DependencyGraph
  include ::Enumerable
  include ::TSort
  def ==(other); end

  def add_child_vertex(name, payload, parent_names, requirement); end

  def add_edge(origin, destination, requirement); end

  def add_vertex(name, payload, root=T.unsafe(nil)); end

  def delete_edge(edge); end

  def detach_vertex_named(name); end

  def each(); end

  def log(); end

  def rewind_to(tag); end

  def root_vertex_named(name); end

  def set_payload(name, payload); end

  def tag(tag); end

  def to_dot(options=T.unsafe(nil)); end

  def tsort_each_child(vertex, &block); end

  def vertex_named(name); end

  def vertices(); end
end

class Molinillo::DependencyGraph::Action
  def down(graph); end

  def next(); end

  def next=(_); end

  def previous(); end

  def previous=(previous); end

  def up(graph); end
end

class Molinillo::DependencyGraph::Action
  def self.action_name(); end
end

class Molinillo::DependencyGraph::AddEdgeNoCircular
  def destination(); end

  def initialize(origin, destination, requirement); end

  def make_edge(graph); end

  def origin(); end

  def requirement(); end
end

class Molinillo::DependencyGraph::AddEdgeNoCircular
end

class Molinillo::DependencyGraph::AddVertex
  def initialize(name, payload, root); end

  def name(); end

  def payload(); end

  def root(); end
end

class Molinillo::DependencyGraph::AddVertex
end

class Molinillo::DependencyGraph::DeleteEdge
  def destination_name(); end

  def initialize(origin_name, destination_name, requirement); end

  def make_edge(graph); end

  def origin_name(); end

  def requirement(); end
end

class Molinillo::DependencyGraph::DeleteEdge
end

class Molinillo::DependencyGraph::DetachVertexNamed
  def initialize(name); end

  def name(); end
end

class Molinillo::DependencyGraph::DetachVertexNamed
end

class Molinillo::DependencyGraph::Edge
  def destination(); end

  def destination=(_); end

  def origin(); end

  def origin=(_); end

  def requirement(); end

  def requirement=(_); end
end

class Molinillo::DependencyGraph::Edge
  def self.[](*_); end

  def self.members(); end
end

class Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Molinillo::DependencyGraph::SetPayload
  def initialize(name, payload); end

  def name(); end

  def payload(); end
end

class Molinillo::DependencyGraph::SetPayload
end

class Molinillo::DependencyGraph::Tag
  def down(_graph); end

  def initialize(tag); end

  def tag(); end

  def up(_graph); end
end

class Molinillo::DependencyGraph::Tag
end

class Molinillo::DependencyGraph::Vertex
  def ==(other); end

  def ancestor?(other); end

  def descendent?(other); end

  def eql?(other); end

  def explicit_requirements(); end

  def incoming_edges(); end

  def incoming_edges=(incoming_edges); end

  def initialize(name, payload); end

  def is_reachable_from?(other); end

  def name(); end

  def name=(name); end

  def outgoing_edges(); end

  def outgoing_edges=(outgoing_edges); end

  def path_to?(other); end

  def payload(); end

  def payload=(payload); end

  def predecessors(); end

  def recursive_predecessors(); end

  def recursive_successors(); end

  def requirements(); end

  def root(); end

  def root=(root); end

  def root?(); end

  def shallow_eql?(other); end

  def successors(); end
end

class Molinillo::DependencyGraph::Vertex
end

class Molinillo::DependencyGraph
  def self.tsort(vertices); end
end

class Molinillo::DependencyState
  def pop_possibility_state(); end
end

class Molinillo::DependencyState
end

class Molinillo::NoSuchDependencyError
  def dependency(); end

  def dependency=(dependency); end

  def initialize(dependency, required_by=T.unsafe(nil)); end

  def required_by(); end

  def required_by=(required_by); end
end

class Molinillo::NoSuchDependencyError
end

class Molinillo::PossibilityState
end

class Molinillo::PossibilityState
end

class Molinillo::ResolutionState
  def activated(); end

  def activated=(_); end

  def conflicts(); end

  def conflicts=(_); end

  def depth(); end

  def depth=(_); end

  def name(); end

  def name=(_); end

  def possibilities(); end

  def possibilities=(_); end

  def requirement(); end

  def requirement=(_); end

  def requirements(); end

  def requirements=(_); end

  def unused_unwind_options(); end

  def unused_unwind_options=(_); end
end

class Molinillo::ResolutionState
  def self.[](*_); end

  def self.empty(); end

  def self.members(); end
end

class Molinillo::Resolver
  def initialize(specification_provider, resolver_ui); end

  def resolve(requested, base=T.unsafe(nil)); end

  def resolver_ui(); end

  def specification_provider(); end
end

class Molinillo::Resolver::Resolution
  include ::Molinillo::Delegates::ResolutionState
  include ::Molinillo::Delegates::SpecificationProvider
  def base(); end

  def initialize(specification_provider, resolver_ui, requested, base); end

  def iteration_rate=(iteration_rate); end

  def original_requested(); end

  def resolve(); end

  def resolver_ui(); end

  def specification_provider(); end

  def started_at=(started_at); end

  def states=(states); end
end

class Molinillo::Resolver::Resolution::Conflict
  def activated_by_name(); end

  def activated_by_name=(_); end

  def existing(); end

  def existing=(_); end

  def locked_requirement(); end

  def locked_requirement=(_); end

  def possibility(); end

  def possibility_set(); end

  def possibility_set=(_); end

  def requirement(); end

  def requirement=(_); end

  def requirement_trees(); end

  def requirement_trees=(_); end

  def requirements(); end

  def requirements=(_); end

  def underlying_error(); end

  def underlying_error=(_); end
end

class Molinillo::Resolver::Resolution::Conflict
  def self.[](*_); end

  def self.members(); end
end

class Molinillo::Resolver::Resolution::PossibilitySet
  def dependencies(); end

  def dependencies=(_); end

  def latest_version(); end

  def possibilities(); end

  def possibilities=(_); end
end

class Molinillo::Resolver::Resolution::PossibilitySet
  def self.[](*_); end

  def self.members(); end
end

class Molinillo::Resolver::Resolution::UnwindDetails
  include ::Comparable
  def all_requirements(); end

  def conflicting_requirements(); end

  def conflicting_requirements=(_); end

  def requirement_tree(); end

  def requirement_tree=(_); end

  def requirement_trees(); end

  def requirement_trees=(_); end

  def requirements_unwound_to_instead(); end

  def requirements_unwound_to_instead=(_); end

  def reversed_requirement_tree_index(); end

  def state_index(); end

  def state_index=(_); end

  def state_requirement(); end

  def state_requirement=(_); end

  def sub_dependencies_to_avoid(); end

  def unwinding_to_primary_requirement?(); end
end

class Molinillo::Resolver::Resolution::UnwindDetails
  def self.[](*_); end

  def self.members(); end
end

class Molinillo::Resolver::Resolution
end

class Molinillo::Resolver
end

class Molinillo::ResolverError
end

class Molinillo::ResolverError
end

module Molinillo::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Molinillo::SpecificationProvider
  extend ::T::Sig
end

module Molinillo::UI
  def after_resolution(); end

  def before_resolution(); end

  def debug(depth=T.unsafe(nil)); end

  def debug?(); end

  def indicate_progress(); end

  def output(); end

  def progress_rate(); end
end

module Molinillo::UI
  extend ::T::Sig
end

class Molinillo::VersionConflict
  include ::Molinillo::Delegates::SpecificationProvider
  def conflicts(); end

  def initialize(conflicts, specification_provider); end

  def message_with_trees(opts=T.unsafe(nil)); end

  def specification_provider(); end
end

class Molinillo::VersionConflict
end

module Molinillo
  extend ::T::Sig
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

class Monitor
  extend ::T::Sig
end

module MonitorMixin
  def initialize(*args); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_mon_enter(); end
end

class MonitorMixin::ConditionVariable
  def broadcast(); end

  def initialize(monitor); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(); end

  def wait_while(); end
end

class MonitorMixin::ConditionVariable::Timeout
  extend ::T::Sig
end

class MonitorMixin::ConditionVariable
  extend ::T::Sig
end

module MonitorMixin
  extend ::T::Sig
  def self.extend_object(obj); end
end

module MultiJson
  include ::MultiJson::Options
  def adapter(); end

  def adapter=(new_adapter); end

  def cached_options(*_); end

  def current_adapter(options=T.unsafe(nil)); end

  def decode(string, options=T.unsafe(nil)); end

  def default_adapter(); end

  def default_engine(); end

  def default_options(); end

  def default_options=(value); end

  def dump(object, options=T.unsafe(nil)); end

  def encode(object, options=T.unsafe(nil)); end

  def engine(); end

  def engine=(new_adapter); end

  def load(string, options=T.unsafe(nil)); end

  def load_adapter(new_adapter); end

  def reset_cached_options!(*_); end

  def use(new_adapter); end

  def with_adapter(new_adapter); end

  def with_engine(new_adapter); end
  ALIASES = ::T.let(nil, ::T.untyped)
  REQUIREMENT_MAP = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class MultiJson::AdapterError
end

class MultiJson::AdapterError
  def self.build(original_exception); end
end

MultiJson::DecodeError = MultiJson::ParseError

MultiJson::LoadError = MultiJson::ParseError

module MultiJson::Options
  def default_dump_options(); end

  def default_load_options(); end

  def dump_options(*args); end

  def dump_options=(options); end

  def load_options(*args); end

  def load_options=(options); end
end

module MultiJson::Options
  extend ::T::Sig
end

module MultiJson::OptionsCache
  def fetch(type, key); end

  def reset(); end
  MAX_CACHE_SIZE = ::T.let(nil, ::T.untyped)
end

module MultiJson::OptionsCache
  extend ::MultiJson::OptionsCache
  extend ::T::Sig
end

class MultiJson::ParseError
  def data(); end
end

class MultiJson::ParseError
  def self.build(original_exception, data); end
end

class MultiJson::Version
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
end

class MultiJson::Version
end

module MultiJson
  extend ::MultiJson
  extend ::MultiJson::Options
  extend ::T::Sig
end

Mutex = Thread::Mutex

class NameError
  def name(); end

  def receiver(); end
end

class NameError
  extend ::T::Sig
end

class Net::BufferedIO
  extend ::T::Sig
end

class Net::HTTP
  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end
  ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = ::T.let(nil, ::T.untyped)
end

class Net::HTTP::Copy
  extend ::T::Sig
end

class Net::HTTP::Delete
  extend ::T::Sig
end

class Net::HTTP::Get
  extend ::T::Sig
end

class Net::HTTP::Head
  extend ::T::Sig
end

class Net::HTTP::Lock
  extend ::T::Sig
end

class Net::HTTP::Mkcol
  extend ::T::Sig
end

class Net::HTTP::Move
  extend ::T::Sig
end

class Net::HTTP::Options
  extend ::T::Sig
end

class Net::HTTP::Patch
  extend ::T::Sig
end

class Net::HTTP::Persistent
  def unescape(str); end
end

class Net::HTTP::Persistent::Error
  extend ::T::Sig
end

class Net::HTTP::Persistent::SSLReuse
  extend ::T::Sig
end

class Net::HTTP::Persistent
  extend ::T::Sig
end

class Net::HTTP::Post
  extend ::T::Sig
end

class Net::HTTP::Propfind
  extend ::T::Sig
end

class Net::HTTP::Proppatch
  extend ::T::Sig
end

module Net::HTTP::ProxyDelta
  extend ::T::Sig
end

Net::HTTP::ProxyMod = Net::HTTP::ProxyDelta

class Net::HTTP::Put
  extend ::T::Sig
end

class Net::HTTP::Trace
  extend ::T::Sig
end

class Net::HTTP::Unlock
  extend ::T::Sig
end

class Net::HTTP
  extend ::T::Sig
end

class Net::HTTPAccepted
  extend ::T::Sig
end

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

class Net::HTTPBadGateway
  extend ::T::Sig
end

class Net::HTTPBadRequest
  extend ::T::Sig
end

class Net::HTTPBadResponse
  extend ::T::Sig
end

class Net::HTTPClientError
  extend ::T::Sig
end

class Net::HTTPClientError
end

Net::HTTPClientErrorCode::EXCEPTION_TYPE = Net::HTTPServerException

class Net::HTTPClientError
end

class Net::HTTPConflict
  extend ::T::Sig
end

class Net::HTTPContinue
  extend ::T::Sig
end

class Net::HTTPCreated
  extend ::T::Sig
end

class Net::HTTPError
  extend ::T::Sig
end

module Net::HTTPExceptions
  extend ::T::Sig
end

class Net::HTTPExpectationFailed
  extend ::T::Sig
end

class Net::HTTPFailedDependency
  extend ::T::Sig
end

class Net::HTTPFatalError
  extend ::T::Sig
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

class Net::HTTPForbidden
  extend ::T::Sig
end

class Net::HTTPFound
  extend ::T::Sig
end

class Net::HTTPGatewayTimeOut
  extend ::T::Sig
end

class Net::HTTPGenericRequest::Chunker
  extend ::T::Sig
end

class Net::HTTPGenericRequest
  extend ::T::Sig
end

class Net::HTTPGone
  extend ::T::Sig
end

module Net::HTTPHeader
  extend ::T::Sig
end

class Net::HTTPHeaderSyntaxError
  extend ::T::Sig
end

class Net::HTTPIMUsed
  extend ::T::Sig
end

class Net::HTTPInformation
  extend ::T::Sig
end

class Net::HTTPInformation
end

Net::HTTPInformationCode::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPInformation
end

class Net::HTTPInsufficientStorage
  extend ::T::Sig
end

class Net::HTTPInternalServerError
  extend ::T::Sig
end

class Net::HTTPLengthRequired
  extend ::T::Sig
end

class Net::HTTPLocked
  extend ::T::Sig
end

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMethodNotAllowed
  extend ::T::Sig
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

class Net::HTTPMovedPermanently
  extend ::T::Sig
end

Net::HTTPMovedTemporarily = Net::HTTPFound

class Net::HTTPMultiStatus
  extend ::T::Sig
end

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPMultipleChoices
  extend ::T::Sig
end

class Net::HTTPNetworkAuthenticationRequired
  extend ::T::Sig
end

class Net::HTTPNoContent
  extend ::T::Sig
end

class Net::HTTPNonAuthoritativeInformation
  extend ::T::Sig
end

class Net::HTTPNotAcceptable
  extend ::T::Sig
end

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPNotFound
  extend ::T::Sig
end

class Net::HTTPNotImplemented
  extend ::T::Sig
end

class Net::HTTPNotModified
  extend ::T::Sig
end

class Net::HTTPOK
  extend ::T::Sig
end

class Net::HTTPPartialContent
  extend ::T::Sig
end

class Net::HTTPPaymentRequired
  extend ::T::Sig
end

class Net::HTTPPermanentRedirect
  extend ::T::Sig
end

class Net::HTTPPreconditionFailed
  extend ::T::Sig
end

class Net::HTTPPreconditionRequired
  extend ::T::Sig
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPProxyAuthenticationRequired
  extend ::T::Sig
end

class Net::HTTPRedirection
  extend ::T::Sig
end

class Net::HTTPRedirection
end

Net::HTTPRedirectionCode::EXCEPTION_TYPE = Net::HTTPRetriableError

class Net::HTTPRedirection
end

class Net::HTTPRequest
  extend ::T::Sig
end

class Net::HTTPRequestEntityTooLarge
  extend ::T::Sig
end

class Net::HTTPRequestHeaderFieldsTooLarge
  extend ::T::Sig
end

class Net::HTTPRequestTimeOut
  extend ::T::Sig
end

Net::HTTPRequestURITooLarge = Net::HTTPRequestURITooLong

class Net::HTTPRequestURITooLong
  extend ::T::Sig
end

class Net::HTTPRequestedRangeNotSatisfiable
  extend ::T::Sig
end

class Net::HTTPResetContent
  extend ::T::Sig
end

Net::HTTPResponceReceiver = Net::HTTPResponse

class Net::HTTPResponse::Inflater
  extend ::T::Sig
end

class Net::HTTPResponse
  extend ::T::Sig
end

Net::HTTPRetriableCode = Net::HTTPRedirection

class Net::HTTPRetriableError
  extend ::T::Sig
end

class Net::HTTPSeeOther
  extend ::T::Sig
end

class Net::HTTPServerError
  extend ::T::Sig
end

class Net::HTTPServerError
end

Net::HTTPServerErrorCode::EXCEPTION_TYPE = Net::HTTPFatalError

class Net::HTTPServerError
end

class Net::HTTPServerException
  extend ::T::Sig
end

class Net::HTTPServiceUnavailable
  extend ::T::Sig
end

Net::HTTPSession = Net::HTTP

class Net::HTTPSuccess
  extend ::T::Sig
end

class Net::HTTPSuccess
end

Net::HTTPSuccessCode::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPSuccess
end

class Net::HTTPSwitchProtocol
  extend ::T::Sig
end

class Net::HTTPTemporaryRedirect
  extend ::T::Sig
end

class Net::HTTPTooManyRequests
  extend ::T::Sig
end

class Net::HTTPUnauthorized
  extend ::T::Sig
end

class Net::HTTPUnavailableForLegalReasons
  extend ::T::Sig
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPUnknownResponse
  extend ::T::Sig
end

class Net::HTTPUnprocessableEntity
  extend ::T::Sig
end

class Net::HTTPUnsupportedMediaType
  extend ::T::Sig
end

class Net::HTTPUpgradeRequired
  extend ::T::Sig
end

class Net::HTTPUseProxy
  extend ::T::Sig
end

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

class Net::HTTPVersionNotSupported
  extend ::T::Sig
end

class Net::InternetMessageIO
  extend ::T::Sig
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

module Net::NetPrivate
  extend ::T::Sig
end

class Net::OpenTimeout
  extend ::T::Sig
end

class Net::ProtoAuthError
  extend ::T::Sig
end

class Net::ProtoCommandError
  extend ::T::Sig
end

class Net::ProtoFatalError
  extend ::T::Sig
end

class Net::ProtoRetriableError
  extend ::T::Sig
end

class Net::ProtoServerError
  extend ::T::Sig
end

class Net::ProtoSyntaxError
  extend ::T::Sig
end

class Net::ProtoUnknownError
  extend ::T::Sig
end

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::Protocol
  extend ::T::Sig
end

class Net::ProtocolError
  extend ::T::Sig
end

class Net::ReadAdapter
  extend ::T::Sig
end

class Net::ReadTimeout
  extend ::T::Sig
end

class Net::WriteAdapter
  extend ::T::Sig
end

module Net
  extend ::T::Sig
end

class NilClass
  include ::PSON::Pure::Generator::GeneratorMethods::NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_i(); end
end

class NilClass
  extend ::T::Sig
end

class NoMemoryError
  extend ::T::Sig
end

class NoMethodError
  def args(); end

  def private_call?(); end
end

class NoMethodError
  extend ::T::Sig
end

class NotImplementedError
  extend ::T::Sig
end

class Numeric
  def finite?(); end

  def infinite?(); end

  def negative?(); end

  def positive?(); end

end

class Numeric
  extend ::T::Sig
end

class Object
  include ::FastGettext::Translation
  include ::PSON::Pure::Generator::GeneratorMethods::Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  def class_def(name, &blk); end

  def daemonize(); end

  def meta_def(name, &blk); end

  def meta_eval(&blk); end

  def meta_undef(name, &blk); end

  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  extend ::T::Sig
  def self.yaml_tag(url); end
end

class ObjectSpace::WeakMap
  def [](_); end

  def []=(_, _1); end

  def each(); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def key?(_); end

  def keys(); end

  def length(); end

  def size(); end

  def values(); end
end

class ObjectSpace::WeakMap
  extend ::T::Sig
end

module ObjectSpace
  extend ::T::Sig
  def self.count_objects(*_); end

  def self.define_finalizer(*_); end

  def self.garbage_collect(*_); end

  def self.undefine_finalizer(_); end
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::ASN1::ASN1Data
  extend ::T::Sig
end

class OpenSSL::ASN1::ASN1Error
  extend ::T::Sig
end

class OpenSSL::ASN1::BMPString
  extend ::T::Sig
end

class OpenSSL::ASN1::BitString
  extend ::T::Sig
end

class OpenSSL::ASN1::Boolean
  extend ::T::Sig
end

class OpenSSL::ASN1::Constructive
  extend ::T::Sig
end

class OpenSSL::ASN1::EndOfContent
  extend ::T::Sig
end

class OpenSSL::ASN1::Enumerated
  extend ::T::Sig
end

class OpenSSL::ASN1::GeneralString
  extend ::T::Sig
end

class OpenSSL::ASN1::GeneralizedTime
  extend ::T::Sig
end

class OpenSSL::ASN1::GraphicString
  extend ::T::Sig
end

class OpenSSL::ASN1::IA5String
  extend ::T::Sig
end

class OpenSSL::ASN1::ISO64String
  extend ::T::Sig
end

class OpenSSL::ASN1::Integer
  extend ::T::Sig
end

class OpenSSL::ASN1::Null
  extend ::T::Sig
end

class OpenSSL::ASN1::NumericString
  extend ::T::Sig
end

class OpenSSL::ASN1::ObjectId
  extend ::T::Sig
end

class OpenSSL::ASN1::OctetString
  extend ::T::Sig
end

class OpenSSL::ASN1::Primitive
  extend ::T::Sig
end

class OpenSSL::ASN1::PrintableString
  extend ::T::Sig
end

class OpenSSL::ASN1::Sequence
  extend ::T::Sig
end

class OpenSSL::ASN1::Set
  extend ::T::Sig
end

class OpenSSL::ASN1::T61String
  extend ::T::Sig
end

class OpenSSL::ASN1::UTCTime
  extend ::T::Sig
end

class OpenSSL::ASN1::UTF8String
  extend ::T::Sig
end

class OpenSSL::ASN1::UniversalString
  extend ::T::Sig
end

class OpenSSL::ASN1::VideotexString
  extend ::T::Sig
end

module OpenSSL::ASN1
  extend ::T::Sig
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(_); end

  def negative?(); end
end

class OpenSSL::BN
  extend ::T::Sig
end

class OpenSSL::BNError
  extend ::T::Sig
end

module OpenSSL::Buffering
  extend ::T::Sig
end

class OpenSSL::Cipher::AES
  extend ::T::Sig
end

class OpenSSL::Cipher::AES128
  extend ::T::Sig
end

class OpenSSL::Cipher::AES192
  extend ::T::Sig
end

class OpenSSL::Cipher::AES256
  extend ::T::Sig
end

class OpenSSL::Cipher::BF
  extend ::T::Sig
end

class OpenSSL::Cipher::CAST5
  extend ::T::Sig
end

class OpenSSL::Cipher::CipherError
  extend ::T::Sig
end

class OpenSSL::Cipher::DES
  extend ::T::Sig
end

class OpenSSL::Cipher::IDEA
  extend ::T::Sig
end

class OpenSSL::Cipher::RC2
  extend ::T::Sig
end

class OpenSSL::Cipher::RC4
  extend ::T::Sig
end

class OpenSSL::Cipher::RC5
  extend ::T::Sig
end

class OpenSSL::Cipher
  extend ::T::Sig
end

class OpenSSL::Config
  extend ::T::Sig
end

class OpenSSL::ConfigError
  extend ::T::Sig
end

class OpenSSL::Digest
  extend ::T::Sig
end

class OpenSSL::Engine::EngineError
  extend ::T::Sig
end

class OpenSSL::Engine
  extend ::T::Sig
end

module OpenSSL::ExtConfig
  extend ::T::Sig
end

class OpenSSL::HMAC
  extend ::T::Sig
end

class OpenSSL::HMACError
  extend ::T::Sig
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  extend ::T::Sig
  def self.hkdf(*_); end

  def self.pbkdf2_hmac(*_); end

  def self.scrypt(*_); end
end

class OpenSSL::Netscape::SPKI
  extend ::T::Sig
end

class OpenSSL::Netscape::SPKIError
  extend ::T::Sig
end

module OpenSSL::Netscape
  extend ::T::Sig
end

class OpenSSL::OCSP::BasicResponse
  extend ::T::Sig
end

class OpenSSL::OCSP::CertificateId
  extend ::T::Sig
end

class OpenSSL::OCSP::OCSPError
  extend ::T::Sig
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

class OpenSSL::OCSP::Request
  extend ::T::Sig
end

class OpenSSL::OCSP::Response
  extend ::T::Sig
end

class OpenSSL::OCSP::SingleResponse
  extend ::T::Sig
end

module OpenSSL::OCSP
  extend ::T::Sig
end

class OpenSSL::OpenSSLError
  extend ::T::Sig
end

class OpenSSL::PKCS12::PKCS12Error
  extend ::T::Sig
end

class OpenSSL::PKCS12
  extend ::T::Sig
end

module OpenSSL::PKCS5
  extend ::T::Sig
end

class OpenSSL::PKCS7::PKCS7Error
  extend ::T::Sig
end

class OpenSSL::PKCS7::RecipientInfo
  extend ::T::Sig
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKCS7::SignerInfo
  extend ::T::Sig
end

class OpenSSL::PKCS7
  extend ::T::Sig
end

class OpenSSL::PKey::DH
  extend ::T::Sig
end

class OpenSSL::PKey::DHError
  extend ::T::Sig
end

class OpenSSL::PKey::DSA
  extend ::T::Sig
end

class OpenSSL::PKey::DSAError
  extend ::T::Sig
end

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Group::Error
  extend ::T::Sig
end

class OpenSSL::PKey::EC::Group
  extend ::T::Sig
end

class OpenSSL::PKey::EC::Point
  def to_octet_string(_); end
end

class OpenSSL::PKey::EC::Point::Error
  extend ::T::Sig
end

class OpenSSL::PKey::EC::Point
  extend ::T::Sig
end

class OpenSSL::PKey::EC
  extend ::T::Sig
end

class OpenSSL::PKey::ECError
  extend ::T::Sig
end

class OpenSSL::PKey::PKey
  extend ::T::Sig
end

class OpenSSL::PKey::PKeyError
  extend ::T::Sig
end

class OpenSSL::PKey::RSA
  def sign_pss(*_); end

  def verify_pss(*_); end
end

class OpenSSL::PKey::RSA
  extend ::T::Sig
end

class OpenSSL::PKey::RSAError
  extend ::T::Sig
end

module OpenSSL::PKey
  extend ::T::Sig
end

class OpenSSL::Random::RandomError
  extend ::T::Sig
end

module OpenSSL::Random
  extend ::T::Sig
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLContext
  def add_certificate(*_); end

  def alpn_protocols(); end

  def alpn_protocols=(alpn_protocols); end

  def alpn_select_cb(); end

  def alpn_select_cb=(alpn_select_cb); end

  def enable_fallback_scsv(); end

  def max_version=(version); end

  def min_version=(version); end
  DEFAULT_TMP_DH_CALLBACK = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLContext
  extend ::T::Sig
end

class OpenSSL::SSL::SSLError
  extend ::T::Sig
end

class OpenSSL::SSL::SSLErrorWaitReadable
  extend ::T::Sig
end

class OpenSSL::SSL::SSLErrorWaitWritable
  extend ::T::Sig
end

class OpenSSL::SSL::SSLServer
  extend ::T::Sig
end

class OpenSSL::SSL::SSLSocket
  def alpn_protocol(); end

  def tmp_key(); end
end

class OpenSSL::SSL::SSLSocket
  extend ::T::Sig
end

class OpenSSL::SSL::Session::SessionError
  extend ::T::Sig
end

class OpenSSL::SSL::Session
  extend ::T::Sig
end

module OpenSSL::SSL::SocketForwarder
  extend ::T::Sig
end

module OpenSSL::SSL
  extend ::T::Sig
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  def ==(other); end
end

class OpenSSL::X509::Attribute
  extend ::T::Sig
end

class OpenSSL::X509::AttributeError
  extend ::T::Sig
end

class OpenSSL::X509::CRL
  def ==(other); end
end

class OpenSSL::X509::CRL
  extend ::T::Sig
end

class OpenSSL::X509::CRLError
  extend ::T::Sig
end

class OpenSSL::X509::Certificate
  extend ::T::Sig
end

class OpenSSL::X509::CertificateError
  extend ::T::Sig
end

class OpenSSL::X509::Extension
  def ==(other); end
end

class OpenSSL::X509::Extension
  extend ::T::Sig
end

class OpenSSL::X509::ExtensionError
  extend ::T::Sig
end

class OpenSSL::X509::ExtensionFactory
  extend ::T::Sig
end

class OpenSSL::X509::Name
  def to_utf8(); end
end

module OpenSSL::X509::Name::RFC2253DN
  extend ::T::Sig
end

class OpenSSL::X509::Name
  extend ::T::Sig
end

class OpenSSL::X509::NameError
  extend ::T::Sig
end

class OpenSSL::X509::Request
  def ==(other); end
end

class OpenSSL::X509::Request
  extend ::T::Sig
end

class OpenSSL::X509::RequestError
  extend ::T::Sig
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

class OpenSSL::X509::Revoked
  extend ::T::Sig
end

class OpenSSL::X509::RevokedError
  extend ::T::Sig
end

class OpenSSL::X509::Store
  extend ::T::Sig
end

class OpenSSL::X509::StoreContext
  extend ::T::Sig
end

class OpenSSL::X509::StoreError
  extend ::T::Sig
end

module OpenSSL::X509
  extend ::T::Sig
end

module OpenSSL
  extend ::T::Sig
  def self.fips_mode(); end
end

class OpenStruct
  extend ::T::Sig
end

OptParse = OptionParser

class OptionParser
  def abort(mesg=T.unsafe(nil)); end

  def accept(*args, &blk); end

  def add_officious(); end

  def banner(); end

  def banner=(banner); end

  def base(); end

  def candidate(word); end

  def compsys(to, name=T.unsafe(nil)); end

  def def_head_option(*opts, &block); end

  def def_option(*opts, &block); end

  def def_tail_option(*opts, &block); end

  def default_argv(); end

  def default_argv=(default_argv); end

  def define(*opts, &block); end

  def define_head(*opts, &block); end

  def define_tail(*opts, &block); end

  def environment(env=T.unsafe(nil)); end

  def getopts(*args); end

  def help(); end

  def inc(*args); end

  def initialize(banner=T.unsafe(nil), width=T.unsafe(nil), indent=T.unsafe(nil)); end

  def load(filename=T.unsafe(nil)); end

  def make_switch(opts, block=T.unsafe(nil)); end

  def new(); end

  def on(*opts, &block); end

  def on_head(*opts, &block); end

  def on_tail(*opts, &block); end

  def order(*argv, into: T.unsafe(nil), &nonopt); end

  def order!(argv=T.unsafe(nil), into: T.unsafe(nil), &nonopt); end

  def parse(*argv, into: T.unsafe(nil)); end

  def parse!(argv=T.unsafe(nil), into: T.unsafe(nil)); end

  def permute(*argv, into: T.unsafe(nil)); end

  def permute!(argv=T.unsafe(nil), into: T.unsafe(nil)); end

  def program_name(); end

  def program_name=(program_name); end

  def reject(*args, &blk); end

  def release(); end

  def release=(release); end

  def remove(); end

  def separator(string); end

  def set_banner(_); end

  def set_program_name(_); end

  def set_summary_indent(_); end

  def set_summary_width(_); end

  def summarize(to=T.unsafe(nil), width=T.unsafe(nil), max=T.unsafe(nil), indent=T.unsafe(nil), &blk); end

  def summary_indent(); end

  def summary_indent=(summary_indent); end

  def summary_width(); end

  def summary_width=(summary_width); end

  def terminate(arg=T.unsafe(nil)); end

  def to_a(); end

  def top(); end

  def ver(); end

  def version(); end

  def version=(version); end

  def warn(mesg=T.unsafe(nil)); end
  ArgumentStyle = ::T.let(nil, ::T.untyped)
  COMPSYS_HEADER = ::T.let(nil, ::T.untyped)
  DecimalInteger = ::T.let(nil, ::T.untyped)
  DecimalNumeric = ::T.let(nil, ::T.untyped)
  DefaultList = ::T.let(nil, ::T.untyped)
  NO_ARGUMENT = ::T.let(nil, ::T.untyped)
  NoArgument = ::T.let(nil, ::T.untyped)
  OPTIONAL_ARGUMENT = ::T.let(nil, ::T.untyped)
  OctalInteger = ::T.let(nil, ::T.untyped)
  Officious = ::T.let(nil, ::T.untyped)
  OptionalArgument = ::T.let(nil, ::T.untyped)
  REQUIRED_ARGUMENT = ::T.let(nil, ::T.untyped)
  RequiredArgument = ::T.let(nil, ::T.untyped)
  SPLAT_PROC = ::T.let(nil, ::T.untyped)
end

module OptionParser::Acceptables
  DecimalInteger = ::T.let(nil, ::T.untyped)
  DecimalNumeric = ::T.let(nil, ::T.untyped)
  OctalInteger = ::T.let(nil, ::T.untyped)
end

module OptionParser::Acceptables
  extend ::T::Sig
end

class OptionParser::AmbiguousArgument
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::AmbiguousArgument
end

class OptionParser::AmbiguousOption
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::AmbiguousOption
end

module OptionParser::Arguable
  def getopts(*args); end

  def initialize(*args); end

  def options(); end

  def options=(opt); end

  def order!(&blk); end

  def parse!(); end

  def permute!(); end
end

module OptionParser::Arguable
  extend ::T::Sig
  def self.extend_object(obj); end
end

class OptionParser::CompletingHash
  include ::OptionParser::Completion
  def match(key); end
end

class OptionParser::CompletingHash
end

module OptionParser::Completion
  def candidate(key, icase=T.unsafe(nil), pat=T.unsafe(nil)); end

  def complete(key, icase=T.unsafe(nil), pat=T.unsafe(nil)); end

  def convert(opt=T.unsafe(nil), val=T.unsafe(nil), *_); end
end

module OptionParser::Completion
  extend ::T::Sig
  def self.candidate(key, icase=T.unsafe(nil), pat=T.unsafe(nil), &block); end

  def self.regexp(key, icase); end
end

class OptionParser::InvalidArgument
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::InvalidArgument
end

class OptionParser::InvalidOption
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::InvalidOption
end

class OptionParser::List
  def accept(t, pat=T.unsafe(nil), &block); end

  def add_banner(to); end

  def append(*args); end

  def atype(); end

  def complete(id, opt, icase=T.unsafe(nil), *pat, &block); end

  def compsys(*args, &block); end

  def each_option(&block); end

  def list(); end

  def long(); end

  def prepend(*args); end

  def reject(t); end

  def search(id, key); end

  def short(); end

  def summarize(*args, &block); end
end

class OptionParser::List
end

class OptionParser::MissingArgument
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::MissingArgument
end

class OptionParser::NeedlessArgument
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::NeedlessArgument
end

class OptionParser::OptionMap
  include ::OptionParser::Completion
end

class OptionParser::OptionMap
end

class OptionParser::ParseError
  def args(); end

  def initialize(*args); end

  def reason(); end

  def reason=(reason); end

  def recover(argv); end

  def set_backtrace(array); end

  def set_option(opt, eq); end
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::ParseError
  def self.filter_backtrace(array); end
end

class OptionParser::Switch
  def add_banner(to); end

  def arg(); end

  def block(); end

  def compsys(sdone, ldone); end

  def conv(); end

  def desc(); end

  def initialize(pattern=T.unsafe(nil), conv=T.unsafe(nil), short=T.unsafe(nil), long=T.unsafe(nil), arg=T.unsafe(nil), desc=T.unsafe(nil), block=T.unsafe(nil)); end

  def long(); end

  def match_nonswitch?(str); end

  def pattern(); end

  def short(); end

  def summarize(sdone=T.unsafe(nil), ldone=T.unsafe(nil), width=T.unsafe(nil), max=T.unsafe(nil), indent=T.unsafe(nil)); end

  def switch_name(); end
end

class OptionParser::Switch::NoArgument
  def parse(arg, argv); end
end

class OptionParser::Switch::NoArgument
  def self.incompatible_argument_styles(*_); end
end

class OptionParser::Switch::OptionalArgument
  def parse(arg, argv, &error); end
end

class OptionParser::Switch::OptionalArgument
end

class OptionParser::Switch::PlacedArgument
  def parse(arg, argv, &error); end
end

class OptionParser::Switch::PlacedArgument
end

class OptionParser::Switch::RequiredArgument
  def parse(arg, argv); end
end

class OptionParser::Switch::RequiredArgument
end

class OptionParser::Switch
  def self.guess(arg); end

  def self.incompatible_argument_styles(arg, t); end

  def self.pattern(); end
end

class OptionParser
  def self.accept(*args, &blk); end

  def self.getopts(*args); end

  def self.inc(arg, default=T.unsafe(nil)); end

  def self.reject(*args, &blk); end

  def self.terminate(arg=T.unsafe(nil)); end

  def self.top(); end

  def self.with(*args, &block); end
end

module PSON
  Infinity = ::T.let(nil, ::T.untyped)
  MAP = ::T.let(nil, ::T.untyped)
  MinusInfinity = ::T.let(nil, ::T.untyped)
  PSON_LOADED = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_ARRAY = ::T.let(nil, ::T.untyped)
  VERSION_BUILD = ::T.let(nil, ::T.untyped)
  VERSION_MAJOR = ::T.let(nil, ::T.untyped)
  VERSION_MINOR = ::T.let(nil, ::T.untyped)
end

class PSON::CircularDatastructure
end

class PSON::CircularDatastructure
end

class PSON::GeneratorError
end

class PSON::GeneratorError
end

class PSON::MissingUnicodeSupport
end

class PSON::MissingUnicodeSupport
end

class PSON::NestingError
end

class PSON::NestingError
end

class PSON::PSONError
end

class PSON::PSONError
end

PSON::Parser = PSON::Pure::Parser

class PSON::ParserError
end

class PSON::ParserError
end

module PSON::Pure
end

module PSON::Pure::Generator
end

module PSON::Pure::Generator::GeneratorMethods
end

module PSON::Pure::Generator::GeneratorMethods::Array
  def to_pson(state=T.unsafe(nil), depth=T.unsafe(nil), *_); end
end

module PSON::Pure::Generator::GeneratorMethods::Array
  extend ::T::Sig
end

module PSON::Pure::Generator::GeneratorMethods::FalseClass
  def to_pson(*_); end
end

module PSON::Pure::Generator::GeneratorMethods::FalseClass
  extend ::T::Sig
end

module PSON::Pure::Generator::GeneratorMethods::Float
  def to_pson(state=T.unsafe(nil), *_); end
end

module PSON::Pure::Generator::GeneratorMethods::Float
  extend ::T::Sig
end

module PSON::Pure::Generator::GeneratorMethods::Hash
  def to_pson(state=T.unsafe(nil), depth=T.unsafe(nil), *_); end
end

module PSON::Pure::Generator::GeneratorMethods::Hash
  extend ::T::Sig
end

module PSON::Pure::Generator::GeneratorMethods::Integer
  def to_pson(*_); end
end

module PSON::Pure::Generator::GeneratorMethods::Integer
  extend ::T::Sig
end

module PSON::Pure::Generator::GeneratorMethods::NilClass
  def to_pson(*_); end
end

module PSON::Pure::Generator::GeneratorMethods::NilClass
  extend ::T::Sig
end

module PSON::Pure::Generator::GeneratorMethods::Object
  def to_pson(*_); end
end

module PSON::Pure::Generator::GeneratorMethods::Object
  extend ::T::Sig
end

module PSON::Pure::Generator::GeneratorMethods::String
  def to_pson(*_); end

  def to_pson_raw(*args); end

  def to_pson_raw_object(); end
end

module PSON::Pure::Generator::GeneratorMethods::String::Extend
  def pson_create(o); end
end

module PSON::Pure::Generator::GeneratorMethods::String::Extend
  extend ::T::Sig
end

module PSON::Pure::Generator::GeneratorMethods::String
  extend ::T::Sig
  def self.included(modul); end
end

module PSON::Pure::Generator::GeneratorMethods::TrueClass
  def to_pson(*_); end
end

module PSON::Pure::Generator::GeneratorMethods::TrueClass
  extend ::T::Sig
end

module PSON::Pure::Generator::GeneratorMethods
  extend ::T::Sig
end

class PSON::Pure::Generator::State
  def allow_nan?(); end

  def array_nl(); end

  def array_nl=(array_nl); end

  def check_circular?(); end

  def check_max_nesting(depth); end

  def configure(opts); end

  def forget(object); end

  def indent(); end

  def indent=(indent); end

  def initialize(opts=T.unsafe(nil)); end

  def max_nesting(); end

  def max_nesting=(max_nesting); end

  def object_nl(); end

  def object_nl=(object_nl); end

  def remember(object); end

  def seen?(object); end

  def space(); end

  def space=(space); end

  def space_before(); end

  def space_before=(space_before); end

  def to_h(); end
end

class PSON::Pure::Generator::State
  def self.from_state(opts); end
end

module PSON::Pure::Generator
  extend ::T::Sig
end

class PSON::Pure::Parser
  def initialize(source, opts=T.unsafe(nil)); end

  def parse(); end

  def source(); end
  ARRAY_CLOSE = ::T.let(nil, ::T.untyped)
  ARRAY_OPEN = ::T.let(nil, ::T.untyped)
  COLLECTION_DELIMITER = ::T.let(nil, ::T.untyped)
  FALSE = ::T.let(nil, ::T.untyped)
  FLOAT = ::T.let(nil, ::T.untyped)
  IGNORE = ::T.let(nil, ::T.untyped)
  INFINITY = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  MINUS_INFINITY = ::T.let(nil, ::T.untyped)
  NAN = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  OBJECT_CLOSE = ::T.let(nil, ::T.untyped)
  OBJECT_OPEN = ::T.let(nil, ::T.untyped)
  PAIR_DELIMITER = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TRUE = ::T.let(nil, ::T.untyped)
  UNESCAPE_MAP = ::T.let(nil, ::T.untyped)
  UNPARSED = ::T.let(nil, ::T.untyped)
end

class PSON::Pure::Parser
end

module PSON::Pure
  extend ::T::Sig
end

PSON::State = PSON::Pure::Generator::State

PSON::UnparserError = PSON::GeneratorError

module PSON
  extend ::T::Sig
  def self.[](object, opts=T.unsafe(nil)); end

  def self.create_id(); end

  def self.create_id=(create_id); end

  def self.deep_const_get(path); end

  def self.dump(obj, anIO=T.unsafe(nil), limit=T.unsafe(nil)); end

  def self.encode(to, from, string); end

  def self.fast_generate(obj); end

  def self.fast_unparse(obj); end

  def self.generate(obj, state=T.unsafe(nil)); end

  def self.generator(); end

  def self.generator=(generator); end

  def self.load(source, proc=T.unsafe(nil)); end

  def self.parse(source, opts=T.unsafe(nil)); end

  def self.parse!(source, opts=T.unsafe(nil)); end

  def self.parser(); end

  def self.parser=(parser); end

  def self.pretty_generate(obj, opts=T.unsafe(nil)); end

  def self.pretty_unparse(obj, opts=T.unsafe(nil)); end

  def self.recurse_proc(result, &proc); end

  def self.restore(source, proc=T.unsafe(nil)); end

  def self.state(); end

  def self.state=(state); end

  def self.unparse(obj, state=T.unsafe(nil)); end

  def self.utf8_to_pson(string); end
end

ParseError = Racc::ParseError

class Pathname
  def empty?(); end

  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end

end

class Pathname
  extend ::T::Sig
end

class Prime
  include ::Enumerable
  include ::Singleton
  def each(ubound=T.unsafe(nil), generator=T.unsafe(nil), &block); end

  def int_from_prime_division(pd); end

  def prime?(value, generator=T.unsafe(nil)); end

  def prime_division(value, generator=T.unsafe(nil)); end
end

class Prime::EratosthenesGenerator
  def initialize(); end
end

class Prime::EratosthenesGenerator
end

class Prime::EratosthenesSieve
  include ::Singleton
  def get_nth_prime(n); end
end

class Prime::EratosthenesSieve
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Prime::Generator23
  def initialize(); end
end

class Prime::Generator23
end

class Prime::PseudoPrimeGenerator
  include ::Enumerable
  def each(); end

  def initialize(ubound=T.unsafe(nil)); end

  def next(); end

  def rewind(); end

  def size(); end

  def succ(); end

  def upper_bound(); end

  def upper_bound=(ubound); end

  def with_index(offset=T.unsafe(nil)); end

  def with_object(obj); end
end

class Prime::PseudoPrimeGenerator
end

class Prime::TrialDivision
  include ::Singleton
  def [](index); end

  def cache(); end

  def primes(); end

  def primes_so_far(); end
end

class Prime::TrialDivision
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Prime::TrialDivisionGenerator
  def initialize(); end
end

class Prime::TrialDivisionGenerator
end

class Prime
  extend ::Singleton::SingletonClassMethods
  extend ::Enumerable
  def self.each(*args, &block); end

  def self.instance(); end

  def self.int_from_prime_division(*args, &block); end

  def self.method_added(method); end

  def self.prime?(*args, &block); end

  def self.prime_division(*args, &block); end
end

class Proc
  def ===(*_); end

  def [](*_); end

  def clone(); end

  def lambda?(); end

  def yield(*_); end
end

class Proc
  extend ::T::Sig
end

module Process::GID
  extend ::T::Sig
end

class Process::Status
  extend ::T::Sig
end

module Process::Sys
  extend ::T::Sig
  def self.getegid(); end

end

class Process::Tms
  def cstime(); end

  def cstime=(_); end

  def cutime(); end

  def cutime=(_); end

  def stime(); end

  def stime=(_); end

  def utime(); end

  def utime=(_); end
end

class Process::Tms
  extend ::T::Sig
  def self.[](*_); end

  def self.members(); end
end

module Process::UID
  extend ::T::Sig
end

class Process::Waiter
  extend ::T::Sig
end

module Process
  extend ::T::Sig
  def self.last_status(); end

  def self.setpgrp(); end

end

module Psych
  LIBYAML_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Psych::BadAlias
end

class Psych::BadAlias
end

class Psych::ClassLoader
  def big_decimal(); end

  def complex(); end

  def date(); end

  def date_time(); end

  def exception(); end

  def load(klassname); end

  def object(); end

  def psych_omap(); end

  def psych_set(); end

  def range(); end

  def rational(); end

  def regexp(); end

  def struct(); end

  def symbol(); end

  def symbolize(sym); end
  BIG_DECIMAL = ::T.let(nil, ::T.untyped)
  CACHE = ::T.let(nil, ::T.untyped)
  COMPLEX = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  DATE_TIME = ::T.let(nil, ::T.untyped)
  EXCEPTION = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  PSYCH_OMAP = ::T.let(nil, ::T.untyped)
  PSYCH_SET = ::T.let(nil, ::T.untyped)
  RANGE = ::T.let(nil, ::T.untyped)
  RATIONAL = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
end

class Psych::ClassLoader::Restricted
  def initialize(classes, symbols); end
end

class Psych::ClassLoader::Restricted
end

class Psych::ClassLoader
end

class Psych::Coder
  def [](k); end

  def []=(k, v); end

  def add(k, v); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(tag); end

  def map(tag=T.unsafe(nil), style=T.unsafe(nil)); end

  def map=(map); end

  def object(); end

  def object=(object); end

  def represent_map(tag, map); end

  def represent_object(tag, obj); end

  def represent_scalar(tag, value); end

  def represent_seq(tag, list); end

  def scalar(*args); end

  def scalar=(value); end

  def seq(); end

  def seq=(list); end

  def style(); end

  def style=(style); end

  def tag(); end

  def tag=(tag); end

  def type(); end
end

class Psych::Coder
end

class Psych::DisallowedClass
  def initialize(klass_name); end
end

class Psych::DisallowedClass
end

class Psych::Emitter
  def alias(_); end

  def canonical(); end

  def canonical=(canonical); end

  def end_document(_); end

  def indentation(); end

  def indentation=(indentation); end

  def initialize(*_); end

  def line_width(); end

  def line_width=(line_width); end

  def scalar(_, _1, _2, _3, _4, _5); end

  def start_document(_, _1, _2); end

  def start_mapping(_, _1, _2, _3); end

  def start_sequence(_, _1, _2, _3); end

  def start_stream(_); end
end

class Psych::Emitter
end

class Psych::Exception
end

class Psych::Exception
end

class Psych::FALLBACK
  def to_ruby(); end

  def to_ruby=(_); end
end

class Psych::FALLBACK
  def self.[](*_); end

  def self.members(); end
end

class Psych::Handler
  def alias(anchor); end

  def empty(); end

  def end_document(implicit); end

  def end_mapping(); end

  def end_sequence(); end

  def end_stream(); end

  def event_location(start_line, start_column, end_line, end_column); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end

  def start_stream(encoding); end

  def streaming?(); end
  EVENTS = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Psych::Handler::DumperOptions
  def canonical(); end

  def canonical=(canonical); end

  def indentation(); end

  def indentation=(indentation); end

  def line_width(); end

  def line_width=(line_width); end
end

class Psych::Handler::DumperOptions
end

class Psych::Handler
end

module Psych::Handlers
end

class Psych::Handlers::DocumentStream
  def initialize(&block); end
end

class Psych::Handlers::DocumentStream
end

module Psych::Handlers
  extend ::T::Sig
end

module Psych::JSON
end

module Psych::JSON::RubyEvents
  def visit_DateTime(o); end

  def visit_String(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end
end

module Psych::JSON::RubyEvents
  extend ::T::Sig
end

class Psych::JSON::Stream
  include ::Psych::Streaming
end

class Psych::JSON::Stream::Emitter
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::Stream::Emitter
end

class Psych::JSON::Stream
  extend ::Psych::Streaming::ClassMethods
end

class Psych::JSON::TreeBuilder
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::TreeBuilder
end

module Psych::JSON::YAMLEvents
  def end_document(implicit_end=T.unsafe(nil)); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end
end

module Psych::JSON::YAMLEvents
  extend ::T::Sig
end

module Psych::JSON
  extend ::T::Sig
end

module Psych::Nodes
end

class Psych::Nodes::Alias
  def anchor(); end

  def anchor=(anchor); end

  def initialize(anchor); end
end

class Psych::Nodes::Alias
end

class Psych::Nodes::Document
  def implicit(); end

  def implicit=(implicit); end

  def implicit_end(); end

  def implicit_end=(implicit_end); end

  def initialize(version=T.unsafe(nil), tag_directives=T.unsafe(nil), implicit=T.unsafe(nil)); end

  def root(); end

  def tag_directives(); end

  def tag_directives=(tag_directives); end

  def version(); end

  def version=(version); end
end

class Psych::Nodes::Document
end

class Psych::Nodes::Mapping
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Mapping
end

class Psych::Nodes::Node
  include ::Enumerable
  def children(); end

  def each(&block); end

  def end_column(); end

  def end_column=(end_column); end

  def end_line(); end

  def end_line=(end_line); end

  def start_column(); end

  def start_column=(start_column); end

  def start_line(); end

  def start_line=(start_line); end

  def tag(); end

  def to_ruby(); end

  def to_yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end

  def transform(); end

  def yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Psych::Nodes::Node
end

class Psych::Nodes::Scalar
  def anchor(); end

  def anchor=(anchor); end

  def initialize(value, anchor=T.unsafe(nil), tag=T.unsafe(nil), plain=T.unsafe(nil), quoted=T.unsafe(nil), style=T.unsafe(nil)); end

  def plain(); end

  def plain=(plain); end

  def quoted(); end

  def quoted=(quoted); end

  def style(); end

  def style=(style); end

  def tag=(tag); end

  def value(); end

  def value=(value); end
  ANY = ::T.let(nil, ::T.untyped)
  DOUBLE_QUOTED = ::T.let(nil, ::T.untyped)
  FOLDED = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  PLAIN = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTED = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Scalar
end

class Psych::Nodes::Sequence
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Sequence
end

class Psych::Nodes::Stream
  def encoding(); end

  def encoding=(encoding); end

  def initialize(encoding=T.unsafe(nil)); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Stream
end

module Psych::Nodes
  extend ::T::Sig
end

class Psych::Omap
end

class Psych::Omap
end

class Psych::Parser
  def external_encoding=(external_encoding); end

  def handler(); end

  def handler=(handler); end

  def initialize(handler=T.unsafe(nil)); end

  def mark(); end

  def parse(*_); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Parser::Mark
end

class Psych::Parser::Mark
end

class Psych::Parser
end

class Psych::ScalarScanner
  def class_loader(); end

  def initialize(class_loader); end

  def parse_int(string); end

  def parse_time(string); end

  def tokenize(string); end
  FLOAT = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  TIME = ::T.let(nil, ::T.untyped)
end

class Psych::ScalarScanner
end

class Psych::Set
end

class Psych::Set
end

class Psych::Stream
  include ::Psych::Streaming
end

class Psych::Stream::Emitter
  def end_document(implicit_end=T.unsafe(nil)); end
end

class Psych::Stream::Emitter
end

class Psych::Stream
  extend ::Psych::Streaming::ClassMethods
end

module Psych::Streaming
  def start(encoding=T.unsafe(nil)); end
end

module Psych::Streaming::ClassMethods
  def new(io); end
end

module Psych::Streaming::ClassMethods
  extend ::T::Sig
end

module Psych::Streaming
  extend ::T::Sig
end

class Psych::SyntaxError
  def column(); end

  def context(); end

  def file(); end

  def initialize(file, line, col, offset, problem, context); end

  def line(); end

  def offset(); end

  def problem(); end
end

class Psych::SyntaxError
end

class Psych::TreeBuilder
  def end_document(implicit_end=T.unsafe(nil)); end

  def root(); end
end

class Psych::TreeBuilder
end

module Psych::Visitors
end

class Psych::Visitors::DepthFirst
  def initialize(block); end
end

class Psych::Visitors::DepthFirst
end

class Psych::Visitors::Emitter
  def initialize(io, options=T.unsafe(nil)); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
end

class Psych::Visitors::Emitter
end

class Psych::Visitors::JSONTree
  include ::Psych::JSON::RubyEvents
end

class Psych::Visitors::JSONTree
  def self.create(options=T.unsafe(nil)); end
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::ToRuby
  def class_loader(); end

  def initialize(ss, class_loader); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
  SHOVEL = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::ToRuby
  def self.create(); end
end

class Psych::Visitors::Visitor
  def accept(target); end
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::Visitor
end

class Psych::Visitors::YAMLTree
  def <<(object); end

  def finish(); end

  def finished(); end

  def finished?(); end

  def initialize(emitter, ss, options); end

  def push(object); end

  def start(encoding=T.unsafe(nil)); end

  def started(); end

  def started?(); end

  def tree(); end

  def visit_Array(o); end

  def visit_BasicObject(o); end

  def visit_BigDecimal(o); end

  def visit_Class(o); end

  def visit_Complex(o); end

  def visit_Date(o); end

  def visit_DateTime(o); end

  def visit_Delegator(o); end

  def visit_Encoding(o); end

  def visit_Enumerator(o); end

  def visit_Exception(o); end

  def visit_FalseClass(o); end

  def visit_Float(o); end

  def visit_Hash(o); end

  def visit_Integer(o); end

  def visit_Module(o); end

  def visit_NameError(o); end

  def visit_NilClass(o); end

  def visit_Object(o); end

  def visit_Psych_Omap(o); end

  def visit_Psych_Set(o); end

  def visit_Range(o); end

  def visit_Rational(o); end

  def visit_Regexp(o); end

  def visit_String(o); end

  def visit_Struct(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end

  def visit_TrueClass(o); end
end

class Psych::Visitors::YAMLTree
  def self.create(options=T.unsafe(nil), emitter=T.unsafe(nil)); end
end

module Psych::Visitors
  extend ::T::Sig
end

module Psych
  extend ::T::Sig
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump(o, io=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.dump_stream(*objects); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load(yaml, filename=T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.load_file(filename, fallback: T.unsafe(nil)); end

  def self.load_stream(yaml, filename=T.unsafe(nil)); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.parse(yaml, filename=T.unsafe(nil), fallback: T.unsafe(nil)); end

  def self.parse_file(filename); end

  def self.parse_stream(yaml, filename=T.unsafe(nil), &block); end

  def self.parser(); end

  def self.remove_type(type_tag); end

  def self.safe_load(yaml, whitelist_classes=T.unsafe(nil), whitelist_symbols=T.unsafe(nil), aliases=T.unsafe(nil), filename=T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.to_json(object); end
end

module Puppet
  AS_DURATION = ::T.let(nil, ::T.untyped)
  OLDEST_RECOMMENDED_RUBY_VERSION = ::T.let(nil, ::T.untyped)
  PUPPETVERSION = ::T.let(nil, ::T.untyped)
end

class Puppet::AlreadyImportedError
end

class Puppet::AlreadyImportedError
end

class Puppet::Application
  include ::Puppet::Util
  def app_defaults(); end

  def command_line(); end

  def configure_indirector_routes(); end

  def deprecate(); end

  def deprecated?(); end

  def handle_help(v); end

  def handle_logdest_arg(arg); end

  def handle_version(arg); end

  def handlearg(opt, val); end

  def help(); end

  def initialize(command_line=T.unsafe(nil)); end

  def initialize_app_defaults(); end

  def log_runtime_environment(extra_info=T.unsafe(nil)); end

  def main(); end

  def name(); end

  def options(); end

  def parse_options(); end

  def preinit(); end

  def run(); end

  def run_command(); end

  def set_log_level(opts=T.unsafe(nil)); end

  def setup(); end

  def setup_logs(); end

  def summary(); end
  DOCPATTERN = ::T.let(nil, ::T.untyped)
end

class Puppet::Application::CommandLineArgs
  def args(); end

  def args=(_); end

  def subcommand_name(); end

  def subcommand_name=(_); end
end

class Puppet::Application::CommandLineArgs
  def self.[](*_); end

  def self.members(); end
end

class Puppet::Application
  extend ::Puppet::Util
  def self.[](name); end

  def self.available_application_names(); end

  def self.banner(banner=T.unsafe(nil)); end

  def self.clear!(); end

  def self.clear?(); end

  def self.clear_everything_for_tests(); end

  def self.controlled_run(&block); end

  def self.environment_mode(mode_name); end

  def self.exit(code); end

  def self.find(application_name); end

  def self.get_environment_mode(); end

  def self.interrupted?(); end

  def self.option(*options, &block); end

  def self.option_parser_commands(); end

  def self.restart!(); end

  def self.restart_requested?(); end

  def self.run_mode(mode_name=T.unsafe(nil)); end

  def self.run_status(); end

  def self.run_status=(run_status); end

  def self.stop!(); end

  def self.stop_requested?(); end
end

module Puppet::ApplicationSupport
end

module Puppet::ApplicationSupport
  extend ::T::Sig
  def self.configure_indirector_routes(application_name); end

  def self.push_application_context(run_mode, environment_mode=T.unsafe(nil)); end
end

class Puppet::AuthStoreError
end

class Puppet::AuthStoreError
end

class Puppet::AuthorizationError
end

class Puppet::AuthorizationError
end

module Puppet::CompilableResourceType
  def is_3x_ruby_plugin?(); end
end

module Puppet::CompilableResourceType
  extend ::T::Sig
end

class Puppet::ConfigurationError
end

class Puppet::ConfigurationError
end

class Puppet::Confine
  include ::Puppet::Util
  def for_binary(); end

  def for_binary=(for_binary); end

  def for_binary?(); end

  def initialize(values); end

  def label(); end

  def label=(label); end

  def message(value); end

  def reset(); end

  def result(); end

  def valid?(); end

  def values(); end
end

class Puppet::Confine::Feature
  def pass?(value); end
end

class Puppet::Confine::Feature
  def self.summarize(confines); end
end

class Puppet::Confine
  def self.inherited(klass); end

  def self.name=(name); end

  def self.test(name); end
end

class Puppet::ConfineCollection
  def confine(hash); end

  def initialize(label); end

  def label(); end

  def summary(); end

  def valid?(); end
end

class Puppet::ConfineCollection
end

module Puppet::Confiner
  def confine(hash); end

  def confine_collection(); end

  def suitable?(short=T.unsafe(nil)); end
end

module Puppet::Confiner
  extend ::T::Sig
end

class Puppet::ConstantAlreadyDefined
end

class Puppet::ConstantAlreadyDefined
end

class Puppet::Context
  def ignore(name); end

  def initialize(initial_bindings); end

  def lookup(name, &block); end

  def mark(name); end

  def override(bindings, description=T.unsafe(nil), &block); end

  def pop(); end

  def push(overrides, description=T.unsafe(nil)); end

  def restore(name); end

  def rollback(name); end
end

class Puppet::Context::DuplicateRollbackMarkError
end

class Puppet::Context::DuplicateRollbackMarkError
end

class Puppet::Context::StackUnderflow
end

class Puppet::Context::StackUnderflow
end

class Puppet::Context::TrustedInformation
  def authenticated(); end

  def certname(); end

  def domain(); end

  def extensions(); end

  def hostname(); end

  def initialize(authenticated, certname, extensions); end

  def to_h(); end
end

class Puppet::Context::TrustedInformation
  def self.local(node); end

  def self.remote(authenticated, node_name, certificate); end
end

class Puppet::Context::UndefinedBindingError
end

class Puppet::Context::UndefinedBindingError
end

class Puppet::Context::UnknownRollbackMarkError
end

class Puppet::Context::UnknownRollbackMarkError
end

class Puppet::Context
end

class Puppet::DataBinding
  include ::Puppet::Indirector::Envelope
  include ::Puppet::Network::FormatSupport
end

class Puppet::DataBinding::LookupError
end

class Puppet::DataBinding::LookupError
end

class Puppet::DataBinding::RecursiveLookupError
end

class Puppet::DataBinding::RecursiveLookupError
end

class Puppet::DataBinding
  extend ::Puppet::Indirector
  extend ::Puppet::Indirector::ClassMethods
end

module Puppet::DataTypes
end

class Puppet::DataTypes::TypeBuilder
  def create_type(loader); end

  def has_implementation?(); end

  def implementation(); end

  def implementation=(implementation); end

  def implementation_class(); end

  def implementation_class=(implementation_class); end

  def initialize(type_name); end

  def interface(); end

  def interface=(interface); end
end

class Puppet::DataTypes::TypeBuilder
end

class Puppet::DataTypes::TypeBuilderAPI
  def implementation(&block); end

  def implementation_class(ruby_class); end

  def initialize(type_builder); end

  def interface(type_string); end

  def load_file(file_name); end
end

class Puppet::DataTypes::TypeBuilderAPI
end

module Puppet::DataTypes
  extend ::T::Sig
  def self.create_loaded_type(type_name, loader, &block); end

  def self.create_type(type_name, &block); end
end

class Puppet::DevError
  include ::Puppet::ExternalFileError
end

class Puppet::DevError
end

module Puppet::Environments
end

class Puppet::Environments::Cached
  include ::Puppet::Environments::EnvironmentLoader
  def clear(name); end

  def clear_all_expired(); end

  def entry(env); end

  def evict_if_expired(name); end

  def get(name); end

  def get_conf(name); end

  def initialize(loader); end

  def list(); end

  def search_paths(); end
  END_OF_TIME = ::T.let(nil, ::T.untyped)
  START_OF_TIME = ::T.let(nil, ::T.untyped)
end

class Puppet::Environments::Cached::DefaultCacheExpirationService
  def created(env); end

  def evicted(env_name); end

  def expired?(env_name); end
end

class Puppet::Environments::Cached::DefaultCacheExpirationService
end

class Puppet::Environments::Cached::Entry
  def expired?(); end

  def expires(); end

  def initialize(value); end

  def label(); end

  def value(); end
end

class Puppet::Environments::Cached::Entry
end

class Puppet::Environments::Cached::NotCachedEntry
end

class Puppet::Environments::Cached::NotCachedEntry
end

class Puppet::Environments::Cached::TTLEntry
  def initialize(value, ttl_seconds); end
end

class Puppet::Environments::Cached::TTLEntry
end

class Puppet::Environments::Cached
  def self.cache_expiration_service(); end

  def self.cache_expiration_service=(service); end

  def self.end_of_time(); end
end

class Puppet::Environments::Combined
  include ::Puppet::Environments::EnvironmentLoader
  def get(name); end

  def get_conf(name); end

  def initialize(*loaders); end

  def list(); end

  def search_paths(); end
end

class Puppet::Environments::Combined
end

class Puppet::Environments::Directories
  include ::Puppet::Environments::EnvironmentLoader
  def get(name); end

  def get_conf(name); end

  def initialize(environment_dir, global_module_path); end

  def list(); end

  def search_paths(); end
end

class Puppet::Environments::Directories
  def self.from_path(path, global_module_path); end
end

module Puppet::Environments::EnvironmentCreator
  def for(module_path, manifest); end
end

module Puppet::Environments::EnvironmentCreator
  extend ::T::Sig
end

module Puppet::Environments::EnvironmentLoader
  def clear_all(); end

  def get!(name); end
end

module Puppet::Environments::EnvironmentLoader
  extend ::T::Sig
end

class Puppet::Environments::EnvironmentNotFound
  def initialize(environment_name, original=T.unsafe(nil)); end
end

class Puppet::Environments::EnvironmentNotFound
end

class Puppet::Environments::Static
  include ::Puppet::Environments::EnvironmentCreator
  include ::Puppet::Environments::EnvironmentLoader
  def get(name); end

  def get_conf(name); end

  def initialize(*environments); end

  def list(); end

  def search_paths(); end
end

class Puppet::Environments::Static
end

class Puppet::Environments::StaticDirectory
  def initialize(env_name, env_dir, environment); end
end

class Puppet::Environments::StaticDirectory
end

class Puppet::Environments::StaticPrivate
end

class Puppet::Environments::StaticPrivate
end

module Puppet::Environments
  extend ::T::Sig
end

class Puppet::Error
  def initialize(message, original=T.unsafe(nil)); end

  def original(); end

  def original=(original); end
end

class Puppet::Error
end

class Puppet::ErrorWithData
  include ::Puppet::ExternalFileError
  def error_data(); end

  def initialize(error_data, message, file: T.unsafe(nil), line: T.unsafe(nil), pos: T.unsafe(nil), original: T.unsafe(nil)); end
end

class Puppet::ErrorWithData
end

module Puppet::Etc
end

module Puppet::Etc
  extend ::T::Sig
  def self.endgrent(); end

  def self.endpwent(); end

  def self.getgrent(); end

  def self.getgrgid(id); end

  def self.getgrnam(groupname); end

  def self.getpwent(); end

  def self.getpwnam(username); end

  def self.getpwuid(id); end

  def self.group(); end

  def self.setgrent(); end

  def self.setpwent(); end
end

class Puppet::ExecutionFailure
end

class Puppet::ExecutionFailure
end

module Puppet::ExternalFileError
  def file(); end

  def file=(file); end

  def initialize(message, file=T.unsafe(nil), line=T.unsafe(nil), pos=T.unsafe(nil), original=T.unsafe(nil)); end

  def line(); end

  def line=(line); end

  def pos(); end

  def pos=(pos); end

  def to_s(); end
end

module Puppet::ExternalFileError
  extend ::T::Sig
end

module Puppet::FileBucket
end

class Puppet::FileBucket::BucketError
end

class Puppet::FileBucket::BucketError
end

class Puppet::FileBucket::File
  include ::Puppet::Indirector::Envelope
  include ::Puppet::Network::FormatSupport
  def bucket_path(); end

  def checksum(); end

  def checksum_data(); end

  def checksum_type(); end

  def contents(); end

  def initialize(contents, options=T.unsafe(nil)); end

  def name(); end

  def size(); end

  def stream(&block); end

  def to_binary(); end
end

class Puppet::FileBucket::File::FileContents
  def checksum_data(base_method); end

  def initialize(path); end

  def size(); end

  def stream(&block); end

  def to_binary(); end
end

class Puppet::FileBucket::File::FileContents
end

class Puppet::FileBucket::File::StringContents
  def checksum_data(base_method); end

  def initialize(content); end

  def size(); end

  def stream(&block); end

  def to_binary(); end
end

class Puppet::FileBucket::File::StringContents
end

class Puppet::FileBucket::File
  extend ::Puppet::Indirector
  extend ::Puppet::Indirector::ClassMethods
  def self.from_binary(contents); end
end

module Puppet::FileBucket
  extend ::T::Sig
end

module Puppet::FileBucketFile
end

class Puppet::FileBucketFile::Selector
  def authorized?(request); end

  def destroy(request); end

  def find(request); end

  def get_terminus(request); end

  def head(request); end

  def save(request); end

  def search(request); end

  def select(request); end
end

class Puppet::FileBucketFile::Selector
end

module Puppet::FileBucketFile
  extend ::T::Sig
end

module Puppet::FileSystem
end

class Puppet::FileSystem::AbsolutePathPattern
  def absolute?(); end
end

class Puppet::FileSystem::AbsolutePathPattern
end

class Puppet::FileSystem::FileImpl
  def assert_path(path); end

  def basename(path); end

  def binread(path); end

  def children(path); end

  def chmod(mode, path); end

  def compare_stream(path, stream); end

  def dir(path); end

  def directory?(path); end

  def each_line(path, &block); end

  def exclusive_create(path, mode, &block); end

  def exclusive_open(path, mode, options=T.unsafe(nil), timeout=T.unsafe(nil), &block); end

  def executable?(path); end

  def exist?(path); end

  def expand_path(path, dir_string=T.unsafe(nil)); end

  def file?(path); end

  def lstat(path); end

  def mkpath(path); end

  def open(path, mode, options, &block); end

  def path_string(path); end

  def pathname(path); end

  def read(path, opts=T.unsafe(nil)); end

  def read_preserve_line_endings(path); end

  def readlink(path); end

  def replace_file(path, mode=T.unsafe(nil)); end

  def size(path); end

  def stat(path); end

  def symlink(path, dest, options=T.unsafe(nil)); end

  def symlink?(path); end

  def touch(path, mtime: T.unsafe(nil)); end

  def unlink(*paths); end

  def writable?(path); end
end

class Puppet::FileSystem::FileImpl
end

class Puppet::FileSystem::MemoryFile
  def absolute?(); end

  def children(); end

  def directory?(); end

  def duplicate_as(other_path); end

  def each_line(&block); end

  def executable?(); end

  def exist?(); end

  def handle(); end

  def initialize(path, properties); end

  def path(); end

  def to_path(); end
end

class Puppet::FileSystem::MemoryFile
  def self.a_directory(path, children=T.unsafe(nil)); end

  def self.a_missing_file(path); end

  def self.a_regular_file_containing(path, content); end

  def self.an_executable(path); end
end

class Puppet::FileSystem::MemoryImpl
  def assert_path(path); end

  def basename(path); end

  def children(path); end

  def directory?(path); end

  def each_line(path, &block); end

  def executable?(path); end

  def exist?(path); end

  def expand_path(path, dir_string=T.unsafe(nil)); end

  def file?(path); end

  def initialize(*files); end

  def open(path, *args, &block); end

  def path_string(object); end

  def pathname(path); end

  def read(path, opts=T.unsafe(nil)); end

  def read_preserve_line_endings(path); end
end

class Puppet::FileSystem::MemoryImpl
end

class Puppet::FileSystem::PathPattern
  def glob(); end

  def initialize(pattern); end

  def pathname(); end

  def prefix_with(prefix); end
  ABSOLUTE_UNIX = ::T.let(nil, ::T.untyped)
  ABSOLUTE_WINDOWS = ::T.let(nil, ::T.untyped)
  CURRENT_DRIVE_RELATIVE_WINDOWS = ::T.let(nil, ::T.untyped)
  TRAVERSAL = ::T.let(nil, ::T.untyped)
end

class Puppet::FileSystem::PathPattern::InvalidPattern
end

class Puppet::FileSystem::PathPattern::InvalidPattern
end

class Puppet::FileSystem::PathPattern
  def self.absolute(pattern); end

  def self.relative(pattern); end
end

class Puppet::FileSystem::Posix
end

class Puppet::FileSystem::Posix
end

class Puppet::FileSystem::RelativePathPattern
  def absolute?(); end
end

class Puppet::FileSystem::RelativePathPattern
end

class Puppet::FileSystem::Uniquefile
  def _close(); end

  def close(unlink_now=T.unsafe(nil)); end

  def close!(); end

  def delete(); end

  def initialize(basename, *rest); end

  def open(); end

  def path(); end

  def unlink(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Puppet::FileSystem::Uniquefile
  def self.locking(tmpname); end

  def self.mkdir(*args); end

  def self.open_tmp(identifier); end

  def self.rmdir(*args); end
end

module Puppet::FileSystem
  extend ::T::Sig
  def self.assert_path(path); end

  def self.basename(path); end

  def self.basename_string(path); end

  def self.binread(path); end

  def self.children(path); end

  def self.chmod(mode, path); end

  def self.compare_stream(path, stream); end

  def self.dir(path); end

  def self.dir_exist?(path); end

  def self.dir_mkpath(path); end

  def self.dir_string(path); end

  def self.directory?(path); end

  def self.each_line(path, &block); end

  def self.exclusive_create(path, mode, &block); end

  def self.exclusive_open(path, mode, options=T.unsafe(nil), timeout=T.unsafe(nil), &block); end

  def self.executable?(path); end

  def self.exist?(path); end

  def self.expand_path(path, dir_string=T.unsafe(nil)); end

  def self.file?(path); end

  def self.lstat(path); end

  def self.mkpath(path); end

  def self.open(path, mode, options, &block); end

  def self.overlay(*files, &block); end

  def self.path_string(path); end

  def self.pathname(path); end

  def self.read(path, opts=T.unsafe(nil)); end

  def self.read_preserve_line_endings(path); end

  def self.readlink(path); end

  def self.replace_file(path, mode=T.unsafe(nil), &block); end

  def self.size(path); end

  def self.stat(path); end

  def self.symlink(path, dest, options=T.unsafe(nil)); end

  def self.symlink?(path); end

  def self.touch(path, mtime: T.unsafe(nil)); end

  def self.unlink(*paths); end

  def self.writable?(path); end
end

module Puppet::Functions
end

class Puppet::Functions::DispatcherBuilder
  def block_param(*type_and_name); end

  def initialize(dispatcher, all_callables, loader); end

  def loader(); end

  def optional_block_param(*type_and_name); end

  def optional_param(type, name); end

  def optional_repeated_param(type, name); end

  def param(type, name); end

  def repeated_param(type, name); end

  def required_block_param(*type_and_name); end

  def required_param(type, name); end

  def required_repeated_param(type, name); end

  def return_type(type); end
end

class Puppet::Functions::DispatcherBuilder
end

class Puppet::Functions::Function
end

class Puppet::Functions::Function
  def self.argument_mismatch(meth_name, &block); end

  def self.builder(); end

  def self.dispatch(meth_name, &block); end

  def self.local_types(&block); end

  def self.new(closure_scope, given_loader); end
end

class Puppet::Functions::Function3x
  PARAM_NAMES = ::T.let(nil, ::T.untyped)
end

class Puppet::Functions::Function3x
  def self.create_function(func_name, func_info, loader); end

  def self.from_to_names(func_info); end
end

class Puppet::Functions::InternalDispatchBuilder
  def cache_param(); end

  def compiler_param(); end

  def pal_compiler_param(); end

  def scope_param(); end

  def script_compiler_param(); end
end

class Puppet::Functions::InternalDispatchBuilder
end

class Puppet::Functions::InternalFunction
  def call_function_with_scope(scope, function_name, *args, &block); end
end

class Puppet::Functions::InternalFunction
end

class Puppet::Functions::LocalTypeAliasesBuilder
  def initialize(loader, name); end

  def loader(); end

  def local_types(); end

  def parser(); end

  def type(assignment_string); end
end

class Puppet::Functions::LocalTypeAliasesBuilder
end

class Puppet::Functions::PuppetFunction
end

class Puppet::Functions::PuppetFunction
  def self.init_dispatch(a_closure); end
end

module Puppet::Functions
  extend ::T::Sig
  def self.any_signature(from, to, names); end

  def self.create_function(func_name, function_base=T.unsafe(nil), &block); end

  def self.create_loaded_function(func_name, loader, function_base=T.unsafe(nil), &block); end

  def self.default_dispatcher(the_class, func_name); end

  def self.min_max_param(method); end
end

module Puppet::GettextConfig
  DEFAULT_TEXT_DOMAIN = ::T.let(nil, ::T.untyped)
  LOCAL_PATH = ::T.let(nil, ::T.untyped)
  POSIX_PATH = ::T.let(nil, ::T.untyped)
  WINDOWS_PATH = ::T.let(nil, ::T.untyped)
end

module Puppet::GettextConfig
  extend ::T::Sig
  def self.add_repository_to_domain(project_name, locale_dir, file_format, text_domain=T.unsafe(nil)); end

  def self.clear_text_domain(); end

  def self.copy_default_translations(domain_name); end

  def self.create_default_text_domain(); end

  def self.current_locale(); end

  def self.delete_all_text_domains(); end

  def self.delete_environment_text_domains(); end

  def self.delete_text_domain(domain_name); end

  def self.disable_gettext(); end

  def self.gettext_loaded?(); end

  def self.load_translations(project_name, locale_dir, file_format, text_domain=T.unsafe(nil)); end

  def self.loaded_text_domains(); end

  def self.puppet_locale_path(); end

  def self.reset_text_domain(domain_name); end

  def self.set_locale(locale); end

  def self.setup_locale(); end

  def self.translation_mode(conf_path); end

  def self.use_text_domain(domain_name); end
end

module Puppet::Graph
end

class Puppet::Graph::Key
  include ::Comparable
  def down(); end

  def initialize(value=T.unsafe(nil)); end

  def next(); end

  def value(); end
end

class Puppet::Graph::Key
end

class Puppet::Graph::Prioritizer
  def forget(key); end

  def generate_priority_contained_in(container, key); end

  def generate_priority_for(key); end

  def priority_of(key); end

  def record_priority_for(key, priority); end
end

class Puppet::Graph::Prioritizer
end

class Puppet::Graph::RbTreeMap
  include ::Enumerable
  def [](key); end

  def []=(key, value); end

  def delete(key); end

  def delete_max(); end

  def delete_min(); end

  def each(&blk); end

  def empty?(); end

  def first(); end

  def get(key); end

  def has_key?(key); end

  def last(); end

  def length(); end

  def max_key(); end

  def min_key(); end

  def push(key, value); end

  def size(); end

  def to_hash(); end
end

class Puppet::Graph::RbTreeMap::Node
  def color(); end

  def color=(color); end

  def colorflip(); end

  def fixup(); end

  def initialize(key, value); end

  def key(); end

  def key=(key); end

  def left(); end

  def left=(left); end

  def move_red_left(); end

  def move_red_right(); end

  def red?(); end

  def right(); end

  def right=(right); end

  def rotate_left(); end

  def rotate_right(); end

  def to_hash(); end

  def value(); end

  def value=(value); end
end

class Puppet::Graph::RbTreeMap::Node
end

class Puppet::Graph::RbTreeMap
end

class Puppet::Graph::RelationshipGraph
  def add_relationship(f, t, label=T.unsafe(nil)); end

  def add_vertex(vertex, priority=T.unsafe(nil)); end

  def blockers(); end

  def clear_blockers(); end

  def enqueue(*resources); end

  def enqueue_roots(); end

  def finish(resource); end

  def initialize(prioritizer); end

  def next_resource(); end

  def populate_from(catalog); end

  def remove_vertex!(vertex); end

  def resource_priority(resource); end

  def traverse(options=T.unsafe(nil), &block); end

  def unblock(resource); end
  Default_label = ::T.let(nil, ::T.untyped)
end

class Puppet::Graph::RelationshipGraph
end

class Puppet::Graph::SequentialPrioritizer
end

class Puppet::Graph::SequentialPrioritizer
end

class Puppet::Graph::SimpleGraph
  include ::Puppet::Util::PsychSupport
  def add_edge(e, *a); end

  def add_relationship(source, target, label=T.unsafe(nil)); end

  def add_vertex(vertex); end

  def adjacent(v, options=T.unsafe(nil)); end

  def clear(); end

  def dependencies(resource); end

  def dependents(resource); end

  def direct_dependencies_of(v); end

  def direct_dependents_of(v); end

  def directed?(); end

  def downstream_from_vertex(v); end

  def each_edge(); end

  def edge?(source, target); end

  def edges(); end

  def edges_between(source, target); end

  def find_cycles_in_graph(); end

  def initialize_from_hash(hash); end

  def leaves(vertex, direction=T.unsafe(nil)); end

  def matching_edges(event, base=T.unsafe(nil)); end

  def path_between(f, t); end

  def paths_in_cycle(cycle, max_paths=T.unsafe(nil)); end

  def remove_edge!(e); end

  def remove_vertex!(v); end

  def report_cycles_in_graph(); end

  def reversal(); end

  def size(); end

  def stringify(s); end

  def tarjan(root, s); end

  def to_a(); end

  def to_data_hash(); end

  def to_dot(params=T.unsafe(nil)); end

  def to_dot_graph(params=T.unsafe(nil)); end

  def tree_from_vertex(start, direction=T.unsafe(nil)); end

  def upstream_from_vertex(v); end

  def vertex?(v); end

  def vertices(); end

  def walk(source, direction); end

  def write_cycles_to_graph(cycles); end

  def write_graph(name); end
end

class Puppet::Graph::SimpleGraph
  def self.use_new_yaml_format(); end

  def self.use_new_yaml_format=(use_new_yaml_format); end
end

module Puppet::Graph
  extend ::T::Sig
end

class Puppet::ImportError
end

class Puppet::ImportError
end

module Puppet::Indirector
  def indirects(indirection, options=T.unsafe(nil)); end
  BadNameRegexp = ::T.let(nil, ::T.untyped)
end

module Puppet::Indirector::ClassMethods
  def indirection(); end
end

module Puppet::Indirector::ClassMethods
  extend ::T::Sig
end

class Puppet::Indirector::Code
end

class Puppet::Indirector::Code
end

module Puppet::Indirector::Envelope
  def expiration(); end

  def expiration=(expiration); end

  def expired?(); end
end

module Puppet::Indirector::Envelope
  extend ::T::Sig
end

class Puppet::Indirector::Indirection
  include ::Puppet::Util::Docs
  def allow_remote_requests?(); end

  def cache(); end

  def cache?(); end

  def cache_class(); end

  def cache_class=(class_name); end

  def delete(); end

  def destroy(key, options=T.unsafe(nil)); end

  def expiration(); end

  def expire(key, options=T.unsafe(nil)); end

  def find(key, options=T.unsafe(nil)); end

  def find_in_cache(request); end

  def head(key, options=T.unsafe(nil)); end

  def initialize(model, name, doc: T.unsafe(nil), indirected_class: T.unsafe(nil), cache_class: T.unsafe(nil), terminus_class: T.unsafe(nil), terminus_setting: T.unsafe(nil), extend: T.unsafe(nil)); end

  def model(); end

  def model=(model); end

  def name(); end

  def name=(name); end

  def request(*args); end

  def reset_terminus_class(); end

  def save(instance, key=T.unsafe(nil), options=T.unsafe(nil)); end

  def search(key, options=T.unsafe(nil)); end

  def termini(); end

  def terminus(terminus_name=T.unsafe(nil)); end

  def terminus_class(); end

  def terminus_class=(klass); end

  def terminus_setting(); end

  def terminus_setting=(terminus_setting); end

  def ttl(); end

  def ttl=(value); end

  def validate_terminus_class(terminus_class); end
end

class Puppet::Indirector::Indirection
  def self.instance(name); end

  def self.instances(); end

  def self.model(name); end
end

class Puppet::Indirector::Request
  include ::Puppet::Util::PsychSupport
  include ::Puppet::Util::Warnings
  def authenticated(); end

  def authenticated=(authenticated); end

  def authenticated?(); end

  def description(); end

  def do_request(srv_service=T.unsafe(nil), default_server=T.unsafe(nil), default_port=T.unsafe(nil), &block); end

  def encode_params(params); end

  def environment(); end

  def environment=(env); end

  def expand_into_parameters(data); end

  def expand_primitive_types_into_parameters(data); end

  def ignore_cache(); end

  def ignore_cache=(ignore_cache); end

  def ignore_cache?(); end

  def ignore_cache_save(); end

  def ignore_cache_save=(ignore_cache_save); end

  def ignore_cache_save?(); end

  def ignore_terminus(); end

  def ignore_terminus=(ignore_terminus); end

  def ignore_terminus?(); end

  def indirection(); end

  def indirection_name(); end

  def indirection_name=(name); end

  def initialize(indirection_name, method, key, instance, options=T.unsafe(nil)); end

  def initialize_from_hash(hash); end

  def instance(); end

  def instance=(instance); end

  def ip(); end

  def ip=(ip); end

  def key(); end

  def key=(key); end

  def method(); end

  def method=(method); end

  def model(); end

  def node(); end

  def node=(node); end

  def options(); end

  def options=(options); end

  def plural?(); end

  def port(); end

  def port=(port); end

  def protocol(); end

  def protocol=(protocol); end

  def query_string(); end

  def remote?(); end

  def server(); end

  def server=(server); end

  def to_data_hash(); end

  def to_hash(); end

  def uri(); end

  def uri=(uri); end
  OPTION_ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class Puppet::Indirector::Request
end

class Puppet::Indirector::SslFile
  def destroy(request); end

  def find(request); end

  def path(name); end

  def save(request); end

  def search(request); end
end

class Puppet::Indirector::SslFile
  def self.collection_directory(); end

  def self.directory_setting(); end

  def self.file_location(); end

  def self.file_setting(); end

  def self.store_at(setting); end

  def self.store_in(setting); end
end

class Puppet::Indirector::Status
end

class Puppet::Indirector::Status::Local
  def find(*anything); end
end

class Puppet::Indirector::Status::Local
end

class Puppet::Indirector::Status
end

class Puppet::Indirector::Terminus
  def allow_remote_requests?(); end

  def indirection(); end

  def model(); end

  def name(); end

  def terminus_type(); end

  def validate(request); end

  def validate_key(request); end

  def validate_model(request); end
end

class Puppet::Indirector::Terminus
  extend ::Puppet::Util::Docs
  extend ::Puppet::Util::InstanceLoader
  extend ::Puppet::Util
  def self.abstract_terminus(); end

  def self.abstract_terminus?(); end

  def self.certificate(name); end

  def self.certificate_request(name); end

  def self.const2name(const); end

  def self.file_bucket_file(name); end

  def self.indirection(); end

  def self.indirection=(name); end

  def self.indirection_name(); end

  def self.inherited(subclass); end

  def self.key(name); end

  def self.mark_as_abstract_terminus(); end

  def self.model(); end

  def self.name2const(name); end

  def self.name=(name); end

  def self.register_terminus_class(klass); end

  def self.report(name); end

  def self.resource(name); end

  def self.status(name); end

  def self.terminus_class(indirection_name, terminus_type); end

  def self.terminus_classes(indirection_name); end

  def self.terminus_type(); end

  def self.terminus_type=(terminus_type); end
end

class Puppet::Indirector::ValidationError
end

class Puppet::Indirector::ValidationError
end

module Puppet::Indirector
  extend ::T::Sig
  def self.configure_routes(application_routes); end
end

class Puppet::LexError
end

class Puppet::LexError
end

class Puppet::LockError
end

class Puppet::LockError
end

Puppet::Log = Puppet::Util::Log

module Puppet::MetaType
end

module Puppet::MetaType::Manager
  include ::Puppet::Util::ClassGen
  include ::Puppet::Util
  def allclear(); end

  def clear_misses(); end

  def eachtype(); end

  def loadall(); end

  def newtype(name, options=T.unsafe(nil), &block); end

  def rmtype(name); end

  def type(name); end

  def typeloader(); end
end

module Puppet::MetaType::Manager
  extend ::T::Sig
end

module Puppet::MetaType
  extend ::T::Sig
end

class Puppet::MissingCommand
end

class Puppet::MissingCommand
end

class Puppet::Module
  include ::Puppet::Util::Logging
  def ==(other); end

  def all_manifests(); end

  def author(); end

  def author=(author); end

  def dependencies(); end

  def dependencies=(dependencies); end

  def dependencies_as_modules(); end

  def description(); end

  def description=(description); end

  def environment(); end

  def environment=(environment); end

  def file(file); end

  def files(); end

  def files?(); end

  def forge_name(); end

  def forge_name=(forge_name); end

  def has_external_facts?(); end

  def has_hiera_conf?(); end

  def has_metadata?(); end

  def has_translations?(locale); end

  def hiera_conf_file(); end

  def initialize(name, path, environment); end

  def license(); end

  def license=(license); end

  def license_file(); end

  def load_metadata(); end

  def locale(file); end

  def locale_directory(); end

  def locales(); end

  def locales?(); end

  def manifest(file); end

  def manifests(); end

  def manifests?(); end

  def match_manifests(rest); end

  def metadata(); end

  def metadata_file(); end

  def modulepath(); end

  def name(); end

  def path(); end

  def plugin(file); end

  def plugin_directory(); end

  def plugin_fact_directory(); end

  def pluginfact(file); end

  def pluginfacts(); end

  def pluginfacts?(); end

  def plugins(); end

  def plugins?(); end

  def project_page(); end

  def project_page=(project_page); end

  def puppetversion(); end

  def puppetversion=(something); end

  def read_metadata(); end

  def required_by(); end

  def source(); end

  def source=(source); end

  def summary(); end

  def summary=(summary); end

  def supports(name, version=T.unsafe(nil)); end

  def task_file(name); end

  def tasks(); end

  def tasks_directory(); end

  def template(file); end

  def templates(); end

  def templates?(); end

  def unmet_dependencies(); end

  def validate_puppet_version(); end

  def version(); end

  def version=(version); end
  FILETYPES = ::T.let(nil, ::T.untyped)
end

class Puppet::Module::Error
end

class Puppet::Module::Error
end

class Puppet::Module::FaultyMetadata
end

class Puppet::Module::FaultyMetadata
end

class Puppet::Module::IncompatibleModule
end

class Puppet::Module::IncompatibleModule
end

class Puppet::Module::IncompatiblePlatform
end

class Puppet::Module::IncompatiblePlatform
end

class Puppet::Module::InvalidFilePattern
end

class Puppet::Module::InvalidFilePattern
end

class Puppet::Module::InvalidName
end

class Puppet::Module::InvalidName
end

class Puppet::Module::MissingMetadata
end

class Puppet::Module::MissingMetadata
end

class Puppet::Module::MissingModule
end

class Puppet::Module::MissingModule
end

class Puppet::Module::Task
  def ==(other); end

  def files(); end

  def initialize(pup_module, task_name, module_executables, metadata_file=T.unsafe(nil)); end

  def metadata(); end

  def metadata_file(); end

  def module(); end

  def name(); end

  def validate(); end
  FORBIDDEN_EXTENSIONS = ::T.let(nil, ::T.untyped)
  MOUNTS = ::T.let(nil, ::T.untyped)
end

class Puppet::Module::Task::Error
  def details(); end

  def details=(details); end

  def initialize(message, kind, details=T.unsafe(nil)); end

  def kind(); end

  def kind=(kind); end

  def to_h(); end
end

class Puppet::Module::Task::Error
end

class Puppet::Module::Task::InvalidFile
  def initialize(msg); end
end

class Puppet::Module::Task::InvalidFile
end

class Puppet::Module::Task::InvalidMetadata
end

class Puppet::Module::Task::InvalidMetadata
end

class Puppet::Module::Task::InvalidName
  def initialize(name); end
end

class Puppet::Module::Task::InvalidName
end

class Puppet::Module::Task::InvalidTask
end

class Puppet::Module::Task::InvalidTask
end

class Puppet::Module::Task::TaskNotFound
  def initialize(task_name, module_name); end
end

class Puppet::Module::Task::TaskNotFound
end

class Puppet::Module::Task
  def self.find_files(name, directory, metadata, executables, envname=T.unsafe(nil)); end

  def self.is_task_name?(name); end

  def self.is_tasks_executable_filename?(name); end

  def self.is_tasks_filename?(path); end

  def self.is_tasks_metadata_filename?(name); end

  def self.read_metadata(file); end

  def self.tasks_in_module(pup_module); end
end

class Puppet::Module::UnsupportedPlatform
end

class Puppet::Module::UnsupportedPlatform
end

class Puppet::Module
  def self.find(modname, environment=T.unsafe(nil)); end

  def self.is_module_directory?(name, path); end

  def self.is_module_directory_name?(name); end

  def self.is_module_namespaced_name?(name); end

  def self.parse_range(range); end
end

module Puppet::ModuleTranslations
end

module Puppet::ModuleTranslations
  extend ::T::Sig
  def self.load_from_modulepath(modules); end

  def self.load_from_vardir(vardir); end
end

module Puppet::Network
end

class Puppet::Network::AuthConfig
  def check_authorization(method, path, params); end

  def initialize(rights=T.unsafe(nil)); end
end

class Puppet::Network::AuthConfig
  def self.authprovider_class(); end

  def self.authprovider_class=(klass); end
end

class Puppet::Network::AuthConfigLoader
end

class Puppet::Network::AuthConfigLoader
  def self.authconfig(); end
end

class Puppet::Network::AuthConfigParser
  def initialize(string); end

  def modify_right(right, method, value, msg, count); end

  def parse(); end

  def parse_right_directive(right, var, value, count); end

  def parse_rights(); end
end

class Puppet::Network::AuthConfigParser
  def self.new_from_file(file); end
end

class Puppet::Network::AuthStore
  include ::Puppet::Util::Logging
  def allow(pattern); end

  def allow_ip(pattern); end

  def allowed?(name, ip); end

  def deny(pattern); end

  def deny_ip(pattern); end

  def empty?(); end

  def globalallow?(); end

  def interpolate(match); end

  def reset_interpolation(); end
end

class Puppet::Network::AuthStore::Declaration
  include ::Puppet::Util
  include ::Comparable
  def deny?(); end

  def exact?(); end

  def initialize(type, pattern); end

  def interpolate(match); end

  def ip?(); end

  def length(); end

  def length=(length); end

  def match?(name, ip); end

  def name(); end

  def name=(name); end

  def pattern(); end

  def pattern=(pattern); end

  def result(); end

  def type(); end

  def type=(type); end
  IP = ::T.let(nil, ::T.untyped)
  IPv4 = ::T.let(nil, ::T.untyped)
  IPv6_full = ::T.let(nil, ::T.untyped)
  IPv6_partial = ::T.let(nil, ::T.untyped)
  Octet = ::T.let(nil, ::T.untyped)
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Puppet::Network::AuthStore::Declaration
end

class Puppet::Network::AuthStore
end

module Puppet::Network::Authorization
  def authconfig(); end

  def check_authorization(method, path, params); end
end

module Puppet::Network::Authorization
  extend ::T::Sig
  def self.authconfigloader_class=(klass); end
end

class Puppet::Network::AuthorizationError
end

class Puppet::Network::AuthorizationError
end

class Puppet::Network::ClientRequest
  def authenticated(); end

  def authenticated=(authenticated); end

  def authenticated?(); end

  def call(); end

  def handler(); end

  def handler=(handler); end

  def initialize(name, ip, authenticated); end

  def ip(); end

  def ip=(ip); end

  def method(); end

  def method=(method); end

  def name(); end

  def name=(name); end
end

class Puppet::Network::ClientRequest
end

class Puppet::Network::DefaultAuthProvider
  def allow(*args); end

  def check_authorization(method, path, params); end

  def deny(*args); end

  def initialize(rights=T.unsafe(nil)); end

  def insert_default_acl(); end

  def mk_acl(acl); end

  def rights(); end

  def rights=(rights); end
end

class Puppet::Network::DefaultAuthProvider
  def self.default_acl(); end

  def self.master_url_prefix(); end
end

class Puppet::Network::Format
  include ::Puppet::Confiner
  def charset(); end

  def charset=(charset); end

  def extension(); end

  def extension=(extension); end

  def init_attribute(name, default); end

  def initialize(name, options=T.unsafe(nil), &block); end

  def intern(klass, text); end

  def intern_method(); end

  def intern_method=(intern_method); end

  def intern_multiple(klass, text); end

  def intern_multiple_method(); end

  def intern_multiple_method=(intern_multiple_method); end

  def mime(); end

  def mime=(mime); end

  def name(); end

  def render(instance); end

  def render_method(); end

  def render_method=(render_method); end

  def render_multiple(instances); end

  def render_multiple_method(); end

  def render_multiple_method=(render_multiple_method); end

  def required_methods(); end

  def required_methods=(required_methods); end

  def required_methods_present?(klass); end

  def supported?(klass); end

  def weight(); end

  def weight=(weight); end
end

class Puppet::Network::Format
end

module Puppet::Network::FormatHandler
  ALL_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
end

class Puppet::Network::FormatHandler::FormatError
end

class Puppet::Network::FormatHandler::FormatError
end

module Puppet::Network::FormatHandler
  extend ::T::Sig
  def self.create(*args, &block); end

  def self.create_serialized_formats(name, options=T.unsafe(nil), &block); end

  def self.format(name); end

  def self.format_by_extension(ext); end

  def self.format_for(name); end

  def self.format_to_canonical_name(format); end

  def self.format_to_canonical_name_or_nil(format); end

  def self.formats(); end

  def self.mime(mimetype); end

  def self.most_suitable_formats_for(accepted, supported); end
end

module Puppet::Network::FormatSupport
  def mime(format=T.unsafe(nil)); end

  def render(format=T.unsafe(nil)); end

  def support_format?(name); end

  def to_json(*args); end

  def to_msgpack(*args); end

  def to_pson(*args); end
end

module Puppet::Network::FormatSupport
  extend ::T::Sig
  def self.included(klass); end
end

module Puppet::Network::HTTP
  CA_URL_PREFIX = ::T.let(nil, ::T.untyped)
  CA_URL_VERSIONS = ::T.let(nil, ::T.untyped)
  HEADER_ENABLE_PROFILING = ::T.let(nil, ::T.untyped)
  HEADER_PUPPET_VERSION = ::T.let(nil, ::T.untyped)
  MASTER_URL_PREFIX = ::T.let(nil, ::T.untyped)
  MASTER_URL_VERSIONS = ::T.let(nil, ::T.untyped)
end

class Puppet::Network::HTTP::API
end

class Puppet::Network::HTTP::API::IndirectedRoutes
  include ::Puppet::Network::Authorization
  def call(request, response); end

  def uri2indirection(http_method, uri, params); end
  METHOD_MAP = ::T.let(nil, ::T.untyped)
end

Puppet::Network::HTTP::API::IndirectedRoutes::IndirectionType = Puppet::Network::HTTP::API::IndirectionType

class Puppet::Network::HTTP::API::IndirectedRoutes
  def self.pluralize(indirection); end

  def self.request_to_uri(request); end

  def self.request_to_uri_and_body(request); end

  def self.routes(); end
end

class Puppet::Network::HTTP::API::IndirectionType
  INDIRECTION_TYPE_MAP = ::T.let(nil, ::T.untyped)
end

class Puppet::Network::HTTP::API::IndirectionType
  def self.ca_url_prefix(); end

  def self.master_url_prefix(); end

  def self.type_for(indirection); end

  def self.url_prefix_for(indirection_name); end
end

module Puppet::Network::HTTP::API::Master
end

class Puppet::Network::HTTP::API::Master::V3
  AUTHZ = ::T.let(nil, ::T.untyped)
  ENVIRONMENT = ::T.let(nil, ::T.untyped)
  ENVIRONMENTS = ::T.let(nil, ::T.untyped)
  INDIRECTED = ::T.let(nil, ::T.untyped)
end

class Puppet::Network::HTTP::API::Master::V3::Authorization
  include ::Puppet::Network::Authorization
  def wrap(&block); end
end

class Puppet::Network::HTTP::API::Master::V3::Authorization
end

class Puppet::Network::HTTP::API::Master::V3::Environment
  def build_environment_graph(catalog); end

  def call(request, response); end
end

class Puppet::Network::HTTP::API::Master::V3::Environment
end

class Puppet::Network::HTTP::API::Master::V3::Environments
  def call(request, response); end

  def initialize(env_loader); end
end

class Puppet::Network::HTTP::API::Master::V3::Environments
end

class Puppet::Network::HTTP::API::Master::V3
  def self.routes(); end
end

module Puppet::Network::HTTP::API::Master
  extend ::T::Sig
end

class Puppet::Network::HTTP::API
  def self.master_routes(); end

  def self.not_found(); end

  def self.not_found_upgrade(); end
end

class Puppet::Network::HTTP::BasePool
  def start(site, verifier, http); end
end

class Puppet::Network::HTTP::BasePool
end

module Puppet::Network::HTTP::Compression
  ACCEPT_ENCODING = ::T.let(nil, ::T.untyped)
end

module Puppet::Network::HTTP::Compression::Active
  def add_accept_encoding(headers=T.unsafe(nil)); end

  def uncompress(response); end

  def uncompress_body(response); end
end

class Puppet::Network::HTTP::Compression::Active::ZlibAdapter
  def close(); end

  def initialize(uncompressor=T.unsafe(nil)); end

  def uncompress(chunk); end
end

class Puppet::Network::HTTP::Compression::Active::ZlibAdapter
end

module Puppet::Network::HTTP::Compression::Active
  extend ::T::Sig
end

class Puppet::Network::HTTP::Compression::IdentityAdapter
  def close(); end

  def uncompress(chunk); end
end

class Puppet::Network::HTTP::Compression::IdentityAdapter
end

module Puppet::Network::HTTP::Compression::None
  def add_accept_encoding(headers); end

  def uncompress(response); end

  def uncompress_body(response); end
end

module Puppet::Network::HTTP::Compression::None
  extend ::T::Sig
end

module Puppet::Network::HTTP::Compression
  extend ::T::Sig
  def self.module(); end
end

class Puppet::Network::HTTP::Connection
  def address(); end

  def delete(path, headers=T.unsafe(nil), options=T.unsafe(nil)); end

  def get(path, headers=T.unsafe(nil), options=T.unsafe(nil)); end

  def head(path, headers=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize(host, port, options=T.unsafe(nil)); end

  def port(); end

  def post(path, data, headers=T.unsafe(nil), options=T.unsafe(nil)); end

  def put(path, data, headers=T.unsafe(nil), options=T.unsafe(nil)); end

  def request(method, *args); end

  def request_get(*args, &block); end

  def request_head(*args, &block); end

  def request_post(*args, &block); end

  def use_ssl?(); end

  def verifier(); end
  OPTION_DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Puppet::Network::HTTP::Connection
end

module Puppet::Network::HTTP::Error
end

class Puppet::Network::HTTP::Error::HTTPBadRequestError
  def initialize(message, issue_kind=T.unsafe(nil)); end
  CODE = ::T.let(nil, ::T.untyped)
end

class Puppet::Network::HTTP::Error::HTTPBadRequestError
end

class Puppet::Network::HTTP::Error::HTTPError
  def initialize(message, status, issue_kind); end

  def issue_kind(); end

  def status(); end

  def to_json(); end
end

class Puppet::Network::HTTP::Error::HTTPError
end

class Puppet::Network::HTTP::Error::HTTPMethodNotAllowedError
  def initialize(message, issue_kind=T.unsafe(nil)); end
  CODE = ::T.let(nil, ::T.untyped)
end

class Puppet::Network::HTTP::Error::HTTPMethodNotAllowedError
end

class Puppet::Network::HTTP::Error::HTTPNotAcceptableError
  def initialize(message, issue_kind=T.unsafe(nil)); end
  CODE = ::T.let(nil, ::T.untyped)
end

class Puppet::Network::HTTP::Error::HTTPNotAcceptableError
end

class Puppet::Network::HTTP::Error::HTTPNotAuthorizedError
  def initialize(message, issue_kind=T.unsafe(nil)); end
  CODE = ::T.let(nil, ::T.untyped)
end

class Puppet::Network::HTTP::Error::HTTPNotAuthorizedError
end

class Puppet::Network::HTTP::Error::HTTPNotFoundError
  def initialize(message, issue_kind=T.unsafe(nil)); end
  CODE = ::T.let(nil, ::T.untyped)
end

class Puppet::Network::HTTP::Error::HTTPNotFoundError
end

class Puppet::Network::HTTP::Error::HTTPServerError
  def initialize(original_error, issue_kind=T.unsafe(nil)); end
  CODE = ::T.let(nil, ::T.untyped)
end

class Puppet::Network::HTTP::Error::HTTPServerError
end

class Puppet::Network::HTTP::Error::HTTPUnsupportedMediaTypeError
  def initialize(message, issue_kind=T.unsafe(nil)); end
  CODE = ::T.let(nil, ::T.untyped)
end

class Puppet::Network::HTTP::Error::HTTPUnsupportedMediaTypeError
end

Puppet::Network::HTTP::Error::Issues = Puppet::Network::HTTP::Issues

module Puppet::Network::HTTP::Error
  extend ::T::Sig
end

class Puppet::Network::HTTP::Factory
  def create_connection(site); end
  KEEP_ALIVE_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Puppet::Network::HTTP::Factory
end

module Puppet::Network::HTTP::Handler
  include ::Puppet::Network::HTTP::Issues
  def find_route_or_raise(request); end

  def format_to_mime(format); end

  def headers(request); end

  def make_generic_request(request); end

  def process(external_request, response); end

  def register(routes); end

  def resolve_node(result); end

  def respond_to_errors(response); end

  def respond_with_http_error(response, exception); end

  def set_content_type(response, format); end

  def set_puppet_version_header(response); end

  def set_response(response, body, status=T.unsafe(nil)); end

  def with_request_profiling(request); end
  DISALLOWED_KEYS = ::T.let(nil, ::T.untyped)
end

module Puppet::Network::HTTP::Handler
  extend ::T::Sig
end

module Puppet::Network::HTTP::Issues
  ENVIRONMENT_NOT_FOUND = ::T.let(nil, ::T.untyped)
  FAILED_AUTHORIZATION = ::T.let(nil, ::T.untyped)
  HANDLER_NOT_FOUND = ::T.let(nil, ::T.untyped)
  MISSING_HEADER_FIELD = ::T.let(nil, ::T.untyped)
  NO_INDIRECTION_REMOTE_REQUESTS = ::T.let(nil, ::T.untyped)
  RESOURCE_NOT_FOUND = ::T.let(nil, ::T.untyped)
  RUNTIME_ERROR = ::T.let(nil, ::T.untyped)
  UNSUPPORTED_FORMAT = ::T.let(nil, ::T.untyped)
  UNSUPPORTED_MEDIA_TYPE = ::T.let(nil, ::T.untyped)
  UNSUPPORTED_METHOD = ::T.let(nil, ::T.untyped)
end

module Puppet::Network::HTTP::Issues
  extend ::T::Sig
end

class Puppet::Network::HTTP::MemoryResponse
  def body(); end

  def code(); end

  def respond_with(code, type, body); end

  def type(); end
end

class Puppet::Network::HTTP::MemoryResponse
end

class Puppet::Network::HTTP::NoCachePool
  def close(); end

  def initialize(factory=T.unsafe(nil)); end

  def with_connection(site, verifier, &block); end
end

class Puppet::Network::HTTP::NoCachePool
end

class Puppet::Network::HTTP::Pool
  def active_sessions(site); end

  def borrow(site, verifier); end

  def close(); end

  def close_connection(site, http); end

  def factory(); end

  def initialize(keepalive_timeout=T.unsafe(nil)); end

  def pool(); end

  def release(site, verifier, http); end

  def setsockopts(netio); end

  def with_connection(site, verifier, &block); end
  FIFTEEN_SECONDS = ::T.let(nil, ::T.untyped)
end

class Puppet::Network::HTTP::Pool
end

class Puppet::Network::HTTP::RedirectionLimitExceededException
end

class Puppet::Network::HTTP::RedirectionLimitExceededException
end

class Puppet::Network::HTTP::Request
  def body(); end

  def body=(_); end

  def client_cert(); end

  def client_cert=(_); end

  def formatter(); end

  def headers(); end

  def headers=(_); end

  def method(); end

  def method=(_); end

  def params(); end

  def params=(_); end

  def path(); end

  def path=(_); end

  def response_formatters_for(supported_formats, default_accepted_formats=T.unsafe(nil)); end

  def route_into(prefix); end

  def routing_path(); end

  def routing_path=(_); end
end

class Puppet::Network::HTTP::Request
  def self.[](*_); end

  def self.from_hash(hash); end

  def self.members(); end
end

class Puppet::Network::HTTP::Response
  def initialize(handler, response); end

  def respond_with(code, type, body); end
end

class Puppet::Network::HTTP::Response
end

class Puppet::Network::HTTP::Route
  def any(*handlers); end

  def chain(*routes); end

  def delete(*handlers); end

  def get(*handlers); end

  def head(*handlers); end

  def initialize(path_matcher); end

  def matches?(request); end

  def options(*handlers); end

  def path_matcher(); end

  def post(*handlers); end

  def process(request, response); end

  def put(*handlers); end
  MethodNotAllowedHandler = ::T.let(nil, ::T.untyped)
  NO_HANDLERS = ::T.let(nil, ::T.untyped)
end

class Puppet::Network::HTTP::Route
  def self.path(path_matcher); end
end

class Puppet::Network::HTTP::Session
  def connection(); end

  def expired?(now); end

  def initialize(connection, verifier, expiration_time); end

  def verifier(); end
end

class Puppet::Network::HTTP::Session
end

class Puppet::Network::HTTP::Site
  def ==(rhs); end

  def addr(); end

  def eql?(rhs); end

  def host(); end

  def initialize(scheme, host, port); end

  def move_to(uri); end

  def port(); end

  def scheme(); end

  def use_ssl?(); end
end

class Puppet::Network::HTTP::Site
end

module Puppet::Network::HTTP
  extend ::T::Sig
end

module Puppet::Network::HttpPool
end

module Puppet::Network::HttpPool
  extend ::T::Sig
  def self.connection(host, port, use_ssl: T.unsafe(nil), ssl_context: T.unsafe(nil)); end

  def self.http_client_class(); end

  def self.http_client_class=(klass); end

  def self.http_instance(host, port, use_ssl=T.unsafe(nil), verify_peer=T.unsafe(nil)); end

  def self.http_ssl_instance(host, port, verifier=T.unsafe(nil)); end
end

class Puppet::Network::Resolver
  def each_srv_record(domain, service_name=T.unsafe(nil), &block); end

  def expired?(service_name); end

  def find_weighted_server(records); end

  def ttl(service_name); end

  def weight(record); end
end

class Puppet::Network::Resolver::CacheEntry
  def choose_lowest_ttl(records); end

  def initialize(records); end

  def records(); end

  def resolution_time(); end

  def ttl(); end
end

class Puppet::Network::Resolver::CacheEntry
end

class Puppet::Network::Resolver
end

class Puppet::Network::Rights
  def [](name); end

  def allowed?(name, *args); end

  def each(); end

  def empty?(); end

  def include?(name); end

  def is_forbidden_and_why?(name, args=T.unsafe(nil)); end

  def is_request_forbidden_and_why?(method, path, params); end

  def newright(name, line=T.unsafe(nil), file=T.unsafe(nil)); end
end

class Puppet::Network::Rights::Right
  def ==(name); end

  def allowed?(name, ip, args=T.unsafe(nil)); end

  def authentication(); end

  def authentication=(authentication); end

  def debug(args); end

  def environment(); end

  def environment=(environment); end

  def file(); end

  def file=(file); end

  def initialize(name, line, file); end

  def key(); end

  def key=(key); end

  def line(); end

  def line=(line); end

  def match?(key); end

  def methods(); end

  def methods=(methods); end

  def name(); end

  def name=(name); end

  def restrict_authenticated(authentication); end

  def restrict_environment(environment); end

  def restrict_method(m); end

  def valid?(); end
  ALL = ::T.let(nil, ::T.untyped)
end

class Puppet::Network::Rights::Right
end

class Puppet::Network::Rights
end

module Puppet::Network
  extend ::T::Sig
end

class Puppet::Node
  include ::Puppet::Util::PsychSupport
  include ::Puppet::Indirector::Envelope
  include ::Puppet::Network::FormatSupport
  def add_extra_facts(extra_facts); end

  def add_server_facts(facts); end

  def classes(); end

  def classes=(classes); end

  def environment(); end

  def environment=(env); end

  def environment_name(); end

  def environment_name=(environment_name); end

  def fact_merge(facts=T.unsafe(nil)); end

  def facts(); end

  def has_environment_instance?(); end

  def initialize(name, options=T.unsafe(nil)); end

  def initialize_from_hash(data); end

  def ipaddress(); end

  def ipaddress=(ipaddress); end

  def merge(params); end

  def name(); end

  def name=(name); end

  def names(); end

  def parameters(); end

  def parameters=(parameters); end

  def sanitize(); end

  def serializable_parameters(); end

  def server_facts(); end

  def source(); end

  def source=(source); end

  def split_name(name); end

  def time(); end

  def to_data_hash(); end

  def trusted_data(); end

  def trusted_data=(data); end
  ENVIRONMENT = ::T.let(nil, ::T.untyped)
end

class Puppet::Node::Environment
  def ==(other); end

  def [](param); end

  def check_for_reparse(); end

  def config_version(); end

  def configuration(); end

  def conflicting_manifest_settings?(); end

  def each_plugin_directory(&block); end

  def eql?(other); end

  def full_modulepath(); end

  def initialize(name, modulepath, manifest, config_version); end

  def known_resource_types(); end

  def loaders(); end

  def loaders=(loaders); end

  def manifest(); end

  def module(name); end

  def module_by_forge_name(forge_name); end

  def module_requirements(); end

  def modulepath(); end

  def modules(); end

  def modules_by_path(); end

  def name(); end

  def override_from_commandline(settings); end

  def override_with(env_params); end

  def rich_data?(); end

  def static_catalogs?(); end

  def to_sym(); end

  def to_yaml(); end

  def validation_errors(); end

  def warn_about_mistaken_path(path, name); end

  def with_text_domain(); end
  NONE = ::T.let(nil, ::T.untyped)
  NO_MANIFEST = ::T.let(nil, ::T.untyped)
end

class Puppet::Node::Environment::None
end

class Puppet::Node::Environment::None
end

class Puppet::Node::Environment::Remote
end

class Puppet::Node::Environment::Remote
end

class Puppet::Node::Environment
  def self.create(name, modulepath, manifest=T.unsafe(nil), config_version=T.unsafe(nil)); end

  def self.expand_dirs(dirs); end

  def self.extralibs(); end

  def self.remote(name); end

  def self.split_path(path_string); end

  def self.valid_name?(name); end
end

class Puppet::Node::Facts
  include ::Puppet::Util::PsychSupport
  include ::Puppet::Indirector::Envelope
  include ::Puppet::Network::FormatSupport
  def ==(other); end

  def add_extra_values(extra_values); end

  def add_local_facts(); end

  def add_timestamp(); end

  def initialize(name, values=T.unsafe(nil)); end

  def initialize_from_hash(data); end

  def name(); end

  def name=(name); end

  def sanitize(); end

  def timestamp(); end

  def timestamp=(timestamp); end

  def to_data_hash(); end

  def values(); end

  def values=(values); end
end

module Puppet::Node::Facts::NodeExpirer
  def save(instance, key=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Puppet::Node::Facts::NodeExpirer
  extend ::T::Sig
end

class Puppet::Node::Facts
  extend ::Puppet::Indirector
  extend ::Puppet::Indirector::ClassMethods
  def self.from_data_hash(data); end
end

class Puppet::Node
  extend ::Puppet::Indirector
  extend ::Puppet::Indirector::ClassMethods
  def self.from_data_hash(data); end
end

module Puppet::Pal
  T_ANY_ARRAY = ::T.let(nil, ::T.untyped)
  T_BOOLEAN = ::T.let(nil, ::T.untyped)
  T_GENERIC_TASK_HASH = ::T.let(nil, ::T.untyped)
  T_STRING = ::T.let(nil, ::T.untyped)
  T_STRING_ARRAY = ::T.let(nil, ::T.untyped)
end

class Puppet::Pal::CatalogCompiler
  def compile_additions(); end

  def evaluate_additions(); end

  def validate(); end

  def with_json_encoding(pretty: T.unsafe(nil), exclude_virtual: T.unsafe(nil)); end
end

class Puppet::Pal::CatalogCompiler
end

class Puppet::Pal::Compiler
  def call_function(function_name, *args, &block); end

  def create(data_type, *arguments); end

  def evaluate(ast); end

  def evaluate_file(file); end

  def evaluate_literal(ast); end

  def evaluate_string(puppet_code, source_file=T.unsafe(nil)); end

  def function_signature(function_name); end

  def has_catalog?(); end

  def initialize(internal_compiler); end

  def internal_compiler(); end

  def internal_evaluator(); end

  def list_functions(filter_regex=T.unsafe(nil), error_collector=T.unsafe(nil)); end

  def list_loadable_kind(kind, filter_regex=T.unsafe(nil), error_collector=T.unsafe(nil)); end

  def parse_file(file); end

  def parse_string(code_string, source_file=T.unsafe(nil)); end

  def type(type_string); end
end

class Puppet::Pal::Compiler
end

class Puppet::Pal::FunctionSignature
  def callable_with?(args, callable=T.unsafe(nil)); end

  def callables(); end

  def initialize(function_class); end
end

class Puppet::Pal::FunctionSignature
end

class Puppet::Pal::PlanSignature
  def callable_with?(args_hash); end

  def initialize(plan_function); end

  def params_type(); end
end

class Puppet::Pal::PlanSignature
end

class Puppet::Pal::ScriptCompiler
  def list_plans(filter_regex=T.unsafe(nil), error_collector=T.unsafe(nil)); end

  def list_tasks(filter_regex=T.unsafe(nil), error_collector=T.unsafe(nil)); end

  def plan_signature(plan_name); end

  def task_signature(task_name); end
end

class Puppet::Pal::ScriptCompiler
end

class Puppet::Pal::TaskSignature
  def initialize(task); end

  def runnable_with?(args_hash); end

  def task(); end

  def task_hash(); end
end

class Puppet::Pal::TaskSignature
end

module Puppet::Pal
  extend ::T::Sig
  def self.assert_non_empty_string(s, what, allow_nil=T.unsafe(nil)); end

  def self.assert_type(type, value, what, allow_nil=T.unsafe(nil)); end

  def self.create_internal_compiler(compiler_class_reference, node); end

  def self.evaluate_script_manifest(manifest_file); end

  def self.evaluate_script_string(code_string); end

  def self.in_environment(env_name, modulepath: T.unsafe(nil), pre_modulepath: T.unsafe(nil), post_modulepath: T.unsafe(nil), settings_hash: T.unsafe(nil), env_dir: T.unsafe(nil), envpath: T.unsafe(nil), facts: T.unsafe(nil), variables: T.unsafe(nil), &block); end

  def self.in_tmp_environment(env_name, modulepath: T.unsafe(nil), settings_hash: T.unsafe(nil), facts: T.unsafe(nil), variables: T.unsafe(nil), &block); end

  def self.with_catalog_compiler(configured_by_env: T.unsafe(nil), manifest_file: T.unsafe(nil), code_string: T.unsafe(nil), facts: T.unsafe(nil), variables: T.unsafe(nil), &block); end

  def self.with_script_compiler(configured_by_env: T.unsafe(nil), manifest_file: T.unsafe(nil), code_string: T.unsafe(nil), facts: T.unsafe(nil), variables: T.unsafe(nil), &block); end
end

class Puppet::Parameter
  include ::Puppet::Util
  include ::Puppet::Util::Errors
  include ::Puppet::Util::Logging
  def file(); end

  def format(fmt, *args); end

  def initialize(resource: T.unsafe(nil), value: T.unsafe(nil), should: T.unsafe(nil)); end

  def isnamevar?(); end

  def line(); end

  def log(msg); end

  def metaparam?(); end

  def munge(value); end

  def name(); end

  def noop(); end

  def parent(); end

  def parent=(parent); end

  def path(); end

  def pathbuilder(); end

  def provider(); end

  def remove(); end

  def required?(); end

  def resource(); end

  def resource=(resource); end

  def sensitive(); end

  def sensitive=(sensitive); end

  def tags(); end

  def unmunge(value); end

  def unsafe_munge(value); end

  def unsafe_validate(value); end

  def validate(value); end

  def value(); end

  def value=(value); end

  def version(); end
end

class Puppet::Parameter::Path
  def unsafe_munge(paths); end

  def unsafe_validate(paths); end

  def validate_path(paths); end
end

class Puppet::Parameter::Path
  def self.accept_arrays(bool=T.unsafe(nil)); end

  def self.arrays?(); end
end

class Puppet::Parameter::Value
  def alias(name); end

  def aliases(); end

  def block(); end

  def block=(block); end

  def event(); end

  def event=(value); end

  def initialize(name); end

  def invalidate_refreshes(); end

  def invalidate_refreshes=(invalidate_refreshes); end

  def match?(value); end

  def method(); end

  def method=(method); end

  def name(); end

  def options(); end

  def regex?(); end

  def required_features(); end

  def required_features=(required_features); end
end

class Puppet::Parameter::Value
end

class Puppet::Parameter::ValueCollection
  def aliasvalue(name, other); end

  def doc(); end

  def empty?(); end

  def match?(test_value); end

  def munge(value); end

  def newvalue(name, options=T.unsafe(nil), &block); end

  def newvalues(*names); end

  def regexes(); end

  def validate(value); end

  def value(name); end

  def values(); end
end

class Puppet::Parameter::ValueCollection
end

class Puppet::Parameter
  extend ::Puppet::Util
  extend ::Puppet::Util::Docs
  def self.aliasvalue(name, other); end

  def self.default(); end

  def self.defaultto(value=T.unsafe(nil), &block); end

  def self.format_value_for_display(value); end

  def self.initvars(); end

  def self.isnamevar(); end

  def self.isnamevar?(); end

  def self.isrequired(); end

  def self.metaparam(); end

  def self.metaparam=(metaparam); end

  def self.munge(&block); end

  def self.newvalues(*names); end

  def self.nodefault(); end

  def self.proxymethods(*values); end

  def self.required?(); end

  def self.required_features(); end

  def self.required_features=(*args); end

  def self.sensitive(value=T.unsafe(nil), &block); end

  def self.unmunge(&block); end

  def self.validate(&block); end

  def self.value_collection(); end
end

class Puppet::ParseError
  include ::Puppet::ExternalFileError
end

class Puppet::ParseError
end

class Puppet::ParseErrorWithIssue
  def arguments(); end

  def basic_message(); end

  def environment(); end

  def environment=(environment); end

  def initialize(message, file=T.unsafe(nil), line=T.unsafe(nil), pos=T.unsafe(nil), original=T.unsafe(nil), issue_code=T.unsafe(nil), arguments=T.unsafe(nil)); end

  def issue_code(); end

  def node(); end

  def node=(node); end

  def to_h(); end
end

class Puppet::ParseErrorWithIssue
  def self.from_issue_and_stack(issue, args=T.unsafe(nil)); end
end

module Puppet::Parser
end

class Puppet::Parser::AST
  include ::Puppet::Util::Errors
  def evaluate(scope); end

  def file(); end

  def file=(file); end

  def initialize(file: T.unsafe(nil), line: T.unsafe(nil), pos: T.unsafe(nil)); end

  def line(); end

  def line=(line); end

  def parent(); end

  def parent=(parent); end

  def pos(); end

  def pos=(pos); end

  def safeevaluate(scope); end

  def scope(); end

  def scope=(scope); end
end

Puppet::Parser::AST::AST = Puppet::Parser::AST

class Puppet::Parser::AST::BlockExpression
  def sequence_with(other); end
end

class Puppet::Parser::AST::BlockExpression
end

class Puppet::Parser::AST::Branch
  include ::Enumerable
  def children(); end

  def children=(children); end

  def each(); end

  def initialize(children: T.unsafe(nil), **args); end

  def pin(); end

  def pin=(pin); end
end

class Puppet::Parser::AST::Branch
end

class Puppet::Parser::AST::HostName
  def eql?(value); end

  def initialize(hash); end
end

class Puppet::Parser::AST::HostName
end

class Puppet::Parser::AST::Hostclass
  def code(); end

  def context(); end

  def context=(context); end

  def initialize(name, context=T.unsafe(nil)); end

  def instantiate(modname); end

  def name(); end

  def name=(name); end
end

class Puppet::Parser::AST::Hostclass
end

class Puppet::Parser::AST::Leaf
  def initialize(value: T.unsafe(nil), **options); end

  def match(value); end

  def type(); end

  def type=(type); end

  def value(); end

  def value=(value); end
end

class Puppet::Parser::AST::Leaf
end

class Puppet::Parser::AST::Node
  def context(); end

  def context=(context); end

  def initialize(names, context=T.unsafe(nil)); end

  def instantiate(modname); end

  def names(); end

  def names=(names); end
end

class Puppet::Parser::AST::Node
end

class Puppet::Parser::AST::PopsBridge
end

class Puppet::Parser::AST::PopsBridge::Expression
  def children(); end

  def each(); end

  def initialize(args); end

  def sequence_with(other); end

  def source_text(); end
end

class Puppet::Parser::AST::PopsBridge::Expression
end

class Puppet::Parser::AST::PopsBridge::ExpressionSupportingReturn
end

class Puppet::Parser::AST::PopsBridge::ExpressionSupportingReturn
end

class Puppet::Parser::AST::PopsBridge::Program
  def context(); end

  def each(); end

  def initialize(program_model, context=T.unsafe(nil)); end

  def instantiate(modname); end

  def is_definitions_only?(); end

  def program_model(); end
end

class Puppet::Parser::AST::PopsBridge::Program
end

class Puppet::Parser::AST::PopsBridge
end

class Puppet::Parser::AST::Regex
  def initialize(hash); end
end

class Puppet::Parser::AST::Regex
end

class Puppet::Parser::AST::Resource
  def exported(); end

  def exported=(exported); end

  def initialize(argshash); end

  def instances(); end

  def instances=(instances); end

  def type(); end

  def type=(type); end

  def virtual(); end

  def virtual=(virtual); end
end

class Puppet::Parser::AST::Resource
end

class Puppet::Parser::AST::ResourceInstance
  def initialize(argshash); end

  def parameters(); end

  def parameters=(parameters); end

  def title(); end

  def title=(title); end
end

class Puppet::Parser::AST::ResourceInstance
end

class Puppet::Parser::AST::ResourceParam
  def add(); end

  def add=(add); end

  def initialize(argshash); end

  def param(); end

  def param=(param); end

  def value(); end

  def value=(value); end
end

class Puppet::Parser::AST::ResourceParam
end

class Puppet::Parser::AST::TopLevelConstruct
end

class Puppet::Parser::AST::TopLevelConstruct
end

class Puppet::Parser::AST
end

module Puppet::Parser::AbstractCompiler
  def catalog(); end

  def environment(); end

  def newscope(scope, options); end

  def qualified_variables(); end

  def topscope(); end
end

module Puppet::Parser::AbstractCompiler
  extend ::T::Sig
end

class Puppet::Parser::CatalogCompiler
  def compile_additions(); end

  def evaluate_additions(); end

  def validate(); end
end

class Puppet::Parser::CatalogCompiler
end

class Puppet::Parser::Compiler
  include ::Puppet::Parser::AbstractCompiler
  include ::Puppet::Util
  include ::Puppet::Util::Errors
  include ::Puppet::Pops::Evaluator::Runtime3Support
  def add_catalog_validator(catalog_validators); end

  def add_catalog_validators(); end

  def add_class(name); end

  def add_collection(*args, &block); end

  def add_override(override); end

  def add_relationship(*args, &block); end

  def add_resource(scope, resource); end

  def assert_app_in_site(scope, resource); end

  def classlist(*args, &block); end

  def code_id(); end

  def code_id=(code_id); end

  def collections(); end

  def compile(); end

  def context_overrides(); end

  def delete_collection(*args, &block); end

  def evaluate_applications(); end

  def evaluate_classes(classes, scope, lazy_evaluate=T.unsafe(nil)); end

  def evaluate_generators(); end

  def evaluate_node_classes(); end

  def evaluate_relationships(); end

  def evaluate_site(); end

  def facts(); end

  def findresource(*args, &block); end

  def finish(); end

  def initialize(node, code_id: T.unsafe(nil)); end

  def loaders(); end

  def newscope(parent, options=T.unsafe(nil)); end

  def node(); end

  def on_empty_site(); end

  def prune_catalog(); end

  def prune_node_catalog(); end

  def relationships(); end

  def resource_overrides(resource); end

  def resources(); end

  def validate_catalog(validation_stage); end

  def with_context_overrides(description=T.unsafe(nil), &block); end
  SETTINGS = ::T.let(nil, ::T.untyped)
end

class Puppet::Parser::Compiler::CatalogValidationError
  include ::Puppet::ExternalFileError
end

class Puppet::Parser::Compiler::CatalogValidationError
end

class Puppet::Parser::Compiler::CatalogValidator
  def catalog(); end

  def initialize(catalog); end

  def validate(); end
  FINAL = ::T.let(nil, ::T.untyped)
  PRE_FINISH = ::T.let(nil, ::T.untyped)
end

class Puppet::Parser::Compiler::CatalogValidator::EnvironmentRelationshipValidator
end

class Puppet::Parser::Compiler::CatalogValidator::EnvironmentRelationshipValidator
end

class Puppet::Parser::Compiler::CatalogValidator::RelationshipValidator
  CAPABILITY_ACCEPTED_METAPARAMS = ::T.let(nil, ::T.untyped)
end

class Puppet::Parser::Compiler::CatalogValidator::RelationshipValidator
end

class Puppet::Parser::Compiler::CatalogValidator::SiteValidator
end

class Puppet::Parser::Compiler::CatalogValidator::SiteValidator
end

class Puppet::Parser::Compiler::CatalogValidator
  def self.validation_stage?(stage); end
end

class Puppet::Parser::Compiler
  extend ::Forwardable
  def self.compile(node, code_id=T.unsafe(nil)); end
end

class Puppet::Parser::EnvironmentCompiler
  def add_function_override(func_name, override); end

  def add_function_overrides(); end

  def evaluate_classes(titles, scope, lazy); end

  def initialize(node, options=T.unsafe(nil)); end

  def prune_env_catalog(); end

  def remove_function_overrides(); end
end

class Puppet::Parser::EnvironmentCompiler
  def self.compile(env, code_id=T.unsafe(nil)); end
end

module Puppet::Parser::Files
end

module Puppet::Parser::Files
  extend ::T::Sig
  def self.find_file(file, environment); end

  def self.find_in_module(reference, environment); end

  def self.find_manifests_in_modules(pattern, environment); end

  def self.find_template(template, environment); end

  def self.split_file_path(path); end
end

module Puppet::Parser::Functions
end

class Puppet::Parser::Functions::AnonymousModuleAdapter
  def module(); end

  def module=(_); end
end

class Puppet::Parser::Functions::AnonymousModuleAdapter
end

class Puppet::Parser::Functions::AutoloaderDelegate
  def delegatee(); end

  def load(name, env=T.unsafe(nil)); end

  def loadall(env=T.unsafe(nil)); end

  def loaded?(name); end
end

class Puppet::Parser::Functions::AutoloaderDelegate
end

Puppet::Parser::Functions::Environment = Puppet::Node::Environment

class Puppet::Parser::Functions::Error
end

class Puppet::Parser::Functions::Error
  def self.is4x(name); end
end

module Puppet::Parser::Functions
  extend ::Puppet::Util
  extend ::T::Sig
  def self.arity(name, environment=T.unsafe(nil)); end

  def self.autoloader(); end

  def self.environment_module(env); end

  def self.function(name, environment=T.unsafe(nil)); end

  def self.functiondocs(environment=T.unsafe(nil)); end

  def self.newfunction(name, options=T.unsafe(nil), &block); end

  def self.reset(); end

  def self.rvalue?(name, environment=T.unsafe(nil)); end
end

class Puppet::Parser::ParserFactory
end

class Puppet::Parser::ParserFactory
  def self.code_merger(); end

  def self.evaluating_parser(); end

  def self.parser(); end
end

class Puppet::Parser::Relationship
  def arrayify(resources, left); end

  def evaluate(catalog); end

  def initialize(source, target, type); end

  def mk_relationship(source, target, catalog); end

  def param_name(); end

  def source(); end

  def source=(source); end

  def target(); end

  def target=(target); end

  def type(); end

  def type=(type); end
  PARAM_MAP = ::T.let(nil, ::T.untyped)
end

class Puppet::Parser::Relationship
end

class Puppet::Parser::Resource
  include ::Puppet::Util
  include ::Puppet::Util::Errors
  include ::Puppet::Util::Logging
  def []=(param, value=T.unsafe(nil)); end

  def add_edge_to_stage(); end

  def add_parameters_from_consume(); end

  def collector_id(); end

  def collector_id=(collector_id); end

  def eachparam(); end

  def evaluate(); end

  def evaluated(); end

  def evaluated=(evaluated); end

  def evaluated?(); end

  def exported=(value); end

  def finish(do_validate=T.unsafe(nil)); end

  def finish_evaluation(); end

  def finished?(); end

  def initialize(type, title, attributes, with_defaults=T.unsafe(nil)); end

  def is_unevaluated_consumer?(); end

  def isomorphic?(); end

  def mark_unevaluated_consumer(); end

  def merge(resource); end

  def offset(); end

  def override(); end

  def override=(override); end

  def override?(); end

  def path(); end

  def scope(); end

  def scope=(scope); end

  def set_parameter(param, value=T.unsafe(nil)); end

  def source(); end

  def source=(source); end

  def translated(); end

  def translated=(translated); end

  def translated?(); end
end

class Puppet::Parser::Resource::Param
  include ::Puppet::Util
  include ::Puppet::Util::Errors
  def add(); end

  def add=(add); end

  def file(); end

  def file=(file); end

  def initialize(name: T.unsafe(nil), value: T.unsafe(nil), source: T.unsafe(nil), line: T.unsafe(nil), file: T.unsafe(nil), add: T.unsafe(nil)); end

  def line(); end

  def line=(line); end

  def line_to_i(); end

  def name(); end

  def name=(name); end

  def source(); end

  def source=(source); end

  def value(); end

  def value=(value); end
end

class Puppet::Parser::Resource::Param
end

class Puppet::Parser::Resource
  def self.relationship_parameter?(name); end
end

class Puppet::Parser::Scope
  include ::Puppet::Util::Errors
  def [](varname, options=T.unsafe(nil)); end

  def []=(varname, value, _=T.unsafe(nil)); end

  def alert(args); end

  def bound?(name); end

  def call_function(func_name, args, &block); end

  def catalog(); end

  def class_scope(klass); end

  def class_set(name, scope); end

  def compiler(); end

  def crit(args); end

  def debug(args); end

  def defaults(); end

  def define_settings(type, params); end

  def effective_symtable(use_ephemeral); end

  def emerg(args); end

  def enclosing_scope(); end

  def environment(); end

  def ephemeral_from(match, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def ephemeral_level(); end

  def err(args); end

  def exist?(name); end

  def find_builtin_resource_type(type); end

  def find_defined_resource_type(type); end

  def find_definition(name); end

  def find_global_scope(); end

  def find_hostclass(name); end

  def find_resource_type(type); end

  def findresource(type, title=T.unsafe(nil)); end

  def get_local_variable(name); end

  def handle_not_found(class_name, variable_name, position, reason=T.unsafe(nil)); end

  def has_local_variable?(name); end

  def include?(name); end

  def info(args); end

  def inherited_scope(); end

  def initialize(compiler, source: T.unsafe(nil), resource: T.unsafe(nil)); end

  def is_classscope?(); end

  def is_default?(type, key, value); end

  def is_nodescope?(); end

  def is_topscope?(); end

  def lookup_qualified_variable(fqn, options); end

  def lookupdefaults(type); end

  def lookuptype(name); end

  def lookupvar(name, options=T.unsafe(nil)); end

  def merge_settings(env_name, set_in_this_scope=T.unsafe(nil)); end

  def method_missing(method, *args, &block); end

  def new_ephemeral(local_scope=T.unsafe(nil)); end

  def new_match_scope(match_data); end

  def newscope(options=T.unsafe(nil)); end

  def notice(args); end

  def parent(); end

  def parent=(parent); end

  def parent_module_name(); end

  def pop_ephemerals(level); end

  def push_ephemerals(ephemeral_scopes); end

  def resolve_type_and_titles(type, titles); end

  def resource(); end

  def resource=(resource); end

  def set_facts(hash); end

  def set_match_data(match_data); end

  def set_server_facts(hash); end

  def set_trusted(hash); end

  def setvar(name, value, options=T.unsafe(nil)); end

  def source(); end

  def source=(source); end

  def to_hash(recursive=T.unsafe(nil)); end

  def transform_and_assert_classnames(names); end

  def undef_as(x, v); end

  def variable_not_found(name, reason=T.unsafe(nil)); end

  def warning(args); end

  def with_global_scope(&block); end

  def with_guarded_scope(); end

  def with_local_scope(scope_variables); end

  def with_parameter_scope(callee_name, param_names); end

  def without_ephemeral_scopes(); end
  BUILT_IN_VARS = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  RESERVED_VARIABLE_NAMES = ::T.let(nil, ::T.untyped)
  TYPENAME_CLASS = ::T.let(nil, ::T.untyped)
  TYPENAME_NODE = ::T.let(nil, ::T.untyped)
  UNDEFINED_VARIABLES_KIND = ::T.let(nil, ::T.untyped)
  VARNAME_FACTS = ::T.let(nil, ::T.untyped)
  VARNAME_SERVER_FACTS = ::T.let(nil, ::T.untyped)
  VARNAME_TRUSTED = ::T.let(nil, ::T.untyped)
end

class Puppet::Parser::Scope::Ephemeral
  def [](name); end

  def add_entries_to(target=T.unsafe(nil)); end

  def bound?(name); end

  def include?(name); end

  def initialize(parent=T.unsafe(nil)); end

  def is_local_scope?(); end

  def parent(); end
end

class Puppet::Parser::Scope::Ephemeral
end

class Puppet::Parser::Scope::LocalScope
  def []=(name, value); end

  def delete(name); end
end

class Puppet::Parser::Scope::LocalScope
end

class Puppet::Parser::Scope::MatchScope
  def []=(name, value); end

  def delete(name); end

  def initialize(parent=T.unsafe(nil), match_data=T.unsafe(nil)); end

  def match_data(); end

  def match_data=(match_data); end
end

class Puppet::Parser::Scope::MatchScope
end

class Puppet::Parser::Scope::ParameterScope
  def []=(name, value); end

  def as_read_only(); end

  def evaluate(name, expression, scope, evaluator); end

  def evaluate3x(name, expression, scope); end

  def initialize(parent, callee_name, param_names); end

  def to_hash(); end
end

class Puppet::Parser::Scope::ParameterScope::Access
  def assigned?(); end

  def value(); end

  def value=(value); end
end

class Puppet::Parser::Scope::ParameterScope::Access
end

class Puppet::Parser::Scope::ParameterScope
end

Puppet::Parser::Scope::UNCAUGHT_THROW_EXCEPTION = UncaughtThrowError

class Puppet::Parser::Scope
  extend ::Forwardable
  def self.number?(value); end

  def self.true?(value); end
end

class Puppet::Parser::ScriptCompiler
  include ::Puppet::Parser::AbstractCompiler
  def compile(); end

  def context_overrides(); end

  def initialize(environment, node_name, for_agent=T.unsafe(nil)); end

  def loaders(); end

  def newscope(parent, options=T.unsafe(nil)); end

  def node_name(); end

  def with_context_overrides(description=T.unsafe(nil), &block); end
end

class Puppet::Parser::ScriptCompiler
end

class Puppet::Parser::TemplateWrapper
  include ::Puppet::Util
  def alert(args); end

  def all_tags(); end

  def classes(); end

  def crit(args); end

  def debug(args); end

  def emerg(args); end

  def err(args); end

  def file(); end

  def file=(filename); end

  def has_variable?(name); end

  def info(args); end

  def initialize(scope); end

  def notice(args); end

  def result(string=T.unsafe(nil)); end

  def scope(); end

  def tags(); end

  def warning(args); end
end

class Puppet::Parser::TemplateWrapper
end

class Puppet::Parser::TypeLoader
  def environment(); end

  def environment=(env); end

  def import(pattern, dir); end

  def import_all(); end

  def initialize(env); end

  def known_resource_types(*args, &block); end

  def parse_file(file); end

  def try_load_fqname(type, fqname); end
end

class Puppet::Parser::TypeLoader::TypeLoaderError
end

class Puppet::Parser::TypeLoader::TypeLoaderError
end

class Puppet::Parser::TypeLoader
  extend ::Forwardable
end

module Puppet::Parser
  extend ::T::Sig
end

module Puppet::Plugins
end

module Puppet::Plugins::Configuration
end

module Puppet::Plugins::Configuration
  extend ::T::Sig
  def self.load_plugins(); end
end

module Puppet::Plugins::SyntaxCheckers
  SYNTAX_CHECKERS_KEY = ::T.let(nil, ::T.untyped)
end

class Puppet::Plugins::SyntaxCheckers::SyntaxChecker
  def check(text, syntax_identifier, acceptor, location_info); end
end

class Puppet::Plugins::SyntaxCheckers::SyntaxChecker
end

module Puppet::Plugins::SyntaxCheckers
  extend ::T::Sig
end

module Puppet::Plugins
  extend ::T::Sig
end

module Puppet::Pops
  DOUBLE_COLON = ::T.let(nil, ::T.untyped)
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  MAX_INTEGER = ::T.let(nil, ::T.untyped)
  MIN_INTEGER = ::T.let(nil, ::T.untyped)
  USCORE = ::T.let(nil, ::T.untyped)
end

module Puppet::Pops::Adaptable
end

class Puppet::Pops::Adaptable::Adapter
end

class Puppet::Pops::Adaptable::Adapter
  def self.adapt(o, &block); end

  def self.adapt_new(o, &block); end

  def self.associate_adapter(adapter, o); end

  def self.clear(o); end

  def self.create_adapter(o); end

  def self.get(o); end

  def self.instance_var_name(name); end

  def self.self_attr_name(); end

  def self.type_name(); end
end

module Puppet::Pops::Adaptable
  extend ::T::Sig
end

module Puppet::Pops::Adapters
end

class Puppet::Pops::Adapters::DocumentationAdapter
  def documentation(); end

  def documentation=(documentation); end
end

class Puppet::Pops::Adapters::DocumentationAdapter
end

class Puppet::Pops::Adapters::EmptyAlternativeAdapter
  def empty_alternative(); end

  def empty_alternative=(empty_alternative); end
end

class Puppet::Pops::Adapters::EmptyAlternativeAdapter
end

class Puppet::Pops::Adapters::LoaderAdapter
  def loader_name(); end

  def loader_name=(loader_name); end
end

class Puppet::Pops::Adapters::LoaderAdapter::PathsAndNameCacheAdapter
  def cache(); end

  def cache=(cache); end

  def paths(); end

  def paths=(paths); end
end

class Puppet::Pops::Adapters::LoaderAdapter::PathsAndNameCacheAdapter
end

class Puppet::Pops::Adapters::LoaderAdapter
  def self.find_module_for_dir(environment, paths, dir); end

  def self.loader_for_model_object(model, file=T.unsafe(nil), default_loader=T.unsafe(nil)); end

  def self.loader_name_by_source(environment, instance, file); end
end

class Puppet::Pops::Adapters::ObjectIdCacheAdapter
  def cache(); end

  def cache=(cache); end

  def retrieve(o); end
end

class Puppet::Pops::Adapters::ObjectIdCacheAdapter
end

class Puppet::Pops::Adapters::SourcePosAdapter
  def extract_text(); end

  def file(); end

  def initialize(object); end

  def line(); end

  def pos(); end
end

class Puppet::Pops::Adapters::SourcePosAdapter
  def self.adapt(object); end
end

module Puppet::Pops::Adapters
  extend ::T::Sig
end

class Puppet::Pops::DeepMergeStrategy
  def deep_clone(value); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::DeepMergeStrategy
end

class Puppet::Pops::DefaultMergeStrategy
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::DefaultMergeStrategy
end

module Puppet::Pops::Evaluator
end

class Puppet::Pops::Evaluator::AccessOperator
  include ::Puppet::Pops::Evaluator::Runtime3Support
  def access(o, scope, *keys); end

  def access_Array(o, scope, keys); end

  def access_Binary(o, scope, keys); end

  def access_Hash(o, scope, keys); end

  def access_Object(o, scope, keys); end

  def access_PArrayType(o, scope, keys); end

  def access_PBooleanType(o, scope, keys); end

  def access_PCallableType(o, scope, keys); end

  def access_PClassType(o, scope, keys); end

  def access_PCollectionType(o, scope, keys); end

  def access_PEnumType(o, scope, keys); end

  def access_PFloatType(o, scope, keys); end

  def access_PHashType(o, scope, keys); end

  def access_PInitType(o, scope, keys); end

  def access_PIntegerType(o, scope, keys); end

  def access_PIterableType(o, scope, keys); end

  def access_PIteratorType(o, scope, keys); end

  def access_PNotUndefType(o, scope, keys); end

  def access_PObjectType(o, scope, keys); end

  def access_POptionalType(o, scope, keys); end

  def access_PPatternType(o, scope, keys); end

  def access_PRegexpType(o, scope, keys); end

  def access_PResourceType(o, scope, keys); end

  def access_PRuntimeType(o, scope, keys); end

  def access_PSemVerType(o, scope, keys); end

  def access_PSensitiveType(o, scope, keys); end

  def access_PStringType(o, scope, keys); end

  def access_PStructType(o, scope, keys); end

  def access_PTimespanType(o, scope, keys); end

  def access_PTimestampType(o, scope, keys); end

  def access_PTupleType(o, scope, keys); end

  def access_PTypeReferenceType(o, scope, keys); end

  def access_PTypeSetType(o, scope, keys); end

  def access_PTypeType(o, scope, keys); end

  def access_PURIType(o, scope, keys); end

  def access_PVariantType(o, scope, keys); end

  def access_Resource(o, scope, keys); end

  def access_String(o, scope, keys); end

  def assert_keys(keys, o, min, max, *allowed_classes); end

  def bad_access_key_type(lhs, key_index, actual, *expected_classes); end

  def bad_key_type_name(actual); end

  def bad_string_access_key_type(lhs, key_index, actual); end

  def bad_type_specialization_key_type(type, key_index, actual, *expected_classes); end

  def collection_size_t(start_index, *keys); end

  def initialize(access_expression); end

  def semantic(); end
  NS = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Evaluator::AccessOperator
end

class Puppet::Pops::Evaluator::CallableSignature
  def args_range(); end

  def argument_mismatch_handler?(); end

  def block_name(); end

  def block_range(); end

  def block_type(); end

  def infinity?(x); end

  def last_captures_rest?(); end

  def parameter_names(); end

  def type(); end
end

class Puppet::Pops::Evaluator::CallableSignature
end

class Puppet::Pops::Evaluator::Closure
  def call(*args); end

  def call_by_name(args_hash, enforce_parameters); end

  def call_by_name_with_scope(scope, args_hash, enforce_parameters); end

  def closure_name(); end

  def enclosing_scope(); end

  def evaluator(); end

  def initialize(evaluator, model); end

  def invoke(instance, calling_scope, args, &block); end

  def model(); end

  def parameter_count(); end

  def parameters(); end

  def params_struct(); end

  def return_type(); end
  ANY_NUMBER_RANGE = ::T.let(nil, ::T.untyped)
  CLOSURE_NAME = ::T.let(nil, ::T.untyped)
  OPTIONAL_SINGLE_RANGE = ::T.let(nil, ::T.untyped)
  REQUIRED_SINGLE_RANGE = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Evaluator::Closure::Dynamic
  def initialize(evaluator, model, scope); end
end

class Puppet::Pops::Evaluator::Closure::Dynamic
end

class Puppet::Pops::Evaluator::Closure::Named
  def initialize(name, evaluator, model); end
end

class Puppet::Pops::Evaluator::Closure::Named
end

class Puppet::Pops::Evaluator::Closure
end

class Puppet::Pops::Evaluator::CollectorTransformer
  def match(o, scope); end

  def match_AccessExpression(o, scope); end

  def match_AndExpression(o, scope); end

  def match_ComparisonExpression(o, scope); end

  def match_ConcatenatedString(o, scope); end

  def match_LiteralBoolean(o, scope); end

  def match_LiteralNumber(o, scope); end

  def match_LiteralString(o, scope); end

  def match_LiteralUndef(o, scope); end

  def match_Object(o, scope); end

  def match_OrExpression(o, scope); end

  def match_ParenthesizedExpression(o, scope); end

  def match_QualifiedName(o, scope); end

  def match_VariableExpression(o, scope); end

  def match_unless_nop(query, scope); end

  def query(o, scope); end

  def query_AccessExpression(o, scope); end

  def query_AndExpression(o, scope); end

  def query_ComparisonExpression(o, scope); end

  def query_ConcatenatedString(o, scope); end

  def query_LiteralBoolean(o, scope); end

  def query_LiteralNumber(o, scope); end

  def query_LiteralString(o, scope); end

  def query_LiteralUndef(o, scope); end

  def query_Object(o, scope); end

  def query_OrExpression(o, scope); end

  def query_ParenthesizedExpression(o, scope); end

  def query_QualifiedName(o, scope); end

  def query_VariableExpression(o, scope); end

  def query_unless_nop(query, scope); end

  def transform(o, scope); end
end

class Puppet::Pops::Evaluator::CollectorTransformer
end

module Puppet::Pops::Evaluator::Collectors
end

class Puppet::Pops::Evaluator::Collectors::AbstractCollector
  def collect(); end

  def collected(); end

  def evaluate(); end

  def initialize(scope, overrides=T.unsafe(nil)); end

  def overrides(); end

  def scope(); end

  def unresolved_resources(); end
  EMPTY_RESOURCES = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Evaluator::Collectors::AbstractCollector
end

class Puppet::Pops::Evaluator::Collectors::CatalogCollector
  def initialize(scope, type, query, overrides=T.unsafe(nil)); end
end

class Puppet::Pops::Evaluator::Collectors::CatalogCollector
end

class Puppet::Pops::Evaluator::Collectors::ExportedCollector
  def initialize(scope, type, equery, cquery, overrides=T.unsafe(nil)); end
end

class Puppet::Pops::Evaluator::Collectors::ExportedCollector
end

class Puppet::Pops::Evaluator::Collectors::FixedSetCollector
  def initialize(scope, resources); end
end

class Puppet::Pops::Evaluator::Collectors::FixedSetCollector
end

module Puppet::Pops::Evaluator::Collectors
  extend ::T::Sig
end

class Puppet::Pops::Evaluator::CompareOperator
  include ::Puppet::Pops::Utils
  include ::Puppet::Pops::Evaluator::Runtime3Support
  def cmp_Numeric(a, b); end

  def cmp_Object(a, b); end

  def cmp_String(a, b); end

  def cmp_Symbol(a, b); end

  def cmp_Timespan(a, b); end

  def cmp_Timestamp(a, b); end

  def cmp_Version(a, b); end

  def compare(a, b); end

  def equals(a, b); end

  def equals_Array(a, b); end

  def equals_Hash(a, b); end

  def equals_NilClass(a, b); end

  def equals_Numeric(a, b); end

  def equals_Object(a, b); end

  def equals_String(a, b); end

  def equals_Symbol(a, b); end

  def include?(a, b, scope); end

  def include_Array(a, b, scope); end

  def include_Binary(a, b, scope); end

  def include_Hash(a, b, scope); end

  def include_Object(a, b, scope); end

  def include_String(a, b, scope); end

  def include_VersionRange(a, b, scope); end

  def match(a, b, scope=T.unsafe(nil)); end

  def match_Array(array, left, scope); end

  def match_Hash(hash, left, scope); end

  def match_Object(pattern, a, scope); end

  def match_PAnyType(any_type, left, scope); end

  def match_Regexp(regexp, left, scope); end

  def match_Symbol(symbol, left, scope); end

  def match_Version(version, left, scope); end

  def match_VersionRange(range, left, scope); end
end

class Puppet::Pops::Evaluator::CompareOperator
end

class Puppet::Pops::Evaluator::DeferredResolver
  def initialize(compiler); end

  def resolve(x); end

  def resolve_future(f); end

  def resolve_futures(catalog); end

  def set_facts_variable(facts); end
  DIG = ::T.let(nil, ::T.untyped)
  DOLLAR = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Evaluator::DeferredResolver
  def self.resolve(value, compiler); end

  def self.resolve_and_replace(facts, catalog); end
end

class Puppet::Pops::Evaluator::EppEvaluator
end

class Puppet::Pops::Evaluator::EppEvaluator
  def self.epp(scope, file, env_name, template_args=T.unsafe(nil)); end

  def self.inline_epp(scope, epp_source, template_args=T.unsafe(nil)); end
end

class Puppet::Pops::Evaluator::EvaluatorImpl
  include ::Puppet::Pops::Utils
  include ::Puppet::Pops::Evaluator::Runtime3Support
  include ::Puppet::Pops::Evaluator::ExternalSyntaxSupport
  def assign(target, value, o, scope); end

  def assign_Array(lvalues, values, o, scope); end

  def assign_Numeric(n, value, o, scope); end

  def assign_Object(name, value, o, scope); end

  def assign_String(name, value, o, scope); end

  def calculate(left, right, bin_expr, scope); end

  def concatenate(x, y); end

  def delete(x, y); end

  def eval_AccessExpression(o, scope); end

  def eval_AndExpression(o, scope); end

  def eval_ApplyExpression(o, scope); end

  def eval_ArithmeticExpression(o, scope); end

  def eval_AssignmentExpression(o, scope); end

  def eval_AttributeOperation(o, scope); end

  def eval_AttributesOperation(o, scope); end

  def eval_BinaryExpression(o, scope); end

  def eval_BlockExpression(o, scope); end

  def eval_CallMethodExpression(o, scope); end

  def eval_CallNamedFunctionExpression(o, scope); end

  def eval_CaseExpression(o, scope); end

  def eval_CollectExpression(o, scope); end

  def eval_ComparisonExpression(o, scope); end

  def eval_ConcatenatedString(o, scope); end

  def eval_Definition(o, scope); end

  def eval_EppExpression(o, scope); end

  def eval_Factory(o, scope); end

  def eval_HeredocExpression(o, scope); end

  def eval_IfExpression(o, scope); end

  def eval_InExpression(o, scope); end

  def eval_LiteralDefault(o, scope); end

  def eval_LiteralHash(o, scope); end

  def eval_LiteralList(o, scope); end

  def eval_LiteralUndef(o, scope); end

  def eval_LiteralValue(o, scope); end

  def eval_MatchExpression(o, scope); end

  def eval_NilClass(o, scope); end

  def eval_Nop(o, scope); end

  def eval_NotExpression(o, scope); end

  def eval_Object(o, scope); end

  def eval_OrExpression(o, scope); end

  def eval_ParenthesizedExpression(o, scope); end

  def eval_Program(o, scope); end

  def eval_QualifiedReference(o, scope); end

  def eval_RelationshipExpression(o, scope); end

  def eval_RenderExpression(o, scope); end

  def eval_RenderStringExpression(o, scope); end

  def eval_ReservedWord(o, scope); end

  def eval_ResourceDefaultsExpression(o, scope); end

  def eval_ResourceExpression(o, scope); end

  def eval_ResourceOverrideExpression(o, scope); end

  def eval_SelectorExpression(o, scope); end

  def eval_SubLocatedExpression(o, scope); end

  def eval_TextExpression(o, scope); end

  def eval_UnaryMinusExpression(o, scope); end

  def eval_UnfoldExpression(o, scope); end

  def eval_UnlessExpression(o, scope); end

  def eval_VariableExpression(o, scope); end

  def evaluate(target, scope); end

  def evaluate_block_with_bindings(scope, variable_bindings, block_expr); end

  def is_match?(left, right, o, option_expr, scope); end

  def lvalue(o, scope); end

  def lvalue_LiteralList(o, scope); end

  def lvalue_Object(o, scope); end

  def lvalue_VariableExpression(o, scope); end

  def match?(left, right); end

  def string(o, scope); end

  def string_Array(o, scope); end

  def string_Hash(o, scope); end

  def string_Object(o, scope); end

  def string_PAnyType(o, scope); end

  def string_Regexp(o, scope); end

  def string_Symbol(o, scope); end

  def type_calculator(); end
  ARITHMETIC_OPERATORS = ::T.let(nil, ::T.untyped)
  COLLECTION_OPERATORS = ::T.let(nil, ::T.untyped)
  COMMA_SEPARATOR = ::T.let(nil, ::T.untyped)
end

Puppet::Pops::Evaluator::EvaluatorImpl::Issues = Puppet::Pops::Issues

class Puppet::Pops::Evaluator::EvaluatorImpl
end

module Puppet::Pops::Evaluator::ExternalSyntaxSupport
  def assert_external_syntax(_, result, syntax, reference_expr); end

  def checker_for_syntax(_, syntax); end

  def lookup_keys_for_syntax(syntax); end
end

module Puppet::Pops::Evaluator::ExternalSyntaxSupport
  extend ::T::Sig
end

class Puppet::Pops::Evaluator::Jumper
  def file(); end

  def initialize(value, file, line); end

  def line(); end

  def value(); end
end

class Puppet::Pops::Evaluator::Jumper
end

class Puppet::Pops::Evaluator::LiteralEvaluator
  def literal(ast); end

  def literal_ConcatenatedString(o); end

  def literal_Factory(o); end

  def literal_LiteralBoolean(o); end

  def literal_LiteralDefault(o); end

  def literal_LiteralHash(o); end

  def literal_LiteralList(o); end

  def literal_LiteralNumber(o); end

  def literal_LiteralRegularExpression(o); end

  def literal_LiteralString(o); end

  def literal_LiteralUndef(o); end

  def literal_Object(o); end

  def literal_Program(o); end

  def literal_QualifiedName(o); end
  COMMA_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Evaluator::LiteralEvaluator
end

class Puppet::Pops::Evaluator::Next
end

class Puppet::Pops::Evaluator::Next
end

class Puppet::Pops::Evaluator::PuppetProc
  def closure(); end
end

class Puppet::Pops::Evaluator::PuppetProc
  def self.new(closure, &block); end
end

class Puppet::Pops::Evaluator::PuppetStopIteration
  def file(); end

  def initialize(file, line, pos=T.unsafe(nil)); end

  def line(); end

  def pos(); end
end

class Puppet::Pops::Evaluator::PuppetStopIteration
end

class Puppet::Pops::Evaluator::RelationshipOperator
  include ::Puppet::Pops::Evaluator::Runtime3Support
  def assert_catalog_type(o, scope); end

  def evaluate(left_right_evaluated, relationship_expression, scope); end

  def reverse_operator?(o); end

  def transform(o, scope); end

  def transform_AbstractCollector(o, scope); end

  def transform_Array(o, scope); end

  def transform_Collector(o, scope); end

  def transform_Object(o, scope); end

  def transform_PAnyType(o, scope); end

  def transform_QualifiedName(o, scope); end

  def transform_Resource(o, scope); end

  def transform_String(o, scope); end
  RELATIONSHIP_OPERATORS = ::T.let(nil, ::T.untyped)
  RELATION_TYPE = ::T.let(nil, ::T.untyped)
  REVERSE_OPERATORS = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Evaluator::RelationshipOperator::IllegalRelationshipOperandError
  def initialize(operand); end

  def operand(); end
end

class Puppet::Pops::Evaluator::RelationshipOperator::IllegalRelationshipOperandError
end

class Puppet::Pops::Evaluator::RelationshipOperator::NotCatalogTypeError
  def initialize(type); end

  def type(); end
end

class Puppet::Pops::Evaluator::RelationshipOperator::NotCatalogTypeError
end

class Puppet::Pops::Evaluator::RelationshipOperator
end

class Puppet::Pops::Evaluator::Return
end

class Puppet::Pops::Evaluator::Return
end

class Puppet::Pops::Evaluator::Runtime3Converter
  def catalog_type_to_split_type_title(catalog_type); end

  def convert(o, scope, undef_value); end

  def convert_Array(o, scope, undef_value); end

  def convert_BigDecimal(o, scope, undef_value); end

  def convert_Hash(o, scope, undef_value); end

  def convert_Integer(o, scope, undef_value); end

  def convert_Iterator(o, scope, undef_value); end

  def convert_NilClass(o, scope, undef_value); end

  def convert_Object(o, scope, undef_value); end

  def convert_PAnyType(o, scope, undef_value); end

  def convert_PCatalogEntryType(o, scope, undef_value); end

  def convert_String(o, scope, undef_value); end

  def convert_Symbol(o, scope, undef_value); end

  def initialize(inner=T.unsafe(nil)); end

  def map_args(args, scope, undef_value); end
  MAX_INTEGER = ::T.let(nil, ::T.untyped)
  MIN_INTEGER = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Evaluator::Runtime3Converter
  def self.convert(o, scope, undef_value); end

  def self.instance(); end

  def self.map_args(args, scope, undef_value); end
end

class Puppet::Pops::Evaluator::Runtime3FunctionArgumentConverter
  def convert_Binary(o, scope, undef_value); end

  def convert_Regexp(o, scope, undef_value); end

  def convert_Timespan(o, scope, undef_value); end

  def convert_Timestamp(o, scope, undef_value); end

  def convert_Version(o, scope, undef_value); end

  def convert_VersionRange(o, scope, undef_value); end
end

class Puppet::Pops::Evaluator::Runtime3FunctionArgumentConverter
  def self.convert_return(val3x); end
end

module Puppet::Pops::Evaluator::Runtime3ResourceSupport
  CLASS_STRING = ::T.let(nil, ::T.untyped)
end

module Puppet::Pops::Evaluator::Runtime3ResourceSupport
  extend ::T::Sig
  def self.create_resources(file, line, scope, virtual, exported, type_name, resource_titles, evaluated_parameters); end

  def self.find_hostclass(scope, class_name); end

  def self.find_main_class(scope); end

  def self.find_resource_type(scope, type_name); end

  def self.find_resource_type_or_class(scope, name); end

  def self.resource_to_ptype(resource); end
end

module Puppet::Pops::Evaluator::Runtime3Support
  def add_relationship(source, target, relationship_type, scope); end

  def call_function(name, args, o, scope, &block); end

  def capitalize_qualified_name(name); end

  def coerce_numeric(v, o, scope); end

  def convert(value, scope, undef_value); end

  def create_local_scope_from(hash, scope); end

  def create_match_scope_from(scope); end

  def create_resource_defaults(o, scope, type_name, evaluated_parameters); end

  def create_resource_overrides(o, scope, evaluated_resources, evaluated_parameters); end

  def create_resource_parameter(o, scope, name, value, operator); end

  def create_resources(o, scope, virtual, exported, type_name, resource_titles, evaluated_parameters); end

  def diagnostic_producer(); end

  def external_call_function(name, args, scope, &block); end

  def extract_file_line(o); end

  def fail(issue, semantic, options=T.unsafe(nil), except=T.unsafe(nil)); end

  def find_resource(scope, type_name, title); end

  def get_resource_parameter_value(scope, resource, parameter_name); end

  def get_scope_nesting_level(scope); end

  def get_variable_value(name, o, scope); end

  def is_boolean?(x); end

  def is_parameter_of_resource?(scope, resource, name); end

  def is_true?(value, o); end

  def optionally_fail(issue, semantic, options=T.unsafe(nil), except=T.unsafe(nil)); end

  def resource_to_ptype(resource); end

  def runtime_issue(issue, options=T.unsafe(nil)); end

  def set_match_data(match_data, scope); end

  def set_scope_nesting_level(scope, level); end

  def set_variable(name, value, o, scope); end

  def variable_bound?(name, scope); end

  def variable_exists?(name, scope); end
  NAME_SPACE_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module Puppet::Pops::Evaluator::Runtime3Support
  extend ::T::Sig
end

module Puppet::Pops::Evaluator
  extend ::T::Sig
end

class Puppet::Pops::FirstFoundStrategy
  def lookup(lookup_variants, _); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::FirstFoundStrategy
end

module Puppet::Pops::Functions
end

class Puppet::Pops::Functions::Dispatch
  def initialize(type, method_name, param_names, last_captures=T.unsafe(nil), block_name=T.unsafe(nil), injections=T.unsafe(nil), weaving=T.unsafe(nil), argument_mismatch_handler=T.unsafe(nil)); end

  def injections(); end

  def invoke(instance, calling_scope, args, &block); end

  def param_names(); end

  def weave(scope, args); end

  def weaving(); end
end

class Puppet::Pops::Functions::Dispatch
end

class Puppet::Pops::Functions::Dispatcher
  def add(a_dispatch); end

  def dispatch(instance, calling_scope, args, &block); end

  def dispatchers(); end

  def empty?(); end

  def signatures(); end

  def to_type(); end
end

class Puppet::Pops::Functions::Dispatcher
end

class Puppet::Pops::Functions::Function
  def call(scope, *args, &block); end

  def call_function(function_name, *args, &block); end

  def closure_scope(); end

  def initialize(closure_scope, loader); end

  def internal_call_function(scope, function_name, args, &block); end

  def loader(); end
end

class Puppet::Pops::Functions::Function
  def self.dispatcher(); end

  def self.signatures(); end
end

module Puppet::Pops::Functions
  extend ::T::Sig
end

class Puppet::Pops::HashMergeStrategy
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::HashMergeStrategy
end

class Puppet::Pops::IssueReporter
end

class Puppet::Pops::IssueReporter
  def self.assert_and_report(acceptor, options); end

  def self.error(exception_class, semantic, issue, args); end

  def self.format_with_prefix(prefix, message); end

  def self.warning(semantic, issue, args); end
end

module Puppet::Pops::Issues
  APPENDS_DELETES_NO_LONGER_SUPPORTED = ::T.let(nil, ::T.untyped)
  BAD_ARRAY_SLICE_ARITY = ::T.let(nil, ::T.untyped)
  BAD_COLLECTION_SLICE_TYPE = ::T.let(nil, ::T.untyped)
  BAD_FLOAT_SLICE_ARITY = ::T.let(nil, ::T.untyped)
  BAD_FLOAT_SLICE_TYPE = ::T.let(nil, ::T.untyped)
  BAD_HASH_SLICE_ARITY = ::T.let(nil, ::T.untyped)
  BAD_INTEGER_SLICE_ARITY = ::T.let(nil, ::T.untyped)
  BAD_INTEGER_SLICE_TYPE = ::T.let(nil, ::T.untyped)
  BAD_NOT_UNDEF_SLICE_TYPE = ::T.let(nil, ::T.untyped)
  BAD_SLICE_KEY_TYPE = ::T.let(nil, ::T.untyped)
  BAD_STRING_SLICE_ARITY = ::T.let(nil, ::T.untyped)
  BAD_STRING_SLICE_KEY_TYPE = ::T.let(nil, ::T.untyped)
  BAD_STRING_SLICE_TYPE = ::T.let(nil, ::T.untyped)
  BAD_TYPE_SLICE_ARITY = ::T.let(nil, ::T.untyped)
  BAD_TYPE_SLICE_TYPE = ::T.let(nil, ::T.untyped)
  BAD_TYPE_SPECIALIZATION = ::T.let(nil, ::T.untyped)
  CAPTURES_REST_NOT_LAST = ::T.let(nil, ::T.untyped)
  CAPTURES_REST_NOT_SUPPORTED = ::T.let(nil, ::T.untyped)
  CATALOG_OPERATION_NOT_SUPPORTED_WHEN_SCRIPTING = ::T.let(nil, ::T.untyped)
  CLASS_NOT_VIRTUALIZABLE = ::T.let(nil, ::T.untyped)
  COMPARISON_NOT_POSSIBLE = ::T.let(nil, ::T.untyped)
  CROSS_SCOPE_ASSIGNMENT = ::T.let(nil, ::T.untyped)
  DISCONTINUED_IMPORT = ::T.let(nil, ::T.untyped)
  DIV_BY_ZERO = ::T.let(nil, ::T.untyped)
  DUPLICATE_ATTRIBUTE = ::T.let(nil, ::T.untyped)
  DUPLICATE_DEFAULT = ::T.let(nil, ::T.untyped)
  DUPLICATE_KEY = ::T.let(nil, ::T.untyped)
  DUPLICATE_PARAMETER = ::T.let(nil, ::T.untyped)
  DUPLICATE_TITLE = ::T.let(nil, ::T.untyped)
  EMPTY_HEREDOC_SYNTAX_SEGMENT = ::T.let(nil, ::T.untyped)
  EMPTY_RESOURCE_SPECIALIZATION = ::T.let(nil, ::T.untyped)
  EMPTY_STRING_TITLE_AT = ::T.let(nil, ::T.untyped)
  EPP_INTERNAL_ERROR = ::T.let(nil, ::T.untyped)
  EPP_UNBALANCED_COMMENT = ::T.let(nil, ::T.untyped)
  EPP_UNBALANCED_EXPRESSION = ::T.let(nil, ::T.untyped)
  EPP_UNBALANCED_TAG = ::T.let(nil, ::T.untyped)
  EXPRESSION_NOT_SUPPORTED_WHEN_COMPILING = ::T.let(nil, ::T.untyped)
  EXPRESSION_NOT_SUPPORTED_WHEN_SCRIPTING = ::T.let(nil, ::T.untyped)
  FEATURE_NOT_SUPPORTED_WHEN_SCRIPTING = ::T.let(nil, ::T.untyped)
  FUTURE_RESERVED_WORD = ::T.let(nil, ::T.untyped)
  HEREDOC_DIRTY_MARGIN = ::T.let(nil, ::T.untyped)
  HEREDOC_EMPTY_ENDTAG = ::T.let(nil, ::T.untyped)
  HEREDOC_INVALID_ESCAPE = ::T.let(nil, ::T.untyped)
  HEREDOC_INVALID_SYNTAX = ::T.let(nil, ::T.untyped)
  HEREDOC_MULTIPLE_AT_ESCAPES = ::T.let(nil, ::T.untyped)
  HEREDOC_UNCLOSED_PARENTHESIS = ::T.let(nil, ::T.untyped)
  HEREDOC_WITHOUT_END_TAGGED_LINE = ::T.let(nil, ::T.untyped)
  HEREDOC_WITHOUT_TEXT = ::T.let(nil, ::T.untyped)
  HIERA_BACKEND_MULTIPLY_DEFINED = ::T.let(nil, ::T.untyped)
  HIERA_DATA_PROVIDER_FUNCTION_NOT_FOUND = ::T.let(nil, ::T.untyped)
  HIERA_DEFAULT_HIERARCHY_NOT_IN_MODULE = ::T.let(nil, ::T.untyped)
  HIERA_DEFAULT_OPTION_RESERVED_BY_PUPPET = ::T.let(nil, ::T.untyped)
  HIERA_HIERARCHY_NAME_MULTIPLY_DEFINED = ::T.let(nil, ::T.untyped)
  HIERA_INTERPOLATION_ALIAS_NOT_ENTIRE_STRING = ::T.let(nil, ::T.untyped)
  HIERA_INTERPOLATION_METHOD_SYNTAX_NOT_ALLOWED = ::T.let(nil, ::T.untyped)
  HIERA_INTERPOLATION_UNKNOWN_INTERPOLATION_METHOD = ::T.let(nil, ::T.untyped)
  HIERA_MISSING_DATA_PROVIDER_FUNCTION = ::T.let(nil, ::T.untyped)
  HIERA_MULTIPLE_DATA_PROVIDER_FUNCTIONS = ::T.let(nil, ::T.untyped)
  HIERA_MULTIPLE_DATA_PROVIDER_FUNCTIONS_IN_DEFAULT = ::T.let(nil, ::T.untyped)
  HIERA_MULTIPLE_LOCATION_SPECS = ::T.let(nil, ::T.untyped)
  HIERA_NO_PROVIDER_FOR_BACKEND = ::T.let(nil, ::T.untyped)
  HIERA_OPTION_RESERVED_BY_PUPPET = ::T.let(nil, ::T.untyped)
  HIERA_UNDEFINED_VARIABLE = ::T.let(nil, ::T.untyped)
  HIERA_UNSUPPORTED_VERSION = ::T.let(nil, ::T.untyped)
  HIERA_UNSUPPORTED_VERSION_IN_GLOBAL = ::T.let(nil, ::T.untyped)
  HIERA_V3_BACKEND_NOT_GLOBAL = ::T.let(nil, ::T.untyped)
  HIERA_V3_BACKEND_REPLACED_BY_DATA_HASH = ::T.let(nil, ::T.untyped)
  HIERA_VERSION_3_NOT_GLOBAL = ::T.let(nil, ::T.untyped)
  IDEM_EXPRESSION_NOT_LAST = ::T.let(nil, ::T.untyped)
  IDEM_NOT_ALLOWED_LAST = ::T.let(nil, ::T.untyped)
  ILLEGAL_ASSIGNMENT = ::T.let(nil, ::T.untyped)
  ILLEGAL_ASSIGNMENT_CONTEXT = ::T.let(nil, ::T.untyped)
  ILLEGAL_ASSIGNMENT_VIA_INDEX = ::T.let(nil, ::T.untyped)
  ILLEGAL_ATTRIBUTE_APPEND = ::T.let(nil, ::T.untyped)
  ILLEGAL_BOM = ::T.let(nil, ::T.untyped)
  ILLEGAL_CATALOG_RELATED_EXPRESSION = ::T.let(nil, ::T.untyped)
  ILLEGAL_CLASSREF = ::T.let(nil, ::T.untyped)
  ILLEGAL_CLASS_REFERENCE = ::T.let(nil, ::T.untyped)
  ILLEGAL_DEFINITION_LOCATION = ::T.let(nil, ::T.untyped)
  ILLEGAL_DEFINITION_NAME = ::T.let(nil, ::T.untyped)
  ILLEGAL_EPP_PARAMETERS = ::T.let(nil, ::T.untyped)
  ILLEGAL_EXPRESSION = ::T.let(nil, ::T.untyped)
  ILLEGAL_FULLY_QUALIFIED_CLASS_REFERENCE = ::T.let(nil, ::T.untyped)
  ILLEGAL_FULLY_QUALIFIED_NAME = ::T.let(nil, ::T.untyped)
  ILLEGAL_HOSTCLASS_NAME = ::T.let(nil, ::T.untyped)
  ILLEGAL_HOSTNAME_CHARS = ::T.let(nil, ::T.untyped)
  ILLEGAL_HOSTNAME_INTERPOLATION = ::T.let(nil, ::T.untyped)
  ILLEGAL_INDEXED_ASSIGNMENT = ::T.let(nil, ::T.untyped)
  ILLEGAL_MULTI_ASSIGNMENT_SIZE = ::T.let(nil, ::T.untyped)
  ILLEGAL_NAME = ::T.let(nil, ::T.untyped)
  ILLEGAL_NAME_OR_BARE_WORD = ::T.let(nil, ::T.untyped)
  ILLEGAL_NODE_INHERITANCE = ::T.let(nil, ::T.untyped)
  ILLEGAL_NUMBER = ::T.let(nil, ::T.untyped)
  ILLEGAL_NUMERIC_ASSIGNMENT = ::T.let(nil, ::T.untyped)
  ILLEGAL_NUMERIC_PARAMETER = ::T.let(nil, ::T.untyped)
  ILLEGAL_NUMERIC_VAR_NAME = ::T.let(nil, ::T.untyped)
  ILLEGAL_OVERRIDDEN_TYPE = ::T.let(nil, ::T.untyped)
  ILLEGAL_PARAM_NAME = ::T.let(nil, ::T.untyped)
  ILLEGAL_QUERY_EXPRESSION = ::T.let(nil, ::T.untyped)
  ILLEGAL_REASSIGNMENT = ::T.let(nil, ::T.untyped)
  ILLEGAL_REGEXP_TYPE_MAPPING = ::T.let(nil, ::T.untyped)
  ILLEGAL_RELATIONSHIP_OPERAND_TYPE = ::T.let(nil, ::T.untyped)
  ILLEGAL_RESERVED_ASSIGNMENT = ::T.let(nil, ::T.untyped)
  ILLEGAL_RESOURCE_SPECIALIZATION = ::T.let(nil, ::T.untyped)
  ILLEGAL_RESOURCE_TYPE = ::T.let(nil, ::T.untyped)
  ILLEGAL_SINGLE_TYPE_MAPPING = ::T.let(nil, ::T.untyped)
  ILLEGAL_TITLE_TYPE_AT = ::T.let(nil, ::T.untyped)
  ILLEGAL_TOP_CONSTRUCT_LOCATION = ::T.let(nil, ::T.untyped)
  ILLEGAL_TYPE_SPECIALIZATION = ::T.let(nil, ::T.untyped)
  ILLEGAL_UNICODE_ESCAPE = ::T.let(nil, ::T.untyped)
  ILLEGAL_VARIABLE_EXPRESSION = ::T.let(nil, ::T.untyped)
  ILLEGAL_VAR_NAME = ::T.let(nil, ::T.untyped)
  INVALID_DECIMAL_NUMBER = ::T.let(nil, ::T.untyped)
  INVALID_HEX_NUMBER = ::T.let(nil, ::T.untyped)
  INVALID_OCTAL_NUMBER = ::T.let(nil, ::T.untyped)
  LOADER_FAILURE = ::T.let(nil, ::T.untyped)
  MATCH_NOT_REGEXP = ::T.let(nil, ::T.untyped)
  MATCH_NOT_STRING = ::T.let(nil, ::T.untyped)
  MISSING_MULTI_ASSIGNMENT_KEY = ::T.let(nil, ::T.untyped)
  MISSING_MULTI_ASSIGNMENT_VARIABLE = ::T.let(nil, ::T.untyped)
  MISSING_REQUIRED_PARAMETER = ::T.let(nil, ::T.untyped)
  MISSING_TITLE = ::T.let(nil, ::T.untyped)
  MISSING_TITLE_AT = ::T.let(nil, ::T.untyped)
  MULTIPLE_ATTRIBUTES_UNFOLD = ::T.let(nil, ::T.untyped)
  NAME_WITH_HYPHEN = ::T.let(nil, ::T.untyped)
  NOT_ABSOLUTE_TOP_LEVEL = ::T.let(nil, ::T.untyped)
  NOT_A_FILE = ::T.let(nil, ::T.untyped)
  NOT_CATALOG_TYPE = ::T.let(nil, ::T.untyped)
  NOT_NUMERIC = ::T.let(nil, ::T.untyped)
  NOT_RVALUE = ::T.let(nil, ::T.untyped)
  NOT_TOP_LEVEL = ::T.let(nil, ::T.untyped)
  NOT_VIRTUALIZEABLE = ::T.let(nil, ::T.untyped)
  NO_INPUT_TO_LEXER = ::T.let(nil, ::T.untyped)
  NO_SUCH_FILE_OR_DIRECTORY = ::T.let(nil, ::T.untyped)
  NUMERIC_COERCION = ::T.let(nil, ::T.untyped)
  NUMERIC_OVERFLOW = ::T.let(nil, ::T.untyped)
  OPERATOR_NOT_APPLICABLE = ::T.let(nil, ::T.untyped)
  OPERATOR_NOT_APPLICABLE_WHEN = ::T.let(nil, ::T.untyped)
  REQUIRED_PARAMETER_AFTER_OPTIONAL = ::T.let(nil, ::T.untyped)
  RESERVED_PARAMETER = ::T.let(nil, ::T.untyped)
  RESERVED_TYPE_NAME = ::T.let(nil, ::T.untyped)
  RESERVED_WORD = ::T.let(nil, ::T.untyped)
  RESOURCE_WITHOUT_TITLE = ::T.let(nil, ::T.untyped)
  RESULT_IS_INFINITY = ::T.let(nil, ::T.untyped)
  RT_NO_STORECONFIGS = ::T.let(nil, ::T.untyped)
  RT_NO_STORECONFIGS_EXPORT = ::T.let(nil, ::T.untyped)
  RUNTIME_ERROR = ::T.let(nil, ::T.untyped)
  SERIALIZATION_DEFAULT_CONVERTED_TO_STRING = ::T.let(nil, ::T.untyped)
  SERIALIZATION_ENDLESS_RECURSION = ::T.let(nil, ::T.untyped)
  SERIALIZATION_UNKNOWN_CONVERTED_TO_STRING = ::T.let(nil, ::T.untyped)
  SERIALIZATION_UNKNOWN_KEY_CONVERTED_TO_STRING = ::T.let(nil, ::T.untyped)
  SYNTAX_ERROR = ::T.let(nil, ::T.untyped)
  TASK_MISSING_BOLT = ::T.let(nil, ::T.untyped)
  TASK_OPERATION_NOT_SUPPORTED_WHEN_COMPILING = ::T.let(nil, ::T.untyped)
  TYPE_MISMATCH = ::T.let(nil, ::T.untyped)
  UNCLOSED_MLCOMMENT = ::T.let(nil, ::T.untyped)
  UNCLOSED_QUOTE = ::T.let(nil, ::T.untyped)
  UNKNOWN_FUNCTION = ::T.let(nil, ::T.untyped)
  UNKNOWN_RESOURCE = ::T.let(nil, ::T.untyped)
  UNKNOWN_RESOURCE_PARAMETER = ::T.let(nil, ::T.untyped)
  UNKNOWN_RESOURCE_TYPE = ::T.let(nil, ::T.untyped)
  UNKNOWN_TASK = ::T.let(nil, ::T.untyped)
  UNKNOWN_VARIABLE = ::T.let(nil, ::T.untyped)
  UNMATCHED_SELECTOR = ::T.let(nil, ::T.untyped)
  UNRECOGNIZED_ESCAPE = ::T.let(nil, ::T.untyped)
  UNSUPPORTED_EXPRESSION = ::T.let(nil, ::T.untyped)
  UNSUPPORTED_OPERATOR = ::T.let(nil, ::T.untyped)
  UNSUPPORTED_OPERATOR_IN_CONTEXT = ::T.let(nil, ::T.untyped)
  UNSUPPORTED_RANGE = ::T.let(nil, ::T.untyped)
  VAR_WITH_HYPHEN = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Issues::Issue
  def arg_names(); end

  def demotable=(demotable); end

  def demotable?(); end

  def format(hash=T.unsafe(nil)); end

  def initialize(issue_code, *args, &block); end

  def issue_code(); end

  def message_block(); end
end

class Puppet::Pops::Issues::Issue
end

class Puppet::Pops::Issues::MessageData
  def format(hash, &block); end

  def initialize(*argnames); end

  def label(*args); end

  def label_provider(); end

  def semantic(); end
end

class Puppet::Pops::Issues::MessageData
end

module Puppet::Pops::Issues
  extend ::T::Sig
  def self.hard_issue(issue_code, *args, &block); end

  def self.issue(issue_code, *args, &block); end
end

module Puppet::Pops::LabelProvider
  def a_an(o); end

  def a_an_uc(o); end

  def article(s); end

  def combine_strings(strings, conjunction=T.unsafe(nil)); end

  def label(o); end

  def plural_s(count, text=T.unsafe(nil)); end

  def the(o); end

  def the_uc(o); end
  A = ::T.let(nil, ::T.untyped)
  AN = ::T.let(nil, ::T.untyped)
  SKIPPED_CHARACTERS = ::T.let(nil, ::T.untyped)
  VOWELS = ::T.let(nil, ::T.untyped)
end

module Puppet::Pops::LabelProvider
  extend ::T::Sig
end

module Puppet::Pops::Loader
  ENVIRONMENT = ::T.let(nil, ::T.untyped)
  ENVIRONMENT_PRIVATE = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Loader::BaseLoader
  def add_entry(type, name, value, origin); end

  def allow_shadowing?(); end

  def initialize(parent_loader, loader_name); end

  def promote_entry(named_entry); end

  def remove_entry(typed_name); end

  def set_entry(typed_name, value, origin=T.unsafe(nil)); end
end

class Puppet::Pops::Loader::BaseLoader
end

class Puppet::Pops::Loader::DependencyLoader
  def initialize(parent_loader, name, dependency_loaders); end
end

class Puppet::Pops::Loader::DependencyLoader
end

module Puppet::Pops::Loader::GemSupport
  def gem_dir(uri_or_string); end

  def gem_dir_from_name(gem_name); end

  def gem_dir_from_uri(uri); end
end

module Puppet::Pops::Loader::GemSupport
  extend ::T::Sig
end

class Puppet::Pops::Loader::GenericPlanInstantiator
end

class Puppet::Pops::Loader::GenericPlanInstantiator
  def self.create(loader, typed_name, source_refs); end
end

class Puppet::Pops::Loader::Loader
  def [](typed_name); end

  def discover(type, error_collector=T.unsafe(nil), name_authority=T.unsafe(nil), &block); end

  def find(typed_name); end

  def get_entry(typed_name); end

  def initialize(loader_name); end

  def load(type, name); end

  def load_typed(typed_name); end

  def loadables(); end

  def loaded_entry(typed_name, check_dependencies=T.unsafe(nil)); end

  def loader_name(); end

  def parent(); end

  def private_loader(); end

  def set_entry(type, name, value, origin=T.unsafe(nil)); end
  LOADABLE_KINDS = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Loader::Loader::NamedEntry
  def initialize(typed_name, value, origin); end

  def origin(); end

  def typed_name(); end

  def value(); end
end

class Puppet::Pops::Loader::Loader::NamedEntry
end

class Puppet::Pops::Loader::Loader
end

module Puppet::Pops::Loader::LoaderPaths
end

class Puppet::Pops::Loader::LoaderPaths::DataTypePath
  SYSTEM_TYPE_PATH = ::T.let(nil, ::T.untyped)
  TYPE_PATH = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Loader::LoaderPaths::DataTypePath
end

class Puppet::Pops::Loader::LoaderPaths::FunctionPath3x
  FUNCTION_PATH_3X = ::T.let(nil, ::T.untyped)
  SYSTEM_FUNCTION_PATH_3X = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Loader::LoaderPaths::FunctionPath3x
end

class Puppet::Pops::Loader::LoaderPaths::FunctionPath4x
  FUNCTION_PATH_4X = ::T.let(nil, ::T.untyped)
  SYSTEM_FUNCTION_PATH_4X = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Loader::LoaderPaths::FunctionPath4x
end

class Puppet::Pops::Loader::LoaderPaths::FunctionPathPP
  FUNCTION_PATH_PP = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Loader::LoaderPaths::FunctionPathPP
end

class Puppet::Pops::Loader::LoaderPaths::PlanPath
  PLAN_PATH = ::T.let(nil, ::T.untyped)
  PP_EXT = ::T.let(nil, ::T.untyped)
  YAML_EXT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Loader::LoaderPaths::PlanPath
end

class Puppet::Pops::Loader::LoaderPaths::PuppetSmartPath
  def extension(); end
  EXTENSION = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Loader::LoaderPaths::PuppetSmartPath
end

class Puppet::Pops::Loader::LoaderPaths::ResourceTypeImplPP
  RESOURCE_TYPES_PATH_PP = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Loader::LoaderPaths::ResourceTypeImplPP
end

class Puppet::Pops::Loader::LoaderPaths::RubySmartPath
  def extension(); end
  EXTENSION = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Loader::LoaderPaths::RubySmartPath
end

class Puppet::Pops::Loader::LoaderPaths::SmartPath
  def effective_path(typed_name, start_index_in_name); end

  def fuzzy_matching?(); end

  def generic_path(); end

  def initialize(loader); end

  def instantiator(); end

  def lib_root?(); end

  def relative_path(); end

  def root_path(); end

  def typed_name(type, name_authority, relative_path, module_name); end

  def valid_name?(typed_name); end

  def valid_path?(path); end
end

class Puppet::Pops::Loader::LoaderPaths::SmartPath
end

class Puppet::Pops::Loader::LoaderPaths::SmartPaths
  def effective_paths(type); end

  def initialize(path_based_loader); end
end

class Puppet::Pops::Loader::LoaderPaths::SmartPaths
end

class Puppet::Pops::Loader::LoaderPaths::TaskPath
  def is_task_name?(name); end
  FORBIDDEN_EXTENSIONS = ::T.let(nil, ::T.untyped)
  TASKS_PATH = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Loader::LoaderPaths::TaskPath
end

class Puppet::Pops::Loader::LoaderPaths::TypePathPP
  TYPE_PATH_PP = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Loader::LoaderPaths::TypePathPP
end

module Puppet::Pops::Loader::LoaderPaths
  extend ::T::Sig
  def self.relative_paths_for_type(type, loader); end
end

module Puppet::Pops::Loader::ModuleLoaders
  NAMESPACE_WILDCARD = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Loader::ModuleLoaders::AbstractPathBasedModuleLoader
  def candidate_paths(resolved_path); end

  def existing_path(resolved_path); end

  def get_contents(effective_path); end

  def get_source_ref(relative_path); end

  def global?(); end

  def initialize(parent_loader, loaders, module_name, path, loader_name, loadables); end

  def instantiate(smart_path, typed_name, origin); end

  def lib_root?(); end

  def meaningful_to_search?(smart_path); end

  def module_name(); end

  def path(); end

  def private_loader=(private_loader); end

  def relative_paths(smart_path); end

  def smart_paths(); end
end

class Puppet::Pops::Loader::ModuleLoaders::AbstractPathBasedModuleLoader
end

class Puppet::Pops::Loader::ModuleLoaders::EmptyLoader
  def private_loader=(loader); end
end

class Puppet::Pops::Loader::ModuleLoaders::EmptyLoader
end

class Puppet::Pops::Loader::ModuleLoaders::FileBased
  def add_to_index(smart_path); end

  def candidate_paths(effective_path); end

  def existing_path(effective_path); end

  def initialize(parent_loader, loaders, module_name, path, loader_name, loadables=T.unsafe(nil)); end

  def path_index(); end
end

class Puppet::Pops::Loader::ModuleLoaders::FileBased
end

class Puppet::Pops::Loader::ModuleLoaders::GemBased
  include ::Puppet::Pops::Loader::GemSupport
  def gem_ref(); end

  def initialize(parent_loader, loaders, module_name, gem_ref, loader_name, loadables=T.unsafe(nil)); end
end

class Puppet::Pops::Loader::ModuleLoaders::GemBased
end

class Puppet::Pops::Loader::ModuleLoaders::LibRootedFileBased
end

class Puppet::Pops::Loader::ModuleLoaders::LibRootedFileBased
end

module Puppet::Pops::Loader::ModuleLoaders
  extend ::T::Sig
  def self.cached_loader_from(parent_loader, loaders); end

  def self.environment_loader_from(parent_loader, loaders, env_path); end

  def self.module_loader_from(parent_loader, loaders, module_name, module_path); end

  def self.pcore_resource_type_loader_from(parent_loader, loaders, environment_path); end

  def self.system_loader_from(parent_loader, loaders); end
end

class Puppet::Pops::Loader::NullLoader
  def find(name); end

  def initialize(parent_loader=T.unsafe(nil), loader_name=T.unsafe(nil)); end

  def set_entry(typed_name, value, origin=T.unsafe(nil)); end
end

class Puppet::Pops::Loader::NullLoader
end

class Puppet::Pops::Loader::PredefinedLoader
end

class Puppet::Pops::Loader::PredefinedLoader
end

class Puppet::Pops::Loader::PuppetFunctionInstantiator
end

class Puppet::Pops::Loader::PuppetFunctionInstantiator
  def self.create(loader, typed_name, source_ref, pp_code_string); end

  def self.create_from_model(function_definition, loader); end

  def self.create_function_class(function_definition); end
end

class Puppet::Pops::Loader::PuppetPlanInstantiator
end

class Puppet::Pops::Loader::PuppetPlanInstantiator
  def self.create(loader, typed_name, source_ref, pp_code_string); end

  def self.create_from_model(plan_definition, loader); end

  def self.create_function_class(plan_definition); end
end

class Puppet::Pops::Loader::PuppetResourceTypeImplInstantiator
end

class Puppet::Pops::Loader::PuppetResourceTypeImplInstantiator
  def self.create(loader, typed_name, source_ref, pp_code_string); end
end

class Puppet::Pops::Loader::RubyDataTypeInstantiator
end

class Puppet::Pops::Loader::RubyDataTypeInstantiator
  def self.create(loader, typed_name, source_ref, ruby_code_string); end
end

class Puppet::Pops::Loader::RubyFunctionInstantiator
end

class Puppet::Pops::Loader::RubyFunctionInstantiator
  def self.create(loader, typed_name, source_ref, ruby_code_string); end
end

class Puppet::Pops::Loader::RubyLegacyFunctionInstantiator
  UNKNOWN = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Loader::RubyLegacyFunctionInstantiator
  def self.create(loader, typed_name, source_ref, ruby_code_string); end
end

class Puppet::Pops::Loader::Runtime3TypeLoader
  def initialize(parent_loader, loaders, environment, env_path); end
end

class Puppet::Pops::Loader::Runtime3TypeLoader
end

class Puppet::Pops::Loader::SimpleEnvironmentLoader
  def private_loader=(private_loader); end
end

class Puppet::Pops::Loader::SimpleEnvironmentLoader
end

class Puppet::Pops::Loader::StaticLoader
  def discover(type, error_collector=T.unsafe(nil), name_authority=T.unsafe(nil)); end

  def find(name); end

  def initialize(); end

  def loaded(); end

  def register_aliases(); end

  def runtime_3_init(); end

  def set_entry(typed_name, value, origin=T.unsafe(nil)); end
  BUILTIN_ALIASES = ::T.let(nil, ::T.untyped)
  BUILTIN_TYPE_NAMES = ::T.let(nil, ::T.untyped)
  BUILTIN_TYPE_NAMES_LC = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Loader::StaticLoader
end

class Puppet::Pops::Loader::TypeDefinitionInstantiator
  def several_paths?(); end
end

class Puppet::Pops::Loader::TypeDefinitionInstantiator
  def self.create(loader, typed_name, source_ref, pp_code_string); end

  def self.create_from_model(type_definition, loader); end

  def self.create_named_type(name, type_name, type_expr, name_authority); end

  def self.create_runtime_type(type_definition); end

  def self.create_type(name, type_expr, name_authority); end

  def self.named_definition(te); end
end

class Puppet::Pops::Loader::TypedName
  def ==(o); end

  def compound_name(); end

  def eql?(o); end

  def initialize(type, name, name_authority=T.unsafe(nil)); end

  def name(); end

  def name_authority(); end

  def name_parts(); end

  def parent(); end

  def qualified?(); end

  def type(); end
end

class Puppet::Pops::Loader::TypedName
end

module Puppet::Pops::Loader
  extend ::T::Sig
end

class Puppet::Pops::Loaders
  def [](loader_name); end

  def add_loader_by_name(loader); end

  def environment(); end

  def find_loader(module_name); end

  def implementation_registry(); end

  def initialize(environment, for_agent); end

  def instantiate_definition(definition, loader); end

  def instantiate_definitions(program, loader); end

  def load_main_manifest(); end

  def pre_load(); end

  def private_environment_loader(); end

  def private_loader_for_module(module_name); end

  def public_environment_loader(); end

  def public_loader_for_module(module_name); end

  def puppet_cache_loader(); end

  def puppet_system_loader(); end

  def register_implementations(obj_classes, name_authority); end

  def runtime3_type_loader(); end

  def static_loader(); end
end

class Puppet::Pops::Loaders::LoaderError
end

class Puppet::Pops::Loaders::LoaderError
end

class Puppet::Pops::Loaders::LoaderModuleData
  def dependency_names(); end

  def initialize(puppet_module); end

  def name(); end

  def path(); end

  def private_loader(); end

  def private_loader=(private_loader); end

  def public_loader(); end

  def public_loader=(public_loader); end

  def puppet_module(); end

  def resolutions(); end

  def resolutions=(resolutions); end

  def resolved?(); end

  def restrict_to_dependencies?(); end

  def unmet_dependencies?(); end

  def version(); end
end

class Puppet::Pops::Loaders::LoaderModuleData
end

class Puppet::Pops::Loaders::ModuleResolver
  def [](name); end

  def []=(name, module_data); end

  def all_module_loaders(); end

  def initialize(loaders); end

  def resolve(module_data); end
end

class Puppet::Pops::Loaders::ModuleResolver
end

class Puppet::Pops::Loaders
  def self.catalog_loader(); end

  def self.clear(); end

  def self.find_loader(module_name); end

  def self.implementation_registry(); end

  def self.loaders(); end

  def self.new(environment, for_agent=T.unsafe(nil)); end

  def self.register_implementations_with_loader(obj_classes, name_authority, loader); end

  def self.register_runtime3_type(name, origin); end

  def self.register_static_implementations(obj_classes); end

  def self.static_implementation_registry(); end

  def self.static_loader(); end
end

module Puppet::Pops::Lookup
  GLOBAL = ::T.let(nil, ::T.untyped)
  LOOKUP_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Lookup::ConfiguredDataProvider
  include ::Puppet::Pops::Lookup::DataProvider
  def assert_config_version(config); end

  def config(lookup_invocation); end

  def config=(config); end

  def config_path(); end

  def configuration_path(lookup_invocation); end

  def initialize(config=T.unsafe(nil)); end

  def provider_root(lookup_invocation); end
end

class Puppet::Pops::Lookup::ConfiguredDataProvider
end

class Puppet::Pops::Lookup::Context
  include ::Puppet::Pops::Types::PuppetObject
  def cache(*args, &block); end

  def cache_all(*args, &block); end

  def cache_has_key(*args, &block); end

  def cached_entries(*args, &block); end

  def cached_file_data(*args, &block); end

  def cached_value(*args, &block); end

  def environment_name(*args, &block); end

  def explain(&block); end

  def initialize(function_context, lookup_invocation); end

  def interpolate(value); end

  def invocation(); end

  def module_name(*args, &block); end

  def not_found(); end
end

class Puppet::Pops::Lookup::Context
  extend ::Forwardable
  def self._pcore_type(); end

  def self.from_asserted_args(module_name); end

  def self.register_ptype(loader, ir); end
end

class Puppet::Pops::Lookup::DataAdapter
  def [](name); end

  def []=(name, value); end

  def include?(name); end
end

class Puppet::Pops::Lookup::DataAdapter
end

class Puppet::Pops::Lookup::DataDigFunctionProvider
  def invoke_with_location(lookup_invocation, location, key, merge); end

  def label(); end

  def validated_data_dig(key, lookup_invocation, location, merge); end
  TAG = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Lookup::DataDigFunctionProvider
end

class Puppet::Pops::Lookup::DataHashFunctionProvider
  include ::Puppet::Pops::Lookup::Interpolation
  include ::Puppet::Pops::Lookup::SubLookup
  TAG = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Lookup::DataHashFunctionProvider
end

module Puppet::Pops::Lookup::DataProvider
  def key_lookup(key, lookup_invocation, merge); end

  def key_lookup_in_default(key, lookup_invocation, merge); end

  def lookup(key, lookup_invocation, merge); end

  def module_name(); end

  def name(); end

  def unchecked_key_lookup(key, lookup_invocation, merge); end

  def validate_data_hash(data_hash, &block); end

  def validate_data_value(value, &block); end

  def value_is_validated?(); end
end

module Puppet::Pops::Lookup::DataProvider
  extend ::T::Sig
  def self.key_type(); end

  def self.register_types(loader); end

  def self.value_type(); end
end

class Puppet::Pops::Lookup::DebugExplainer
  def emit_debug_info(preamble); end

  def initialize(wrapped_explainer); end

  def wrapped_explainer(); end
end

class Puppet::Pops::Lookup::DebugExplainer
end

class Puppet::Pops::Lookup::EnvironmentContext
  def cached_file_data(path); end

  def environment_name(); end

  def initialize(environment); end
end

class Puppet::Pops::Lookup::EnvironmentContext::FileData
  def data(); end

  def initialize(path, inode, mtime, size, data); end

  def valid?(stat); end
end

class Puppet::Pops::Lookup::EnvironmentContext::FileData
end

class Puppet::Pops::Lookup::EnvironmentContext
  def self.create_adapter(environment); end
end

class Puppet::Pops::Lookup::EnvironmentDataProvider
  def place(); end
end

class Puppet::Pops::Lookup::EnvironmentDataProvider
end

class Puppet::Pops::Lookup::ExplainDataProvider
  def initialize(parent, provider); end
end

class Puppet::Pops::Lookup::ExplainDataProvider
end

class Puppet::Pops::Lookup::ExplainGlobal
  def initialize(parent, binding_terminus); end
end

class Puppet::Pops::Lookup::ExplainGlobal
end

class Puppet::Pops::Lookup::ExplainInterpolate
  def initialize(parent, expression); end
end

class Puppet::Pops::Lookup::ExplainInterpolate
end

class Puppet::Pops::Lookup::ExplainInvalidKey
  def initialize(parent, key); end
end

class Puppet::Pops::Lookup::ExplainInvalidKey
end

class Puppet::Pops::Lookup::ExplainKeySegment
  def initialize(parent, segment); end
end

class Puppet::Pops::Lookup::ExplainKeySegment
end

class Puppet::Pops::Lookup::ExplainLocation
  def initialize(parent, location); end
end

class Puppet::Pops::Lookup::ExplainLocation
end

class Puppet::Pops::Lookup::ExplainMerge
  def initialize(parent, merge); end

  def options_wo_strategy(); end
end

class Puppet::Pops::Lookup::ExplainMerge
end

class Puppet::Pops::Lookup::ExplainMergeSource
  def initialize(merge_source); end

  def merge_source(); end

  def type(); end
end

class Puppet::Pops::Lookup::ExplainMergeSource
end

class Puppet::Pops::Lookup::ExplainModule
  def initialize(parent, module_name); end

  def module_not_found(); end

  def module_provider_not_found(); end
end

class Puppet::Pops::Lookup::ExplainModule
end

class Puppet::Pops::Lookup::ExplainNode
  def branches(); end

  def dump_on(io, indent, first_indent); end

  def dump_texts(io, indent); end

  def explain(); end

  def text(text); end

  def to_hash(); end
end

class Puppet::Pops::Lookup::ExplainNode
end

class Puppet::Pops::Lookup::ExplainScope
  def initialize(parent, name); end
end

class Puppet::Pops::Lookup::ExplainScope
end

class Puppet::Pops::Lookup::ExplainSubLookup
  def initialize(parent, sub_key); end
end

class Puppet::Pops::Lookup::ExplainSubLookup
end

class Puppet::Pops::Lookup::ExplainTop
  def initialize(parent, type, key); end
end

class Puppet::Pops::Lookup::ExplainTop
end

class Puppet::Pops::Lookup::ExplainTreeNode
  def dump_outcome(io, indent); end

  def dump_value(io, indent, value); end

  def event(); end

  def found(key, value); end

  def found_in_defaults(key, value); end

  def found_in_overrides(key, value); end

  def increase_indent(indent); end

  def initialize(parent); end

  def key(); end

  def key=(key); end

  def location_not_found(); end

  def not_found(key); end

  def parent(); end

  def result(value); end

  def type(); end

  def value(); end
end

class Puppet::Pops::Lookup::ExplainTreeNode
end

class Puppet::Pops::Lookup::Explainer
  def accept_found(key, value); end

  def accept_found_in_defaults(key, value); end

  def accept_found_in_overrides(key, value); end

  def accept_location_not_found(); end

  def accept_merge_source(merge_source); end

  def accept_module_not_found(module_name); end

  def accept_module_provider_not_found(module_name); end

  def accept_not_found(key); end

  def accept_result(result); end

  def accept_text(text); end

  def explain_options?(); end

  def initialize(explain_options=T.unsafe(nil), only_explain_options=T.unsafe(nil)); end

  def only_explain_options?(); end

  def pop(); end

  def push(qualifier_type, qualifier); end
end

class Puppet::Pops::Lookup::Explainer
end

class Puppet::Pops::Lookup::FunctionContext
  include ::Puppet::Pops::Lookup::Interpolation
  include ::Puppet::Pops::Lookup::SubLookup
  def cache(key, value); end

  def cache_all(hash); end

  def cache_has_key(key); end

  def cached_entries(&block); end

  def cached_file_data(path, &block); end

  def cached_value(key); end

  def data_hash(); end

  def data_hash=(data_hash); end

  def environment_name(); end

  def function(); end

  def initialize(environment_context, module_name, function); end

  def module_name(); end
end

class Puppet::Pops::Lookup::FunctionContext
end

class Puppet::Pops::Lookup::FunctionProvider
  include ::Puppet::Pops::Lookup::DataProvider
  def create_function_context(lookup_invocation); end

  def full_name(); end

  def function_context(lookup_invocation, location); end

  def function_name(); end

  def initialize(name, parent_data_provider, function_name, options, locations); end

  def locations(); end

  def options(location=T.unsafe(nil)); end

  def parent_data_provider(); end
end

class Puppet::Pops::Lookup::FunctionProvider
  def self.trusted_return_type(); end
end

class Puppet::Pops::Lookup::GlobalDataProvider
  def place(); end
end

class Puppet::Pops::Lookup::GlobalDataProvider
end

class Puppet::Pops::Lookup::HieraConfig
  include ::Puppet::Pops::Lookup::LocationResolver
  include ::Puppet::Pops::Lookup::Interpolation
  include ::Puppet::Pops::Lookup::SubLookup
  include ::Puppet::Pops::LabelProvider
  def config_path(); end

  def configured_data_providers(lookup_invocation, parent_data_provider, use_default_hierarchy=T.unsafe(nil)); end

  def create_configured_data_providers(lookup_invocation, parent_data_provider, use_default_hierarchy); end

  def create_hiera3_backend_provider(name, backend, parent_data_provider, datadir, paths, hiera3_config); end

  def fail(issue, args=T.unsafe(nil), line=T.unsafe(nil)); end

  def find_line_matching(regexp, start_line=T.unsafe(nil)); end

  def has_default_hierarchy?(); end

  def initialize(config_root, config_path, loaded_config, owner); end

  def name(); end

  def scope_interpolations_stable?(lookup_invocation); end

  def validate_config(config, owner); end

  def version(); end
  ALL_FUNCTION_KEYS = ::T.let(nil, ::T.untyped)
  CONFIG_FILE_NAME = ::T.let(nil, ::T.untyped)
  FUNCTION_KEYS = ::T.let(nil, ::T.untyped)
  FUNCTION_PROVIDERS = ::T.let(nil, ::T.untyped)
  KEY_BACKEND = ::T.let(nil, ::T.untyped)
  KEY_DATADIR = ::T.let(nil, ::T.untyped)
  KEY_DATA_DIG = ::T.let(nil, ::T.untyped)
  KEY_DATA_HASH = ::T.let(nil, ::T.untyped)
  KEY_DEFAULTS = ::T.let(nil, ::T.untyped)
  KEY_DEFAULT_HIERARCHY = ::T.let(nil, ::T.untyped)
  KEY_EXTENSION = ::T.let(nil, ::T.untyped)
  KEY_GLOB = ::T.let(nil, ::T.untyped)
  KEY_GLOBS = ::T.let(nil, ::T.untyped)
  KEY_HIERARCHY = ::T.let(nil, ::T.untyped)
  KEY_LOGGER = ::T.let(nil, ::T.untyped)
  KEY_LOOKUP_KEY = ::T.let(nil, ::T.untyped)
  KEY_MAPPED_PATHS = ::T.let(nil, ::T.untyped)
  KEY_NAME = ::T.let(nil, ::T.untyped)
  KEY_OPTIONS = ::T.let(nil, ::T.untyped)
  KEY_PATH = ::T.let(nil, ::T.untyped)
  KEY_PATHS = ::T.let(nil, ::T.untyped)
  KEY_URI = ::T.let(nil, ::T.untyped)
  KEY_URIS = ::T.let(nil, ::T.untyped)
  KEY_V3_BACKEND = ::T.let(nil, ::T.untyped)
  KEY_V3_DATA_HASH = ::T.let(nil, ::T.untyped)
  KEY_V3_LOOKUP_KEY = ::T.let(nil, ::T.untyped)
  KEY_V4_DATA_HASH = ::T.let(nil, ::T.untyped)
  KEY_VERSION = ::T.let(nil, ::T.untyped)
  LOCATION_KEYS = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Lookup::HieraConfig
  def self.config_exist?(config_root); end

  def self.create(lookup_invocation, config_path, owner); end

  def self.not_implemented(impl, method_name); end

  def self.symkeys_to_string(struct); end

  def self.v4_function_config(config_root, function_name, owner); end
end

class Puppet::Pops::Lookup::HieraConfigV3
  def create_configured_data_providers(lookup_invocation, parent_data_provider, _); end

  def merge_strategy(); end
  DEFAULT_CONFIG_HASH = ::T.let(nil, ::T.untyped)
  KEY_BACKENDS = ::T.let(nil, ::T.untyped)
  KEY_DEEP_MERGE_OPTIONS = ::T.let(nil, ::T.untyped)
  KEY_MERGE_BEHAVIOR = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Lookup::HieraConfigV3
  def self.config_type(); end
end

class Puppet::Pops::Lookup::HieraConfigV4
  def create_configured_data_providers(lookup_invocation, parent_data_provider, _); end
end

class Puppet::Pops::Lookup::HieraConfigV4
  def self.config_type(); end
end

class Puppet::Pops::Lookup::HieraConfigV5
  def validate_defaults(defaults); end

  def validate_hierarchy(he, defaults, owner); end
  DEFAULT_CONFIG_HASH = ::T.let(nil, ::T.untyped)
  RESERVED_OPTION_KEYS = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Lookup::HieraConfigV5
  def self.config_type(); end
end

module Puppet::Pops::Lookup::Interpolation
  include ::Puppet::Pops::Lookup::SubLookup
  def interpolate(value, context, allow_methods); end
  EMPTY_INTERPOLATIONS = ::T.let(nil, ::T.untyped)
  QUOTED_KEY = ::T.let(nil, ::T.untyped)
end

module Puppet::Pops::Lookup::Interpolation
  extend ::T::Sig
end

class Puppet::Pops::Lookup::Invocation
  def adapter_class(); end

  def check(name); end

  def default_values(); end

  def emit_debug_info(preamble); end

  def explain_options?(); end

  def explainer(); end

  def global_hiera_config_path(); end

  def global_only?(); end

  def hiera_v3_location_overrides(); end

  def hiera_v3_merge_behavior?(); end

  def hiera_xxx_call?(); end

  def initialize(scope, override_values=T.unsafe(nil), default_values=T.unsafe(nil), explainer=T.unsafe(nil), adapter_class=T.unsafe(nil)); end

  def lookup(key, module_name=T.unsafe(nil)); end

  def lookup_adapter(); end

  def module_name(); end

  def name_stack(); end

  def only_explain_options?(); end

  def override_values(); end

  def remember_scope_lookup(*lookup_result); end

  def report_found(key, value); end

  def report_found_in_defaults(key, value); end

  def report_found_in_overrides(key, value); end

  def report_location_not_found(); end

  def report_merge_source(merge_source); end

  def report_module_not_found(module_name); end

  def report_module_provider_not_found(module_name); end

  def report_not_found(key); end

  def report_result(value); end

  def report_text(&block); end

  def scope(); end

  def set_global_only(); end

  def set_hiera_v3_location_overrides(overrides); end

  def set_hiera_v3_merge_behavior(); end

  def set_hiera_xxx_call(); end

  def top_key(); end

  def with(qualifier_type, qualifier); end

  def with_scope(scope); end

  def without_explain(); end
end

class Puppet::Pops::Lookup::Invocation
  def self.current(); end
end

module Puppet::Pops::Lookup::LocationResolver
  include ::Puppet::Pops::Lookup::Interpolation
  include ::Puppet::Pops::Lookup::SubLookup
  def expand_globs(datadir, declared_globs, lookup_invocation); end

  def expand_mapped_paths(datadir, mapped_path_triplet, lookup_invocation); end

  def expand_uris(declared_uris, lookup_invocation); end

  def resolve_paths(datadir, declared_paths, lookup_invocation, is_default_config, extension=T.unsafe(nil)); end
end

module Puppet::Pops::Lookup::LocationResolver
  extend ::T::Sig
end

class Puppet::Pops::Lookup::LookupAdapter
  def convert_result(key, lookup_options, lookup_invocation, the_lookup); end

  def extract_lookup_options_for_key(key, options); end

  def global_hiera_config_path(); end

  def global_only?(); end

  def has_environment_data_provider?(lookup_invocation); end

  def initialize(compiler); end

  def lookup(key, lookup_invocation, merge); end

  def lookup_default_in_module(key, lookup_invocation); end

  def lookup_global(key, lookup_invocation, merge_strategy); end

  def lookup_in_environment(key, lookup_invocation, merge_strategy); end

  def lookup_in_module(key, lookup_invocation, merge_strategy); end

  def lookup_lookup_options(key, lookup_invocation); end

  def lookup_merge_options(key, lookup_invocation); end

  def set_global_hiera_config_path(path); end

  def set_global_only(); end
  CONVERT_TO = ::T.let(nil, ::T.untyped)
  GLOBAL_ENV_MERGE = ::T.let(nil, ::T.untyped)
  HASH = ::T.let(nil, ::T.untyped)
  LOOKUP_OPTIONS_PATTERN_START = ::T.let(nil, ::T.untyped)
  LOOKUP_OPTIONS_PREFIX = ::T.let(nil, ::T.untyped)
  MERGE = ::T.let(nil, ::T.untyped)
  NEW = ::T.let(nil, ::T.untyped)
  PROVIDER_STACK = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Lookup::LookupAdapter
  def self.create_adapter(compiler); end
end

class Puppet::Pops::Lookup::LookupKey
  include ::Puppet::Pops::Lookup::SubLookup
  def ==(v); end

  def dig(lookup_invocation, value); end

  def eql?(v); end

  def initialize(key); end

  def module_name(); end

  def prune(value); end

  def root_key(); end

  def segments(); end

  def to_a(); end

  def undig(value); end
  LOOKUP_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Lookup::LookupKey
end

class Puppet::Pops::Lookup::LookupKeyFunctionProvider
  def invoke_with_location(lookup_invocation, location, root_key, merge); end

  def label(); end
  TAG = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Lookup::LookupKeyFunctionProvider
end

class Puppet::Pops::Lookup::ModuleDataProvider
  def initialize(module_name, config=T.unsafe(nil)); end

  def place(); end

  def validate_data_hash(data_hash); end
end

class Puppet::Pops::Lookup::ModuleDataProvider
end

class Puppet::Pops::Lookup::ResolvedLocation
  def exist?(); end

  def initialize(original_location, location, exist); end

  def location(); end

  def original_location(); end
end

class Puppet::Pops::Lookup::ResolvedLocation
end

class Puppet::Pops::Lookup::ScopeLookupCollectingInvocation
  def initialize(scope); end

  def remember_scope_lookup(key, root_key, segments, value); end

  def scope_interpolations(); end

  def with_local_memory_eluding(name); end
end

class Puppet::Pops::Lookup::ScopeLookupCollectingInvocation
end

module Puppet::Pops::Lookup::SubLookup
  def split_key(key); end

  def sub_lookup(key, context, segments, value); end
  SPECIAL = ::T.let(nil, ::T.untyped)
end

module Puppet::Pops::Lookup::SubLookup
  extend ::T::Sig
end

class Puppet::Pops::Lookup::V3BackendFunctionProvider
  TAG = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Lookup::V3BackendFunctionProvider
end

class Puppet::Pops::Lookup::V3DataHashFunctionProvider
  TAG = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Lookup::V3DataHashFunctionProvider
end

class Puppet::Pops::Lookup::V3LookupKeyFunctionProvider
  TAG = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Lookup::V3LookupKeyFunctionProvider
end

class Puppet::Pops::Lookup::V4DataHashFunctionProvider
  TAG = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Lookup::V4DataHashFunctionProvider
end

module Puppet::Pops::Lookup
  extend ::T::Sig
  def self.debug_preamble(names); end

  def self.lookup(name, value_type, default_value, has_default, merge, lookup_invocation); end

  def self.search_and_merge(name, lookup_invocation, merge, apl=T.unsafe(nil)); end
end

class Puppet::Pops::MergeStrategy
  def assert_type(param, type, value); end

  def checked_merge(e1, e2); end

  def configuration(); end

  def convert_value(value); end

  def initialize(options); end

  def lookup(lookup_variants, lookup_invocation); end

  def merge(e1, e2); end

  def merge_lookup(lookup_variants); end

  def merge_single(value); end

  def options(); end

  def value_t(); end
  NOT_FOUND = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::MergeStrategy
  def self.add_strategy(strategy_class); end

  def self.key(); end

  def self.merge(e1, e2, merge); end

  def self.options_t(); end

  def self.strategy(merge); end

  def self.strategy_keys(); end
end

module Puppet::Pops::Migration
end

class Puppet::Pops::Migration::MigrationChecker
  def available_migrations(); end

  def report_ambiguous_float(o); end

  def report_ambiguous_integer(o); end

  def report_array_last_in_block(o); end

  def report_empty_string_true(value, o); end

  def report_equality_type_mismatch(left, right, o); end

  def report_in_expression(o); end

  def report_option_type_mismatch(test_value, option_value, option_expr, matching_expr); end

  def report_uc_bareword_type(value, o); end
end

class Puppet::Pops::Migration::MigrationChecker
  def self.singleton(); end
end

module Puppet::Pops::Migration
  extend ::T::Sig
end

module Puppet::Pops::Model
end

class Puppet::Pops::Model::AbstractAttributeOperation
end

class Puppet::Pops::Model::AbstractAttributeOperation
end

class Puppet::Pops::Model::AbstractResource
  def exported(); end

  def form(); end

  def initialize(locator, offset, length, form=T.unsafe(nil)); end

  def virtual(); end
end

class Puppet::Pops::Model::AbstractResource
  def self.create(locator, offset, length, form=T.unsafe(nil)); end
end

class Puppet::Pops::Model::AccessExpression
  def _pcore_all_contents(path, &block); end

  def initialize(locator, offset, length, left_expr, keys=T.unsafe(nil)); end

  def keys(); end

  def left_expr(); end
end

class Puppet::Pops::Model::AccessExpression
  def self.create(locator, offset, length, left_expr, keys=T.unsafe(nil)); end
end

class Puppet::Pops::Model::AndExpression
end

class Puppet::Pops::Model::AndExpression
end

class Puppet::Pops::Model::Application
end

class Puppet::Pops::Model::Application
end

class Puppet::Pops::Model::ApplyBlockExpression
end

class Puppet::Pops::Model::ApplyBlockExpression
end

class Puppet::Pops::Model::ApplyExpression
  def _pcore_all_contents(path, &block); end

  def arguments(); end

  def body(); end

  def initialize(locator, offset, length, arguments=T.unsafe(nil), body=T.unsafe(nil)); end
end

class Puppet::Pops::Model::ApplyExpression
  def self.create(locator, offset, length, arguments=T.unsafe(nil), body=T.unsafe(nil)); end
end

class Puppet::Pops::Model::ArithmeticExpression
  def initialize(locator, offset, length, left_expr, right_expr, operator); end

  def operator(); end
end

class Puppet::Pops::Model::ArithmeticExpression
  def self.create(locator, offset, length, left_expr, right_expr, operator); end
end

class Puppet::Pops::Model::AssignmentExpression
  def initialize(locator, offset, length, left_expr, right_expr, operator); end

  def operator(); end
end

class Puppet::Pops::Model::AssignmentExpression
  def self.create(locator, offset, length, left_expr, right_expr, operator); end
end

class Puppet::Pops::Model::AstTransformer
  def ast(o, klass, hash=T.unsafe(nil)); end

  def hostname(o); end

  def hostname_Array(o); end

  def hostname_LiteralDefault(o); end

  def hostname_LiteralNumber(o); end

  def hostname_LiteralRegularExpression(o); end

  def hostname_LiteralValue(o); end

  def hostname_Object(o); end

  def hostname_QualifiedName(o); end

  def importer(); end

  def initialize(source_file=T.unsafe(nil), importer=T.unsafe(nil)); end

  def is_nop?(o); end

  def merge_location(hash, o); end

  def nil_or_empty?(x); end

  def query(o); end

  def query_Object(o); end

  def transform(o); end

  def transform_Object(o); end
end

Puppet::Pops::Model::AstTransformer::AST = Puppet::Parser::AST

Puppet::Pops::Model::AstTransformer::Model = Puppet::Pops::Model

class Puppet::Pops::Model::AstTransformer
end

class Puppet::Pops::Model::AttributeOperation
  def _pcore_all_contents(path, &block); end

  def attribute_name(); end

  def initialize(locator, offset, length, attribute_name, operator, value_expr); end

  def operator(); end

  def value_expr(); end
end

class Puppet::Pops::Model::AttributeOperation
  def self.create(locator, offset, length, attribute_name, operator, value_expr); end
end

class Puppet::Pops::Model::AttributesOperation
  def _pcore_all_contents(path, &block); end

  def expr(); end

  def initialize(locator, offset, length, expr); end
end

class Puppet::Pops::Model::AttributesOperation
  def self.create(locator, offset, length, expr); end
end

class Puppet::Pops::Model::BinaryExpression
  def _pcore_all_contents(path, &block); end

  def initialize(locator, offset, length, left_expr, right_expr); end

  def left_expr(); end

  def right_expr(); end
end

class Puppet::Pops::Model::BinaryExpression
  def self.create(locator, offset, length, left_expr, right_expr); end
end

class Puppet::Pops::Model::BlockExpression
  def _pcore_all_contents(path, &block); end

  def initialize(locator, offset, length, statements=T.unsafe(nil)); end

  def statements(); end
end

class Puppet::Pops::Model::BlockExpression
  def self.create(locator, offset, length, statements=T.unsafe(nil)); end
end

class Puppet::Pops::Model::BooleanExpression
end

class Puppet::Pops::Model::BooleanExpression
end

class Puppet::Pops::Model::CallExpression
  def _pcore_all_contents(path, &block); end

  def arguments(); end

  def functor_expr(); end

  def initialize(locator, offset, length, functor_expr, rval_required=T.unsafe(nil), arguments=T.unsafe(nil), lambda=T.unsafe(nil)); end

  def rval_required(); end
end

class Puppet::Pops::Model::CallExpression
  def self.create(locator, offset, length, functor_expr, rval_required=T.unsafe(nil), arguments=T.unsafe(nil), lambda=T.unsafe(nil)); end
end

class Puppet::Pops::Model::CallFunctionExpression
end

class Puppet::Pops::Model::CallFunctionExpression
end

class Puppet::Pops::Model::CallMethodExpression
end

class Puppet::Pops::Model::CallMethodExpression
end

class Puppet::Pops::Model::CallNamedFunctionExpression
end

class Puppet::Pops::Model::CallNamedFunctionExpression
end

class Puppet::Pops::Model::CapabilityMapping
  def _pcore_all_contents(path, &block); end

  def capability(); end

  def component(); end

  def initialize(locator, offset, length, kind, capability, component, mappings=T.unsafe(nil)); end

  def kind(); end

  def mappings(); end
end

class Puppet::Pops::Model::CapabilityMapping
  def self.create(locator, offset, length, kind, capability, component, mappings=T.unsafe(nil)); end
end

class Puppet::Pops::Model::CaseExpression
  def _pcore_all_contents(path, &block); end

  def initialize(locator, offset, length, test, options=T.unsafe(nil)); end

  def options(); end

  def test(); end
end

class Puppet::Pops::Model::CaseExpression
  def self.create(locator, offset, length, test, options=T.unsafe(nil)); end
end

class Puppet::Pops::Model::CaseOption
  def _pcore_all_contents(path, &block); end

  def initialize(locator, offset, length, values, then_expr=T.unsafe(nil)); end

  def then_expr(); end

  def values(); end
end

class Puppet::Pops::Model::CaseOption
  def self.create(locator, offset, length, values, then_expr=T.unsafe(nil)); end
end

class Puppet::Pops::Model::CollectExpression
  def _pcore_all_contents(path, &block); end

  def initialize(locator, offset, length, type_expr, query, operations=T.unsafe(nil)); end

  def operations(); end

  def query(); end

  def type_expr(); end
end

class Puppet::Pops::Model::CollectExpression
  def self.create(locator, offset, length, type_expr, query, operations=T.unsafe(nil)); end
end

class Puppet::Pops::Model::ComparisonExpression
  def initialize(locator, offset, length, left_expr, right_expr, operator); end

  def operator(); end
end

class Puppet::Pops::Model::ComparisonExpression
  def self.create(locator, offset, length, left_expr, right_expr, operator); end
end

class Puppet::Pops::Model::ConcatenatedString
  def _pcore_all_contents(path, &block); end

  def initialize(locator, offset, length, segments=T.unsafe(nil)); end

  def segments(); end
end

class Puppet::Pops::Model::ConcatenatedString
  def self.create(locator, offset, length, segments=T.unsafe(nil)); end
end

class Puppet::Pops::Model::Definition
end

class Puppet::Pops::Model::Definition
end

class Puppet::Pops::Model::EppExpression
  def _pcore_all_contents(path, &block); end

  def body(); end

  def initialize(locator, offset, length, parameters_specified=T.unsafe(nil), body=T.unsafe(nil)); end

  def parameters_specified(); end
end

class Puppet::Pops::Model::EppExpression
  def self.create(locator, offset, length, parameters_specified=T.unsafe(nil), body=T.unsafe(nil)); end
end

class Puppet::Pops::Model::ExportedQuery
end

class Puppet::Pops::Model::ExportedQuery
end

class Puppet::Pops::Model::Expression
end

class Puppet::Pops::Model::Expression
end

class Puppet::Pops::Model::Factory
  def %(r); end

  def *(r); end

  def +(r); end

  def -(r); end

  def /(r); end

  def <(r); end

  def <<(r); end

  def <=(r); end

  def =~(r); end

  def >(r); end

  def >=(r); end

  def >>(r); end

  def [](key); end

  def []=(key, value); end

  def access(r); end

  def access_at(*r); end

  def all_factories(&block); end

  def and(r); end

  def attributes(*args); end

  def build_AccessExpression(o, left, keys); end

  def build_Application(o, n, ps, body); end

  def build_ApplyExpression(o, args, body); end

  def build_ArithmeticExpression(o, op, a, b); end

  def build_AssignmentExpression(o, op, a, b); end

  def build_AttributeOperation(o, name, op, value); end

  def build_AttributesOperation(o, value); end

  def build_BinaryExpression(o, left, right); end

  def build_BlockExpression(o, args); end

  def build_CallExpression(o, functor, rval_required, args); end

  def build_CallMethodExpression(o, functor, rval_required, lambda, args); end

  def build_CapabilityMapping(o, kind, component, capability, mappings); end

  def build_CaseExpression(o, test, args); end

  def build_CaseOption(o, value_list, then_expr); end

  def build_CollectExpression(o, type_expr, query_expr, attribute_operations); end

  def build_ComparisonExpression(o, op, a, b); end

  def build_ConcatenatedString(o, args); end

  def build_EppExpression(o, parameters_specified, body); end

  def build_FunctionDefinition(o, name, parameters, body, return_type); end

  def build_HeredocExpression(o, name, expr); end

  def build_HostClassDefinition(o, name, parameters, parent_class_name, body); end

  def build_IfExpression(o, t, ift, els); end

  def build_KeyedEntry(o, k, v); end

  def build_LambdaExpression(o, parameters, body, return_type); end

  def build_LiteralFloat(o, val); end

  def build_LiteralHash(o, keyed_entries, unfolded); end

  def build_LiteralInteger(o, val, radix); end

  def build_LiteralList(o, values); end

  def build_LiteralString(o, value); end

  def build_MatchExpression(o, op, a, b); end

  def build_NamedDefinition(o, name, parameters, body); end

  def build_NodeDefinition(o, hosts, parent, body); end

  def build_Parameter(o, name, expr); end

  def build_PlanDefinition(o, name, parameters, body, return_type=T.unsafe(nil)); end

  def build_Program(o, body, definitions, locator); end

  def build_QualifiedName(o, name); end

  def build_QualifiedReference(o, name); end

  def build_QueryExpression(o, expr); end

  def build_RelationshipExpression(o, op, a, b); end

  def build_RenderStringExpression(o, string); end

  def build_ReservedWord(o, name, future); end

  def build_ResourceBody(o, title_expression, attribute_operations); end

  def build_ResourceDefaultsExpression(o, type_ref, attribute_operations); end

  def build_ResourceExpression(o, type_name, bodies); end

  def build_ResourceOverrideExpression(o, resources, attribute_operations); end

  def build_SelectorEntry(o, matching, value); end

  def build_SelectorExpression(o, left, *selectors); end

  def build_SiteDefinition(o, body); end

  def build_SubLocatedExpression(o, token, expression); end

  def build_TokenValue(o); end

  def build_TypeAlias(o, name, type_expr); end

  def build_TypeDefinition(o, name, parent, body); end

  def build_TypeMapping(o, lhs, rhs); end

  def build_UnaryExpression(o, expr); end

  def captures_rest(); end

  def contained_current(container); end

  def create_model(); end

  def current(); end

  def default(r); end

  def dot(r); end

  def eq(r); end

  def f_arithmetic(op, r); end

  def f_build_binary(klazz, left, right); end

  def f_build_binary_op(klazz, op, left, right); end

  def f_build_body(body); end

  def f_build_unary(klazz, expr); end

  def f_comparison(op, r); end

  def f_match(op, r); end

  def factory_to_model(value); end

  def in(r); end

  def infer_Array(o); end

  def infer_FalseClass(o); end

  def infer_Float(o); end

  def infer_Hash(o); end

  def infer_Integer(o); end

  def infer_NilClass(o); end

  def infer_Regexp(o); end

  def infer_String(o); end

  def infer_Symbol(o); end

  def infer_TrueClass(o); end

  def initialize(o, *args); end

  def interpolate(); end

  def interpolate_AccessExpression(c); end

  def interpolate_CallMethodExpression(c); end

  def interpolate_Factory(c); end

  def interpolate_LiteralInteger(c); end

  def interpolate_NamedAccessExpression(c); end

  def interpolate_Object(c); end

  def interpolate_QualifiedName(c); end

  def is_interop_rewriteable?(o); end

  def lambda=(lambda); end

  def length(); end

  def map_offset(model, locator); end

  def map_offset_Factory(o, locator); end

  def map_offset_Object(o, locator); end

  def map_offset_Positioned(o, locator); end

  def minus(); end

  def minus_set(r); end

  def mne(r); end

  def model(); end

  def model_class(); end

  def ne(r); end

  def not(); end

  def offset(); end

  def or(r); end

  def paren(); end

  def plus_set(r); end

  def record_position(locator, start_locatable, end_locatable); end

  def relop(op, r); end

  def select(*args); end

  def set(r); end

  def text(); end

  def type_expr(o); end

  def unfold(); end

  def unfolded(); end

  def var(); end
  BUILD_VISITOR = ::T.let(nil, ::T.untyped)
  INFER_VISITOR = ::T.let(nil, ::T.untyped)
  INTERPOLATION_VISITOR = ::T.let(nil, ::T.untyped)
  KEY_BODY = ::T.let(nil, ::T.untyped)
  KEY_EXPR = ::T.let(nil, ::T.untyped)
  KEY_KEYS = ::T.let(nil, ::T.untyped)
  KEY_LEFT_EXPR = ::T.let(nil, ::T.untyped)
  KEY_LENGTH = ::T.let(nil, ::T.untyped)
  KEY_LOCATOR = ::T.let(nil, ::T.untyped)
  KEY_NAME = ::T.let(nil, ::T.untyped)
  KEY_OFFSET = ::T.let(nil, ::T.untyped)
  KEY_OPERATOR = ::T.let(nil, ::T.untyped)
  KEY_PARAMETERS = ::T.let(nil, ::T.untyped)
  KEY_RIGHT_EXPR = ::T.let(nil, ::T.untyped)
  KEY_VALUE = ::T.let(nil, ::T.untyped)
  MAPOFFSET_VISITOR = ::T.let(nil, ::T.untyped)
  STATEMENT_CALLS = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Model::Factory::ArgsToNonCallError
  def args(); end

  def initialize(args, name_expr); end

  def name_expr(); end
end

class Puppet::Pops::Model::Factory::ArgsToNonCallError
end

class Puppet::Pops::Model::Factory
  def self.APPLICATION(name, parameters, body); end

  def self.APPLY(arguments, body); end

  def self.APPLY_BLOCK(statements); end

  def self.ARGUMENTS(args, arg); end

  def self.ATTRIBUTES_OP(expr); end

  def self.ATTRIBUTE_OP(name, op, expr); end

  def self.CALL_METHOD(functor, argument_list); end

  def self.CALL_NAMED(name, rval_required, argument_list); end

  def self.CAPABILITY_MAPPING(kind, component, cap_name, mappings); end

  def self.CASE(test_e, *options); end

  def self.COLLECT(type_expr, query_expr, attribute_operations); end

  def self.DEFINITION(name, parameters, body); end

  def self.EPP(parameters, body); end

  def self.EXPORTED_QUERY(query_expr); end

  def self.FUNCTION(name, parameters, body, return_type); end

  def self.HASH(entries); end

  def self.HASH_UNFOLDED(entries); end

  def self.HEREDOC(name, expr); end

  def self.HOSTCLASS(name, parameters, parent, body); end

  def self.IF(test_e, then_e, else_e); end

  def self.KEY_ENTRY(key, val); end

  def self.LAMBDA(parameters, body, return_type); end

  def self.LIST(entries); end

  def self.MAP(match, value); end

  def self.NAMED_ACCESS(type_name, bodies); end

  def self.NODE(hosts, parent, body); end

  def self.NUMBER(name_or_numeric); end

  def self.PARAM(name, expr=T.unsafe(nil)); end

  def self.PLAN(name, parameters, body); end

  def self.PROGRAM(body, definitions, locator); end

  def self.QNAME(name); end

  def self.QNAME_OR_NUMBER(name); end

  def self.QREF(name); end

  def self.RENDER_EXPR(expr); end

  def self.RENDER_STRING(o); end

  def self.RESERVED(name, future=T.unsafe(nil)); end

  def self.RESOURCE(type_name, bodies); end

  def self.RESOURCE_BODY(resource_title, attribute_operations); end

  def self.RESOURCE_DEFAULTS(type_name, attribute_operations); end

  def self.RESOURCE_OVERRIDE(resource_ref, attribute_operations); end

  def self.SITE(body); end

  def self.STRING(*args); end

  def self.SUBLOCATE(token, expr_factory); end

  def self.TEXT(expr); end

  def self.TYPE_ASSIGNMENT(lhs, rhs); end

  def self.TYPE_DEFINITION(name, parent, body); end

  def self.UNLESS(test_e, then_e, else_e); end

  def self.VIRTUAL_QUERY(query_expr); end

  def self.WHEN(values_list, block); end

  def self.block(*args); end

  def self.block_or_expression(args, left_brace=T.unsafe(nil), right_brace=T.unsafe(nil)); end

  def self.call_named(name, rval_required, *argument_list); end

  def self.concat(*args); end

  def self.fqn(o); end

  def self.fqr(o); end

  def self.infer(o); end

  def self.literal(o); end

  def self.minus(o); end

  def self.name_is_statement?(name); end

  def self.nop?(o); end

  def self.resource_shape(expr); end

  def self.set_resource_form(expr, form); end

  def self.string(*args); end

  def self.text(o); end

  def self.transform_calls(expressions); end

  def self.transform_resource_wo_title(left, attribute_ops, lbrace_token, rbrace_token); end

  def self.unfold(o); end

  def self.var(o); end
end

class Puppet::Pops::Model::FunctionDefinition
  def initialize(locator, offset, length, name, parameters=T.unsafe(nil), body=T.unsafe(nil), return_type=T.unsafe(nil)); end

  def return_type(); end
end

class Puppet::Pops::Model::FunctionDefinition
  def self.create(locator, offset, length, name, parameters=T.unsafe(nil), body=T.unsafe(nil), return_type=T.unsafe(nil)); end
end

class Puppet::Pops::Model::HeredocExpression
  def _pcore_all_contents(path, &block); end

  def initialize(locator, offset, length, text_expr, syntax=T.unsafe(nil)); end

  def syntax(); end

  def text_expr(); end
end

class Puppet::Pops::Model::HeredocExpression
  def self.create(locator, offset, length, text_expr, syntax=T.unsafe(nil)); end
end

class Puppet::Pops::Model::HostClassDefinition
  def initialize(locator, offset, length, name, parameters=T.unsafe(nil), body=T.unsafe(nil), parent_class=T.unsafe(nil)); end

  def parent_class(); end
end

class Puppet::Pops::Model::HostClassDefinition
  def self.create(locator, offset, length, name, parameters=T.unsafe(nil), body=T.unsafe(nil), parent_class=T.unsafe(nil)); end
end

class Puppet::Pops::Model::IfExpression
  def _pcore_all_contents(path, &block); end

  def else_expr(); end

  def initialize(locator, offset, length, test, then_expr=T.unsafe(nil), else_expr=T.unsafe(nil)); end

  def test(); end

  def then_expr(); end
end

class Puppet::Pops::Model::IfExpression
  def self.create(locator, offset, length, test, then_expr=T.unsafe(nil), else_expr=T.unsafe(nil)); end
end

class Puppet::Pops::Model::InExpression
end

class Puppet::Pops::Model::InExpression
end

class Puppet::Pops::Model::KeyedEntry
  def _pcore_all_contents(path, &block); end

  def initialize(locator, offset, length, key, value); end

  def key(); end

  def value(); end
end

class Puppet::Pops::Model::KeyedEntry
  def self.create(locator, offset, length, key, value); end
end

class Puppet::Pops::Model::LambdaExpression
  def _pcore_all_contents(path, &block); end

  def body(); end

  def initialize(locator, offset, length, parameters=T.unsafe(nil), body=T.unsafe(nil), return_type=T.unsafe(nil)); end

  def parameters(); end

  def return_type(); end
end

class Puppet::Pops::Model::LambdaExpression
  def self.create(locator, offset, length, parameters=T.unsafe(nil), body=T.unsafe(nil), return_type=T.unsafe(nil)); end
end

class Puppet::Pops::Model::Literal
end

class Puppet::Pops::Model::Literal
end

class Puppet::Pops::Model::LiteralBoolean
  def initialize(locator, offset, length, value); end

  def value(); end
end

class Puppet::Pops::Model::LiteralBoolean
  def self.create(locator, offset, length, value); end
end

class Puppet::Pops::Model::LiteralDefault
end

class Puppet::Pops::Model::LiteralDefault
end

class Puppet::Pops::Model::LiteralFloat
  def initialize(locator, offset, length, value); end

  def value(); end
end

class Puppet::Pops::Model::LiteralFloat
  def self.create(locator, offset, length, value); end
end

class Puppet::Pops::Model::LiteralHash
  def _pcore_all_contents(path, &block); end

  def entries(); end

  def initialize(locator, offset, length, entries=T.unsafe(nil)); end
end

class Puppet::Pops::Model::LiteralHash
  def self.create(locator, offset, length, entries=T.unsafe(nil)); end
end

class Puppet::Pops::Model::LiteralInteger
  def initialize(locator, offset, length, value, radix=T.unsafe(nil)); end

  def radix(); end

  def value(); end
end

class Puppet::Pops::Model::LiteralInteger
  def self.create(locator, offset, length, value, radix=T.unsafe(nil)); end
end

class Puppet::Pops::Model::LiteralList
  def _pcore_all_contents(path, &block); end

  def initialize(locator, offset, length, values=T.unsafe(nil)); end

  def values(); end
end

class Puppet::Pops::Model::LiteralList
  def self.create(locator, offset, length, values=T.unsafe(nil)); end
end

class Puppet::Pops::Model::LiteralNumber
end

class Puppet::Pops::Model::LiteralNumber
end

class Puppet::Pops::Model::LiteralRegularExpression
  def initialize(locator, offset, length, value, pattern); end

  def pattern(); end

  def value(); end
end

class Puppet::Pops::Model::LiteralRegularExpression
  def self.create(locator, offset, length, value, pattern); end
end

class Puppet::Pops::Model::LiteralString
  def initialize(locator, offset, length, value); end

  def value(); end
end

class Puppet::Pops::Model::LiteralString
  def self.create(locator, offset, length, value); end
end

class Puppet::Pops::Model::LiteralUndef
end

class Puppet::Pops::Model::LiteralUndef
end

class Puppet::Pops::Model::LiteralValue
end

class Puppet::Pops::Model::LiteralValue
end

class Puppet::Pops::Model::MatchExpression
  def initialize(locator, offset, length, left_expr, right_expr, operator); end

  def operator(); end
end

class Puppet::Pops::Model::MatchExpression
  def self.create(locator, offset, length, left_expr, right_expr, operator); end
end

class Puppet::Pops::Model::ModelLabelProvider
  include ::Puppet::Pops::LabelProvider
  def label_AccessExpression(o); end

  def label_AndExpression(o); end

  def label_Application(o); end

  def label_ApplyBlockExpression(o); end

  def label_ApplyExpression(o); end

  def label_ArithmeticExpression(o); end

  def label_Array(o); end

  def label_AssignmentExpression(o); end

  def label_AttributeOperation(o); end

  def label_Bignum(o); end

  def label_Binary(o); end

  def label_BlockExpression(o); end

  def label_CallMethodExpression(o); end

  def label_CallNamedFunctionExpression(o); end

  def label_CapabilityMapping(o); end

  def label_CaseExpression(o); end

  def label_CaseOption(o); end

  def label_CatalogCollector(o); end

  def label_Class(o); end

  def label_CollectExpression(o); end

  def label_ComparisonExpression(o); end

  def label_ConcatenatedString(o); end

  def label_EppExpression(o); end

  def label_ExportedCollector(o); end

  def label_ExportedQuery(o); end

  def label_Factory(o); end

  def label_FalseClass(o); end

  def label_Fixnum(o); end

  def label_Float(o); end

  def label_FunctionDefinition(o); end

  def label_Hash(o); end

  def label_HeredocExpression(o); end

  def label_HostClassDefinition(o); end

  def label_IfExpression(o); end

  def label_InExpression(o); end

  def label_Integer(o); end

  def label_KeyedEntry(o); end

  def label_LambdaExpression(o); end

  def label_LiteralBoolean(o); end

  def label_LiteralDefault(o); end

  def label_LiteralFloat(o); end

  def label_LiteralHash(o); end

  def label_LiteralInteger(o); end

  def label_LiteralList(o); end

  def label_LiteralRegularExpression(o); end

  def label_LiteralString(o); end

  def label_LiteralUndef(o); end

  def label_MatchExpression(o); end

  def label_NamedAccessExpression(o); end

  def label_NilClass(o); end

  def label_NodeDefinition(o); end

  def label_Nop(o); end

  def label_NotExpression(o); end

  def label_Object(o); end

  def label_OrExpression(o); end

  def label_PAnyType(o); end

  def label_PResourceType(o); end

  def label_Parameter(o); end

  def label_ParenthesizedExpression(o); end

  def label_PlanDefinition(o); end

  def label_QualifiedName(o); end

  def label_QualifiedReference(o); end

  def label_QueryExpression(o); end

  def label_Regexp(o); end

  def label_RelationshipExpression(o); end

  def label_RenderExpression(o); end

  def label_RenderStringExpression(o); end

  def label_ReservedWord(o); end

  def label_Resource(o); end

  def label_ResourceBody(o); end

  def label_ResourceDefaultsExpression(o); end

  def label_ResourceExpression(o); end

  def label_ResourceOverrideExpression(o); end

  def label_ResourceTypeDefinition(o); end

  def label_SelectorEntry(o); end

  def label_SelectorExpression(o); end

  def label_Sensitive(o); end

  def label_SiteDefinition(o); end

  def label_String(o); end

  def label_TextExpression(o); end

  def label_Timespan(o); end

  def label_Timestamp(o); end

  def label_TrueClass(o); end

  def label_TypeAlias(o); end

  def label_TypeDefinition(o); end

  def label_TypeMapping(o); end

  def label_UnaryMinusExpression(o); end

  def label_UnfoldExpression(o); end

  def label_UnlessExpression(o); end

  def label_VariableExpression(o); end

  def label_Version(o); end

  def label_VersionRange(o); end

  def label_VirtualQuery(o); end
end

class Puppet::Pops::Model::ModelLabelProvider
end

class Puppet::Pops::Model::ModelTreeDumper
  def dump_AccessExpression(o); end

  def dump_AndExpression(o); end

  def dump_Application(o); end

  def dump_ArithmeticExpression(o); end

  def dump_Array(o); end

  def dump_AssignmentExpression(o); end

  def dump_AttributeOperation(o); end

  def dump_AttributesOperation(o); end

  def dump_BlockExpression(o); end

  def dump_CallMethodExpression(o); end

  def dump_CallNamedFunctionExpression(o); end

  def dump_CapabilityMapping(o); end

  def dump_CaseExpression(o); end

  def dump_CaseOption(o); end

  def dump_CollectExpression(o); end

  def dump_ComparisonExpression(o); end

  def dump_ConcatenatedString(o); end

  def dump_EppExpression(o); end

  def dump_ExportedQuery(o); end

  def dump_Factory(o); end

  def dump_FunctionDefinition(o); end

  def dump_HeredocExpression(o); end

  def dump_HostClassDefinition(o); end

  def dump_IfExpression(o); end

  def dump_InExpression(o); end

  def dump_KeyedEntry(o); end

  def dump_LambdaExpression(o); end

  def dump_LiteralDefault(o); end

  def dump_LiteralFloat(o); end

  def dump_LiteralHash(o); end

  def dump_LiteralInteger(o); end

  def dump_LiteralList(o); end

  def dump_LiteralRegularExpression(o); end

  def dump_LiteralString(o); end

  def dump_LiteralUndef(o); end

  def dump_LiteralValue(o); end

  def dump_MatchExpression(o); end

  def dump_MatchesExpression(o); end

  def dump_NamedAccessExpression(o); end

  def dump_NamedDefinition(o); end

  def dump_NilClass(o); end

  def dump_NodeDefinition(o); end

  def dump_Nop(o); end

  def dump_NotExpression(o); end

  def dump_Object(o); end

  def dump_OrExpression(o); end

  def dump_Parameter(o); end

  def dump_ParenthesizedExpression(o); end

  def dump_PlanDefinition(o); end

  def dump_Program(o); end

  def dump_QualifiedReference(o); end

  def dump_QueryExpression(o); end

  def dump_RelationshipExpression(o); end

  def dump_RenderExpression(o); end

  def dump_RenderStringExpression(o); end

  def dump_ReservedWord(o); end

  def dump_ResourceBody(o); end

  def dump_ResourceDefaultsExpression(o); end

  def dump_ResourceExpression(o); end

  def dump_ResourceOverrideExpression(o); end

  def dump_ResourceTypeDefinition(o); end

  def dump_SelectorEntry(o); end

  def dump_SelectorExpression(o); end

  def dump_SiteDefinition(o); end

  def dump_SubLocatedExpression(o); end

  def dump_TextExpression(o); end

  def dump_TypeAlias(o); end

  def dump_TypeDefinition(o); end

  def dump_TypeMapping(o); end

  def dump_UnaryMinusExpression(o); end

  def dump_UnfoldExpression(o); end

  def dump_UnlessExpression(o); end

  def dump_VariableExpression(o); end

  def dump_VirtualQuery(o); end
end

class Puppet::Pops::Model::ModelTreeDumper
end

class Puppet::Pops::Model::NamedAccessExpression
end

class Puppet::Pops::Model::NamedAccessExpression
end

class Puppet::Pops::Model::NamedDefinition
  def _pcore_all_contents(path, &block); end

  def body(); end

  def initialize(locator, offset, length, name, parameters=T.unsafe(nil), body=T.unsafe(nil)); end

  def name(); end

  def parameters(); end
end

class Puppet::Pops::Model::NamedDefinition
  def self.create(locator, offset, length, name, parameters=T.unsafe(nil), body=T.unsafe(nil)); end
end

class Puppet::Pops::Model::NodeDefinition
  def _pcore_all_contents(path, &block); end

  def body(); end

  def host_matches(); end

  def initialize(locator, offset, length, host_matches, parent=T.unsafe(nil), body=T.unsafe(nil)); end

  def parent(); end
end

class Puppet::Pops::Model::NodeDefinition
  def self.create(locator, offset, length, host_matches, parent=T.unsafe(nil), body=T.unsafe(nil)); end
end

class Puppet::Pops::Model::Nop
end

class Puppet::Pops::Model::Nop
end

class Puppet::Pops::Model::NotExpression
end

class Puppet::Pops::Model::NotExpression
end

class Puppet::Pops::Model::OrExpression
end

class Puppet::Pops::Model::OrExpression
end

class Puppet::Pops::Model::Parameter
  def _pcore_all_contents(path, &block); end

  def captures_rest(); end

  def initialize(locator, offset, length, name, value=T.unsafe(nil), type_expr=T.unsafe(nil), captures_rest=T.unsafe(nil)); end

  def name(); end

  def type_expr(); end

  def value(); end
end

class Puppet::Pops::Model::Parameter
  def self.create(locator, offset, length, name, value=T.unsafe(nil), type_expr=T.unsafe(nil), captures_rest=T.unsafe(nil)); end
end

class Puppet::Pops::Model::ParenthesizedExpression
end

class Puppet::Pops::Model::ParenthesizedExpression
end

class Puppet::Pops::Model::PlanDefinition
end

class Puppet::Pops::Model::PlanDefinition
end

class Puppet::Pops::Model::PopsObject
  include ::Puppet::Pops::Types::PuppetObject
  def ==(o); end

  def _pcore_all_contents(path); end

  def eql?(o); end
end

class Puppet::Pops::Model::PopsObject
  def self._pcore_type(); end

  def self.create(); end

  def self.from_asserted_hash(init_hash); end

  def self.from_hash(init_hash); end
end

class Puppet::Pops::Model::Positioned
  def file(); end

  def initialize(locator, offset, length); end

  def length(); end

  def line(); end

  def locator(); end

  def offset(); end

  def pos(); end
end

class Puppet::Pops::Model::Positioned
  def self.create(locator, offset, length); end
end

class Puppet::Pops::Model::Program
  def _pcore_all_contents(path, &block); end

  def body(); end

  def current(); end

  def definitions(); end

  def initialize(locator, body=T.unsafe(nil), definitions=T.unsafe(nil)); end

  def line_offsets(); end

  def locator(); end

  def source_ref(); end

  def source_text(); end
end

class Puppet::Pops::Model::Program
  def self.create(locator, body=T.unsafe(nil), definitions=T.unsafe(nil)); end
end

class Puppet::Pops::Model::QRefDefinition
  def initialize(locator, offset, length, name); end

  def name(); end
end

class Puppet::Pops::Model::QRefDefinition
  def self.create(locator, offset, length, name); end
end

class Puppet::Pops::Model::QualifiedName
  def initialize(locator, offset, length, value); end

  def value(); end
end

class Puppet::Pops::Model::QualifiedName
  def self.create(locator, offset, length, value); end
end

class Puppet::Pops::Model::QualifiedReference
  def cased_value(); end

  def initialize(locator, offset, length, cased_value); end

  def value(); end
end

class Puppet::Pops::Model::QualifiedReference
  def self.create(locator, offset, length, cased_value); end
end

class Puppet::Pops::Model::QueryExpression
  def _pcore_all_contents(path, &block); end

  def expr(); end

  def initialize(locator, offset, length, expr=T.unsafe(nil)); end
end

class Puppet::Pops::Model::QueryExpression
  def self.create(locator, offset, length, expr=T.unsafe(nil)); end
end

class Puppet::Pops::Model::RelationshipExpression
  def initialize(locator, offset, length, left_expr, right_expr, operator); end

  def operator(); end
end

class Puppet::Pops::Model::RelationshipExpression
  def self.create(locator, offset, length, left_expr, right_expr, operator); end
end

class Puppet::Pops::Model::RenderExpression
end

class Puppet::Pops::Model::RenderExpression
end

class Puppet::Pops::Model::RenderStringExpression
end

class Puppet::Pops::Model::RenderStringExpression
end

class Puppet::Pops::Model::ReservedWord
  def future(); end

  def initialize(locator, offset, length, word, future=T.unsafe(nil)); end

  def word(); end
end

class Puppet::Pops::Model::ReservedWord
  def self.create(locator, offset, length, word, future=T.unsafe(nil)); end
end

class Puppet::Pops::Model::ResourceBody
  def _pcore_all_contents(path, &block); end

  def initialize(locator, offset, length, title=T.unsafe(nil), operations=T.unsafe(nil)); end

  def operations(); end

  def title(); end
end

class Puppet::Pops::Model::ResourceBody
  def self.create(locator, offset, length, title=T.unsafe(nil), operations=T.unsafe(nil)); end
end

class Puppet::Pops::Model::ResourceDefaultsExpression
  def _pcore_all_contents(path, &block); end

  def initialize(locator, offset, length, form=T.unsafe(nil), type_ref=T.unsafe(nil), operations=T.unsafe(nil)); end

  def operations(); end

  def type_ref(); end
end

class Puppet::Pops::Model::ResourceDefaultsExpression
  def self.create(locator, offset, length, form=T.unsafe(nil), type_ref=T.unsafe(nil), operations=T.unsafe(nil)); end
end

class Puppet::Pops::Model::ResourceExpression
  def _pcore_all_contents(path, &block); end

  def bodies(); end

  def initialize(locator, offset, length, type_name, form=T.unsafe(nil), bodies=T.unsafe(nil)); end

  def type_name(); end
end

class Puppet::Pops::Model::ResourceExpression
  def self.create(locator, offset, length, type_name, form=T.unsafe(nil), bodies=T.unsafe(nil)); end
end

class Puppet::Pops::Model::ResourceOverrideExpression
  def _pcore_all_contents(path, &block); end

  def initialize(locator, offset, length, resources, form=T.unsafe(nil), operations=T.unsafe(nil)); end

  def operations(); end

  def resources(); end
end

class Puppet::Pops::Model::ResourceOverrideExpression
  def self.create(locator, offset, length, resources, form=T.unsafe(nil), operations=T.unsafe(nil)); end
end

class Puppet::Pops::Model::ResourceTypeDefinition
end

class Puppet::Pops::Model::ResourceTypeDefinition
end

class Puppet::Pops::Model::SelectorEntry
  def _pcore_all_contents(path, &block); end

  def initialize(locator, offset, length, matching_expr, value_expr); end

  def matching_expr(); end

  def value_expr(); end
end

class Puppet::Pops::Model::SelectorEntry
  def self.create(locator, offset, length, matching_expr, value_expr); end
end

class Puppet::Pops::Model::SelectorExpression
  def _pcore_all_contents(path, &block); end

  def initialize(locator, offset, length, left_expr, selectors=T.unsafe(nil)); end

  def left_expr(); end

  def selectors(); end
end

class Puppet::Pops::Model::SelectorExpression
  def self.create(locator, offset, length, left_expr, selectors=T.unsafe(nil)); end
end

class Puppet::Pops::Model::SiteDefinition
  def _pcore_all_contents(path, &block); end

  def body(); end

  def initialize(locator, offset, length, body=T.unsafe(nil)); end
end

class Puppet::Pops::Model::SiteDefinition
  def self.create(locator, offset, length, body=T.unsafe(nil)); end
end

class Puppet::Pops::Model::SubLocatedExpression
  def _pcore_all_contents(path, &block); end

  def expr(); end

  def initialize(locator, offset, length, expr, line_offsets=T.unsafe(nil), leading_line_count=T.unsafe(nil), leading_line_offset=T.unsafe(nil)); end

  def leading_line_count(); end

  def leading_line_offset(); end

  def line_offsets(); end
end

class Puppet::Pops::Model::SubLocatedExpression
  def self.create(locator, offset, length, expr, line_offsets=T.unsafe(nil), leading_line_count=T.unsafe(nil), leading_line_offset=T.unsafe(nil)); end
end

class Puppet::Pops::Model::TextExpression
end

class Puppet::Pops::Model::TextExpression
end

class Puppet::Pops::Model::TreeDumper
  def do_dump(o); end

  def dump(o); end

  def format(x); end

  def format_r(x); end

  def indent(); end

  def indent_count(); end

  def indent_count=(indent_count); end

  def initialize(initial_indentation=T.unsafe(nil)); end

  def is_nop?(o); end
end

class Puppet::Pops::Model::TreeDumper
end

class Puppet::Pops::Model::TypeAlias
  def _pcore_all_contents(path, &block); end

  def initialize(locator, offset, length, name, type_expr=T.unsafe(nil)); end

  def type_expr(); end
end

class Puppet::Pops::Model::TypeAlias
  def self.create(locator, offset, length, name, type_expr=T.unsafe(nil)); end
end

class Puppet::Pops::Model::TypeDefinition
  def _pcore_all_contents(path, &block); end

  def body(); end

  def initialize(locator, offset, length, name, parent=T.unsafe(nil), body=T.unsafe(nil)); end

  def parent(); end
end

class Puppet::Pops::Model::TypeDefinition
  def self.create(locator, offset, length, name, parent=T.unsafe(nil), body=T.unsafe(nil)); end
end

class Puppet::Pops::Model::TypeMapping
  def _pcore_all_contents(path, &block); end

  def initialize(locator, offset, length, type_expr=T.unsafe(nil), mapping_expr=T.unsafe(nil)); end

  def mapping_expr(); end

  def type_expr(); end
end

class Puppet::Pops::Model::TypeMapping
  def self.create(locator, offset, length, type_expr=T.unsafe(nil), mapping_expr=T.unsafe(nil)); end
end

class Puppet::Pops::Model::UnaryExpression
  def _pcore_all_contents(path, &block); end

  def expr(); end

  def initialize(locator, offset, length, expr); end
end

class Puppet::Pops::Model::UnaryExpression
  def self.create(locator, offset, length, expr); end
end

class Puppet::Pops::Model::UnaryMinusExpression
end

class Puppet::Pops::Model::UnaryMinusExpression
end

class Puppet::Pops::Model::UnfoldExpression
end

class Puppet::Pops::Model::UnfoldExpression
end

class Puppet::Pops::Model::UnlessExpression
end

class Puppet::Pops::Model::UnlessExpression
end

class Puppet::Pops::Model::VariableExpression
end

class Puppet::Pops::Model::VariableExpression
end

class Puppet::Pops::Model::VirtualQuery
end

class Puppet::Pops::Model::VirtualQuery
end

module Puppet::Pops::Model
  extend ::T::Sig
  def self.register_pcore_types(); end
end

module Puppet::Pops::Parser
end

class Puppet::Pops::Parser::CodeMerger
  def concatenate(parse_results); end
end

class Puppet::Pops::Parser::CodeMerger
end

class Puppet::Pops::Parser::EppParser
  def initvars(); end
end

class Puppet::Pops::Parser::EppParser
end

module Puppet::Pops::Parser::EppSupport
  def fullscan_epp(); end

  def interpolate_epp(skip_leading=T.unsafe(nil)); end

  def scan_epp(); end
  TOKEN_RENDER_EXPR = ::T.let(nil, ::T.untyped)
  TOKEN_RENDER_STRING = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Parser::EppSupport::EppScanner
  def initialize(scanner); end

  def issue(); end

  def message(); end

  def mode(); end

  def scan(skip_leading=T.unsafe(nil)); end

  def scanner(); end

  def skip_leading(); end
end

class Puppet::Pops::Parser::EppSupport::EppScanner
end

module Puppet::Pops::Parser::EppSupport
  extend ::T::Sig
end

class Puppet::Pops::Parser::EvaluatingParser
  def acceptor(); end

  def assert_and_report(parse_result); end

  def clear(); end

  def closure(model, scope); end

  def convert_to_3x(object, scope); end

  def evaluate(scope, model); end

  def evaluate_expression_with_bindings(scope, variable_bindings, expression); end

  def evaluate_file(scope, file); end

  def evaluate_string(scope, s, file_source=T.unsafe(nil)); end

  def evaluator(); end

  def parse_file(file); end

  def parse_string(s, file_source=T.unsafe(nil)); end

  def parser(); end

  def quote(x); end

  def validate(parse_result); end

  def validator(acceptor); end
end

class Puppet::Pops::Parser::EvaluatingParser::EvaluatingEppParser
end

class Puppet::Pops::Parser::EvaluatingParser::EvaluatingEppParser
end

class Puppet::Pops::Parser::EvaluatingParser
  def self.quote(x); end

  def self.singleton(); end
end

module Puppet::Pops::Parser::HeredocSupport
  include ::Puppet::Pops::Parser::LexerSupport
  def heredoc(); end

  def heredoc_text(lines, leading, has_margin, remove_break); end
  PATTERN_HEREDOC = ::T.let(nil, ::T.untyped)
end

module Puppet::Pops::Parser::HeredocSupport
  extend ::T::Sig
end

module Puppet::Pops::Parser::InterpolationSupport
  def enqueue_until(brace_count); end

  def interpolate_dq(); end

  def interpolate_tail_dq(); end

  def interpolate_tail_uq(); end

  def interpolate_uq(); end

  def interpolate_uq_to(lexer); end

  def transform_to_variable(token); end
  PATTERN_VARIABLE = ::T.let(nil, ::T.untyped)
end

module Puppet::Pops::Parser::InterpolationSupport
  extend ::T::Sig
end

class Puppet::Pops::Parser::Lexer2
  include ::Puppet::Pops::Parser::HeredocSupport
  include ::Puppet::Pops::Parser::InterpolationSupport
  include ::Puppet::Pops::Parser::SlurpSupport
  include ::Puppet::Pops::Parser::LexerSupport
  include ::Puppet::Pops::Parser::EppSupport
  def clear(); end

  def emit(token, byte_offset); end

  def emit_completed(token, byte_offset); end

  def enqueue(emitted_token); end

  def enqueue_completed(token, byte_offset); end

  def escaped_end(value); end

  def file(); end

  def file=(file); end

  def fullscan(); end

  def initvars(); end

  def lex_file(file); end

  def lex_string(string, path=T.unsafe(nil)); end

  def lex_token(); end

  def lex_unquoted_string(string, locator, escapes, interpolate); end

  def locator(); end

  def regexp_acceptable?(); end

  def scan(); end

  def string=(string); end
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORD_NAMES = ::T.let(nil, ::T.untyped)
  PATTERN_BARE_WORD = ::T.let(nil, ::T.untyped)
  PATTERN_CLASSREF = ::T.let(nil, ::T.untyped)
  PATTERN_COMMENT = ::T.let(nil, ::T.untyped)
  PATTERN_DOLLAR_VAR = ::T.let(nil, ::T.untyped)
  PATTERN_MLCOMMENT = ::T.let(nil, ::T.untyped)
  PATTERN_NAME = ::T.let(nil, ::T.untyped)
  PATTERN_NON_WS = ::T.let(nil, ::T.untyped)
  PATTERN_NUMBER = ::T.let(nil, ::T.untyped)
  PATTERN_REGEX = ::T.let(nil, ::T.untyped)
  PATTERN_REGEX_A = ::T.let(nil, ::T.untyped)
  PATTERN_REGEX_END = ::T.let(nil, ::T.untyped)
  PATTERN_REGEX_ESC = ::T.let(nil, ::T.untyped)
  PATTERN_REGEX_Z = ::T.let(nil, ::T.untyped)
  PATTERN_WS = ::T.let(nil, ::T.untyped)
  STRING_BSLASH_SLASH = ::T.let(nil, ::T.untyped)
  TOKEN_APPENDS = ::T.let(nil, ::T.untyped)
  TOKEN_AT = ::T.let(nil, ::T.untyped)
  TOKEN_ATAT = ::T.let(nil, ::T.untyped)
  TOKEN_COLON = ::T.let(nil, ::T.untyped)
  TOKEN_COMMA = ::T.let(nil, ::T.untyped)
  TOKEN_DELETES = ::T.let(nil, ::T.untyped)
  TOKEN_DIV = ::T.let(nil, ::T.untyped)
  TOKEN_DOT = ::T.let(nil, ::T.untyped)
  TOKEN_DQMID = ::T.let(nil, ::T.untyped)
  TOKEN_DQPOS = ::T.let(nil, ::T.untyped)
  TOKEN_DQPRE = ::T.let(nil, ::T.untyped)
  TOKEN_EPPEND = ::T.let(nil, ::T.untyped)
  TOKEN_EPPEND_TRIM = ::T.let(nil, ::T.untyped)
  TOKEN_EPPSTART = ::T.let(nil, ::T.untyped)
  TOKEN_EQUALS = ::T.let(nil, ::T.untyped)
  TOKEN_FARROW = ::T.let(nil, ::T.untyped)
  TOKEN_GREATEREQUAL = ::T.let(nil, ::T.untyped)
  TOKEN_GREATERTHAN = ::T.let(nil, ::T.untyped)
  TOKEN_HEREDOC = ::T.let(nil, ::T.untyped)
  TOKEN_IN_EDGE = ::T.let(nil, ::T.untyped)
  TOKEN_IN_EDGE_SUB = ::T.let(nil, ::T.untyped)
  TOKEN_ISEQUAL = ::T.let(nil, ::T.untyped)
  TOKEN_LBRACE = ::T.let(nil, ::T.untyped)
  TOKEN_LBRACK = ::T.let(nil, ::T.untyped)
  TOKEN_LCOLLECT = ::T.let(nil, ::T.untyped)
  TOKEN_LESSEQUAL = ::T.let(nil, ::T.untyped)
  TOKEN_LESSTHAN = ::T.let(nil, ::T.untyped)
  TOKEN_LISTSTART = ::T.let(nil, ::T.untyped)
  TOKEN_LLCOLLECT = ::T.let(nil, ::T.untyped)
  TOKEN_LPAREN = ::T.let(nil, ::T.untyped)
  TOKEN_LSHIFT = ::T.let(nil, ::T.untyped)
  TOKEN_MATCH = ::T.let(nil, ::T.untyped)
  TOKEN_MINUS = ::T.let(nil, ::T.untyped)
  TOKEN_MODULO = ::T.let(nil, ::T.untyped)
  TOKEN_NOMATCH = ::T.let(nil, ::T.untyped)
  TOKEN_NOT = ::T.let(nil, ::T.untyped)
  TOKEN_NOTEQUAL = ::T.let(nil, ::T.untyped)
  TOKEN_NUMBER = ::T.let(nil, ::T.untyped)
  TOKEN_OTHER = ::T.let(nil, ::T.untyped)
  TOKEN_OUT_EDGE = ::T.let(nil, ::T.untyped)
  TOKEN_OUT_EDGE_SUB = ::T.let(nil, ::T.untyped)
  TOKEN_PARROW = ::T.let(nil, ::T.untyped)
  TOKEN_PIPE = ::T.let(nil, ::T.untyped)
  TOKEN_PLUS = ::T.let(nil, ::T.untyped)
  TOKEN_QMARK = ::T.let(nil, ::T.untyped)
  TOKEN_RBRACE = ::T.let(nil, ::T.untyped)
  TOKEN_RBRACK = ::T.let(nil, ::T.untyped)
  TOKEN_RCOLLECT = ::T.let(nil, ::T.untyped)
  TOKEN_REGEXP = ::T.let(nil, ::T.untyped)
  TOKEN_RPAREN = ::T.let(nil, ::T.untyped)
  TOKEN_RRCOLLECT = ::T.let(nil, ::T.untyped)
  TOKEN_RSHIFT = ::T.let(nil, ::T.untyped)
  TOKEN_SELBRACE = ::T.let(nil, ::T.untyped)
  TOKEN_SEMIC = ::T.let(nil, ::T.untyped)
  TOKEN_STRING = ::T.let(nil, ::T.untyped)
  TOKEN_TILDE = ::T.let(nil, ::T.untyped)
  TOKEN_TIMES = ::T.let(nil, ::T.untyped)
  TOKEN_VARIABLE = ::T.let(nil, ::T.untyped)
  TOKEN_VARIABLE_EMPTY = ::T.let(nil, ::T.untyped)
  TOKEN_WORD = ::T.let(nil, ::T.untyped)
  TOKEN_WSLPAREN = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Parser::Lexer2
end

module Puppet::Pops::Parser::LexerSupport
  def assert_not_bom(content); end

  def assert_numeric(value, pos); end

  def create_lex_error(issue, args=T.unsafe(nil), pos=T.unsafe(nil)); end

  def filename(); end

  def followed_by(); end

  def format_quote(q); end

  def get_bom(content); end

  def lex_error(issue, args=T.unsafe(nil), pos=T.unsafe(nil)); end

  def lex_error_without_pos(issue, args=T.unsafe(nil)); end

  def lex_warning(issue, args=T.unsafe(nil), pos=T.unsafe(nil)); end

  def line(pos); end

  def position(pos); end
  BOM_BOCU = ::T.let(nil, ::T.untyped)
  BOM_GB_18030 = ::T.let(nil, ::T.untyped)
  BOM_SCSU = ::T.let(nil, ::T.untyped)
  BOM_UTF_1 = ::T.let(nil, ::T.untyped)
  BOM_UTF_16_1 = ::T.let(nil, ::T.untyped)
  BOM_UTF_16_2 = ::T.let(nil, ::T.untyped)
  BOM_UTF_32_1 = ::T.let(nil, ::T.untyped)
  BOM_UTF_32_2 = ::T.let(nil, ::T.untyped)
  BOM_UTF_8 = ::T.let(nil, ::T.untyped)
  BOM_UTF_EBCDIC = ::T.let(nil, ::T.untyped)
  LONGEST_BOM = ::T.let(nil, ::T.untyped)
  MM_ANY = ::T.let(nil, ::T.untyped)
end

Puppet::Pops::Parser::LexerSupport::MM = Puppet::Util::MultiMatch

class Puppet::Pops::Parser::LexerSupport::TokenValue
  def [](key); end

  def initialize(token_array, offset, locator); end

  def locator(); end

  def token_array(); end
end

class Puppet::Pops::Parser::LexerSupport::TokenValue
end

module Puppet::Pops::Parser::LexerSupport
  extend ::T::Sig
end

class Puppet::Pops::Parser::Locatable
  def length(); end

  def offset(); end
end

class Puppet::Pops::Parser::Locatable::Fixed
  def initialize(offset, length); end
end

class Puppet::Pops::Parser::Locatable::Fixed
end

class Puppet::Pops::Parser::Locatable
end

class Puppet::Pops::Parser::Locator
  def char_length(offset, end_offset); end

  def char_offset(byte_offset); end

  def extract_text(offset, length); end

  def extract_tree_text(ast); end

  def file(); end

  def line_for_offset(offset); end

  def line_index(); end

  def offset_on_line(offset); end

  def pos_on_line(offset); end

  def string(); end

  def to_uri(ast); end
end

class Puppet::Pops::Parser::Locator::AbstractLocator
  def ary_bsearch_i(ary, value); end

  def eql?(o); end

  def initialize(string, file, line_index=T.unsafe(nil)); end

  def line_index=(line_index); end

  def to_location_hash(reported_offset, end_offset); end
end

class Puppet::Pops::Parser::Locator::AbstractLocator
end

class Puppet::Pops::Parser::Locator::Locator19
  include ::Puppet::Pops::Types::PuppetObject
end

class Puppet::Pops::Parser::Locator::Locator19
  def self._pcore_type(); end
end

class Puppet::Pops::Parser::Locator::LocatorForChars
  def char_offset(char_offset); end
end

class Puppet::Pops::Parser::Locator::LocatorForChars
end

class Puppet::Pops::Parser::Locator::SubLocator
  def char_offset(offset); end

  def has_margin(); end

  def initialize(locator, str, leading_line_count, leading_offset, has_margin, margin_per_line); end

  def leading_line_count(); end

  def leading_offset(); end

  def locator(); end

  def margin_per_line(); end

  def to_global(offset, length); end
end

class Puppet::Pops::Parser::Locator::SubLocator
end

class Puppet::Pops::Parser::Locator
  def self.compute_line_index(string); end

  def self.locator(string, file, index=T.unsafe(nil), char_offsets=T.unsafe(nil)); end
end

class Puppet::Pops::Parser::Parser
  def _parse(); end

  def _reduce_1(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_109(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_110(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_113(val, _values, result); end

  def _reduce_114(val, _values, result); end

  def _reduce_115(val, _values, result); end

  def _reduce_116(val, _values, result); end

  def _reduce_117(val, _values, result); end

  def _reduce_118(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_120(val, _values, result); end

  def _reduce_121(val, _values, result); end

  def _reduce_122(val, _values, result); end

  def _reduce_123(val, _values, result); end

  def _reduce_124(val, _values, result); end

  def _reduce_126(val, _values, result); end

  def _reduce_127(val, _values, result); end

  def _reduce_128(val, _values, result); end

  def _reduce_129(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_130(val, _values, result); end

  def _reduce_131(val, _values, result); end

  def _reduce_135(val, _values, result); end

  def _reduce_136(val, _values, result); end

  def _reduce_137(val, _values, result); end

  def _reduce_138(val, _values, result); end

  def _reduce_139(val, _values, result); end

  def _reduce_140(val, _values, result); end

  def _reduce_141(val, _values, result); end

  def _reduce_142(val, _values, result); end

  def _reduce_145(val, _values, result); end

  def _reduce_146(val, _values, result); end

  def _reduce_147(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_150(val, _values, result); end

  def _reduce_151(val, _values, result); end

  def _reduce_152(val, _values, result); end

  def _reduce_153(val, _values, result); end

  def _reduce_154(val, _values, result); end

  def _reduce_155(val, _values, result); end

  def _reduce_156(val, _values, result); end

  def _reduce_159(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_160(val, _values, result); end

  def _reduce_161(val, _values, result); end

  def _reduce_162(val, _values, result); end

  def _reduce_163(val, _values, result); end

  def _reduce_167(val, _values, result); end

  def _reduce_17(val, _values, result); end

  def _reduce_170(val, _values, result); end

  def _reduce_171(val, _values, result); end

  def _reduce_172(val, _values, result); end

  def _reduce_173(val, _values, result); end

  def _reduce_174(val, _values, result); end

  def _reduce_175(val, _values, result); end

  def _reduce_178(val, _values, result); end

  def _reduce_180(val, _values, result); end

  def _reduce_181(val, _values, result); end

  def _reduce_185(val, _values, result); end

  def _reduce_186(val, _values, result); end

  def _reduce_187(val, _values, result); end

  def _reduce_188(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_193(val, _values, result); end

  def _reduce_194(val, _values, result); end

  def _reduce_195(val, _values, result); end

  def _reduce_196(val, _values, result); end

  def _reduce_197(val, _values, result); end

  def _reduce_198(val, _values, result); end

  def _reduce_199(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_200(val, _values, result); end

  def _reduce_201(val, _values, result); end

  def _reduce_206(val, _values, result); end

  def _reduce_207(val, _values, result); end

  def _reduce_208(val, _values, result); end

  def _reduce_209(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_210(val, _values, result); end

  def _reduce_211(val, _values, result); end

  def _reduce_212(val, _values, result); end

  def _reduce_213(val, _values, result); end

  def _reduce_214(val, _values, result); end

  def _reduce_215(val, _values, result); end

  def _reduce_216(val, _values, result); end

  def _reduce_217(val, _values, result); end

  def _reduce_218(val, _values, result); end

  def _reduce_219(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_220(val, _values, result); end

  def _reduce_221(val, _values, result); end

  def _reduce_222(val, _values, result); end

  def _reduce_223(val, _values, result); end

  def _reduce_224(val, _values, result); end

  def _reduce_225(val, _values, result); end

  def _reduce_226(val, _values, result); end

  def _reduce_227(val, _values, result); end

  def _reduce_228(val, _values, result); end

  def _reduce_229(val, _values, result); end

  def _reduce_230(val, _values, result); end

  def _reduce_231(val, _values, result); end

  def _reduce_232(val, _values, result); end

  def _reduce_234(val, _values, result); end

  def _reduce_236(val, _values, result); end

  def _reduce_237(val, _values, result); end

  def _reduce_238(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_248(val, _values, result); end

  def _reduce_249(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_250(val, _values, result); end

  def _reduce_251(val, _values, result); end

  def _reduce_252(val, _values, result); end

  def _reduce_253(val, _values, result); end

  def _reduce_254(val, _values, result); end

  def _reduce_255(val, _values, result); end

  def _reduce_256(val, _values, result); end

  def _reduce_257(val, _values, result); end

  def _reduce_258(val, _values, result); end

  def _reduce_259(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_260(val, _values, result); end

  def _reduce_261(val, _values, result); end

  def _reduce_264(val, _values, result); end

  def _reduce_265(val, _values, result); end

  def _reduce_266(val, _values, result); end

  def _reduce_267(val, _values, result); end

  def _reduce_268(val, _values, result); end

  def _reduce_269(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_272(val, _values, result); end

  def _reduce_273(val, _values, result); end

  def _reduce_275(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_300(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_42(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_44(val, _values, result); end

  def _reduce_45(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_50(val, _values, result); end

  def _reduce_51(val, _values, result); end

  def _reduce_52(val, _values, result); end

  def _reduce_53(val, _values, result); end

  def _reduce_54(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_56(val, _values, result); end

  def _reduce_57(val, _values, result); end

  def _reduce_58(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_7(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def add_definition(definition); end

  def add_mapping(produces); end

  def aryfy(o); end

  def classname(name); end

  def create_empty_program(); end

  def create_program(body); end

  def definitions(); end

  def error(semantic, message); end

  def heredoc_loc(factory, start_locatable, end_locatable=T.unsafe(nil)); end

  def lexer(); end

  def lexer=(lexer); end

  def loc(factory, start_locatable, end_locatable=T.unsafe(nil)); end

  def namepop(); end

  def namespace(); end

  def namestack(name); end

  def on_error(token, value, stack); end

  def parse_file(file); end

  def parse_string(code, path=T.unsafe(nil)); end

  def token_text(t); end

  def transform_calls(expressions); end

  def transform_resource_wo_title(left, resource, lbrace_token, rbrace_token); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

Puppet::Pops::Parser::Parser::Factory = Puppet::Pops::Model::Factory

class Puppet::Pops::Parser::Parser
end

module Puppet::Pops::Parser::SlurpSupport
  include ::Puppet::Pops::Parser::LexerSupport
  def slurp(scanner, pattern, escapes, ignore_invalid_escapes); end

  def slurp_dqstring(); end

  def slurp_sqstring(); end

  def slurp_uqstring(); end
  DQ_ESCAPES = ::T.let(nil, ::T.untyped)
  SLURP_ALL_PATTERN = ::T.let(nil, ::T.untyped)
  SLURP_DQ_PATTERN = ::T.let(nil, ::T.untyped)
  SLURP_SQ_PATTERN = ::T.let(nil, ::T.untyped)
  SLURP_UQNE_PATTERN = ::T.let(nil, ::T.untyped)
  SLURP_UQ_PATTERN = ::T.let(nil, ::T.untyped)
  SQ_ESCAPES = ::T.let(nil, ::T.untyped)
  UQ_ESCAPES = ::T.let(nil, ::T.untyped)
end

module Puppet::Pops::Parser::SlurpSupport
  extend ::T::Sig
end

module Puppet::Pops::Parser
  extend ::T::Sig
end

module Puppet::Pops::Patterns
  CLASSREF = ::T.let(nil, ::T.untyped)
  CLASSREF_DECL = ::T.let(nil, ::T.untyped)
  CLASSREF_EXT = ::T.let(nil, ::T.untyped)
  CLASSREF_EXT_DECL = ::T.let(nil, ::T.untyped)
  DOLLAR_VAR = ::T.let(nil, ::T.untyped)
  ILLEGAL_HOSTNAME_CHARS = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NUMERIC = ::T.let(nil, ::T.untyped)
  NUMERIC_VAR_NAME = ::T.let(nil, ::T.untyped)
  PARAM_NAME = ::T.let(nil, ::T.untyped)
  VAR_NAME = ::T.let(nil, ::T.untyped)
  WS_BETWEEN_SIGN_AND_NUMBER = ::T.let(nil, ::T.untyped)
end

module Puppet::Pops::Patterns
  extend ::T::Sig
end

module Puppet::Pops::Pcore
  include ::Puppet::Pops::Types::PuppetObject
  KEY_PCORE_URI = ::T.let(nil, ::T.untyped)
  KEY_PCORE_VERSION = ::T.let(nil, ::T.untyped)
  PARSABLE_PCORE_VERSIONS = ::T.let(nil, ::T.untyped)
  PCORE_URI = ::T.let(nil, ::T.untyped)
  PCORE_VERSION = ::T.let(nil, ::T.untyped)
  RUNTIME_NAME_AUTHORITY = ::T.let(nil, ::T.untyped)
  TYPE_MEMBER_NAME = ::T.let(nil, ::T.untyped)
  TYPE_QUALIFIED_REFERENCE = ::T.let(nil, ::T.untyped)
  TYPE_SIMPLE_TYPE_NAME = ::T.let(nil, ::T.untyped)
  TYPE_URI = ::T.let(nil, ::T.untyped)
  TYPE_URI_ALIAS = ::T.let(nil, ::T.untyped)
  TYPE_URI_RX = ::T.let(nil, ::T.untyped)
end

module Puppet::Pops::Pcore
  extend ::T::Sig
  def self._pcore_type(); end

  def self.add_alias(name, type, loader, name_authority=T.unsafe(nil)); end

  def self.add_object_type(name, body, loader); end

  def self.add_type(type, loader, name_authority=T.unsafe(nil)); end

  def self.annotate(instance, annotations_hash); end

  def self.create_object_type(loader, ir, impl_class, type_name, parent_name, attributes_hash=T.unsafe(nil), functions_hash=T.unsafe(nil), equality=T.unsafe(nil)); end

  def self.init(loader, ir); end

  def self.init_env(loader); end

  def self.register_aliases(aliases, name_authority=T.unsafe(nil), loader=T.unsafe(nil)); end

  def self.register_implementations(impls, name_authority=T.unsafe(nil)); end
end

module Puppet::Pops::PuppetStack
  PP_ENTRY_PATTERN = ::T.let(nil, ::T.untyped)
end

module Puppet::Pops::PuppetStack
  extend ::T::Sig
  def self.stack(file, line, obj, message, args, &block); end

  def self.stacktrace(); end

  def self.top_of_stack(); end
end

module Puppet::Pops::Resource
end

class Puppet::Pops::Resource::Param
  include ::Puppet::Pops::Types::PuppetObject
  def initialize(type, name, name_var=T.unsafe(nil)); end

  def name(); end

  def name_var(); end

  def type(); end
end

class Puppet::Pops::Resource::Param
  def self._pcore_type(); end

  def self.register_ptype(loader, ir); end
end

class Puppet::Pops::Resource::ResourceTypeImpl
  include ::Puppet::Pops::Types::PuppetObject
  include ::Puppet::CompilableResourceType
  def ==(other); end

  def allattrs(); end

  def application?(); end

  def apply_to(); end

  def apply_to_all(); end

  def apply_to_device(); end

  def apply_to_host(); end

  def attrclass(name); end

  def attrtype(name); end

  def can_apply_to_target(target); end

  def deprecate_params(title, attributes); end

  def eql?(other); end

  def finish(); end

  def initialize(name, properties=T.unsafe(nil), parameters=T.unsafe(nil), title_patterns_hash=T.unsafe(nil), isomorphic=T.unsafe(nil), capability=T.unsafe(nil)); end

  def instantiate_resource(scope, resource); end

  def is_capability?(); end

  def isomorphic?(); end

  def key_attributes(); end

  def name(); end

  def parameters(); end

  def properties(); end

  def title_patterns(); end

  def title_patterns_hash(); end

  def valid_parameter?(name); end
  METAPARAMS = ::T.let(nil, ::T.untyped)
  METAPARAMSET = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Resource::ResourceTypeImpl
  def self._pcore_type(); end

  def self.register_ptype(loader, ir); end
end

module Puppet::Pops::Resource
  extend ::T::Sig
  def self.register_ptypes(loader, ir); end
end

class Puppet::Pops::ReverseDeepMergeStrategy
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::ReverseDeepMergeStrategy
end

class Puppet::Pops::SemanticError
  def file(); end

  def initialize(issue, semantic=T.unsafe(nil), options=T.unsafe(nil)); end

  def issue(); end

  def issue=(issue); end

  def line(); end

  def options(); end

  def options=(options); end

  def pos(); end

  def semantic(); end

  def semantic=(semantic); end
end

class Puppet::Pops::SemanticError
end

module Puppet::Pops::Serialization
  MAX_INTEGER = ::T.let(nil, ::T.untyped)
  MIN_INTEGER = ::T.let(nil, ::T.untyped)
  PCORE_LOCAL_REF_SYMBOL = ::T.let(nil, ::T.untyped)
  PCORE_TYPE_BINARY = ::T.let(nil, ::T.untyped)
  PCORE_TYPE_DEFAULT = ::T.let(nil, ::T.untyped)
  PCORE_TYPE_HASH = ::T.let(nil, ::T.untyped)
  PCORE_TYPE_KEY = ::T.let(nil, ::T.untyped)
  PCORE_TYPE_SENSITIVE = ::T.let(nil, ::T.untyped)
  PCORE_TYPE_SYMBOL = ::T.let(nil, ::T.untyped)
  PCORE_VALUE_KEY = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Serialization::AbstractReader
  def extension_unpacker(); end

  def initialize(unpacker, extension_unpacker=T.unsafe(nil)); end

  def primitive_count(); end

  def read(); end

  def read_payload(data); end

  def read_tpl(ep); end

  def read_tpl_qname(ep); end

  def register_type(extension_number, &block); end

  def register_types(); end
end

class Puppet::Pops::Serialization::AbstractReader
end

class Puppet::Pops::Serialization::AbstractWriter
  def build_payload(); end

  def extension_packer(); end

  def finish(); end

  def initialize(packer, options, extension_packer=T.unsafe(nil)); end

  def register_type(extension_number, payload_class, &block); end

  def register_types(); end

  def supports_binary?(); end

  def write(value); end

  def write_tpl(ep, value); end

  def write_tpl_qname(ep, qname); end
end

class Puppet::Pops::Serialization::AbstractWriter
end

class Puppet::Pops::Serialization::Builder
  def [](key); end

  def []=(key, value); end

  def initialize(values); end

  def resolve(); end
end

class Puppet::Pops::Serialization::Builder
end

class Puppet::Pops::Serialization::Deserializer
  def initialize(reader, loader); end

  def loader(); end

  def read(); end

  def reader(); end

  def remember(value); end
end

class Puppet::Pops::Serialization::Deserializer
end

module Puppet::Pops::Serialization::Extension
  ARRAY_START = ::T.let(nil, ::T.untyped)
  BASE64 = ::T.let(nil, ::T.untyped)
  BINARY = ::T.let(nil, ::T.untyped)
  COMMENT = ::T.let(nil, ::T.untyped)
  DEFAULT = ::T.let(nil, ::T.untyped)
  INNER_TABULATION = ::T.let(nil, ::T.untyped)
  MAP_START = ::T.let(nil, ::T.untyped)
  OBJECT_START = ::T.let(nil, ::T.untyped)
  PCORE_OBJECT_START = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  SENSITIVE_START = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
  TABULATION = ::T.let(nil, ::T.untyped)
  TIME = ::T.let(nil, ::T.untyped)
  TIMESPAN = ::T.let(nil, ::T.untyped)
  TYPE_REFERENCE = ::T.let(nil, ::T.untyped)
  URI = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_RANGE = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Serialization::Extension::ArrayStart
  include ::Puppet::Pops::Serialization::Extension::NotTabulated
  include ::Puppet::Pops::Serialization::Extension::SequenceStart
  def initialize(size); end

  def sequence_size(); end

  def size(); end
end

class Puppet::Pops::Serialization::Extension::ArrayStart
end

class Puppet::Pops::Serialization::Extension::Comment
  def ==(o); end

  def comment(); end

  def eql?(o); end

  def initialize(comment); end
end

class Puppet::Pops::Serialization::Extension::Comment
end

class Puppet::Pops::Serialization::Extension::Default
  include ::Puppet::Pops::Serialization::Extension::NotTabulated
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Serialization::Extension::Default
end

class Puppet::Pops::Serialization::Extension::InnerTabulation
end

class Puppet::Pops::Serialization::Extension::InnerTabulation
end

class Puppet::Pops::Serialization::Extension::MapStart
  include ::Puppet::Pops::Serialization::Extension::NotTabulated
  include ::Puppet::Pops::Serialization::Extension::SequenceStart
  def initialize(size); end

  def sequence_size(); end

  def size(); end
end

class Puppet::Pops::Serialization::Extension::MapStart
end

module Puppet::Pops::Serialization::Extension::NotTabulated
end

module Puppet::Pops::Serialization::Extension::NotTabulated
  extend ::T::Sig
end

class Puppet::Pops::Serialization::Extension::ObjectStart
  include ::Puppet::Pops::Serialization::Extension::SequenceStart
  def ==(o); end

  def attribute_count(); end

  def eql?(o); end

  def initialize(attribute_count); end

  def sequence_size(); end
end

class Puppet::Pops::Serialization::Extension::ObjectStart
end

class Puppet::Pops::Serialization::Extension::PcoreObjectStart
  include ::Puppet::Pops::Serialization::Extension::SequenceStart
  def ==(o); end

  def attribute_count(); end

  def eql?(o); end

  def initialize(type_name, attribute_count); end

  def sequence_size(); end

  def type_name(); end
end

class Puppet::Pops::Serialization::Extension::PcoreObjectStart
end

class Puppet::Pops::Serialization::Extension::SensitiveStart
  include ::Puppet::Pops::Serialization::Extension::NotTabulated
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Serialization::Extension::SensitiveStart
end

module Puppet::Pops::Serialization::Extension::SequenceStart
end

module Puppet::Pops::Serialization::Extension::SequenceStart
  extend ::T::Sig
end

class Puppet::Pops::Serialization::Extension::Tabulation
  include ::Puppet::Pops::Serialization::Extension::NotTabulated
  def index(); end

  def initialize(index); end
end

class Puppet::Pops::Serialization::Extension::Tabulation
end

module Puppet::Pops::Serialization::Extension
  extend ::T::Sig
end

class Puppet::Pops::Serialization::FromDataConverter
  def convert(value); end

  def initialize(options=T.unsafe(nil)); end
end

class Puppet::Pops::Serialization::FromDataConverter
  def self.convert(value, options=T.unsafe(nil)); end
end

module Puppet::Pops::Serialization::InstanceReader
  def read(impl_class, value_count, deserializer); end
end

module Puppet::Pops::Serialization::InstanceReader
  extend ::T::Sig
end

module Puppet::Pops::Serialization::InstanceWriter
  def write(type, value, serializer); end
end

module Puppet::Pops::Serialization::InstanceWriter
  extend ::T::Sig
end

module Puppet::Pops::Serialization::JSON
end

class Puppet::Pops::Serialization::JSON::Packer
  def clear_io(); end

  def empty?(); end

  def flush(); end

  def initialize(io, options=T.unsafe(nil)); end

  def pack(obj); end

  def register_type(type, klass, &block); end

  def to_a(); end

  def to_json(); end

  def write(obj); end

  def write_array_header(n); end

  def write_map_header(n); end

  def write_nil(); end

  def write_pl(obj); end
end

class Puppet::Pops::Serialization::JSON::Packer
end

class Puppet::Pops::Serialization::JSON::Reader
  def initialize(io); end

  def re_initialize(io); end
end

class Puppet::Pops::Serialization::JSON::Reader
end

class Puppet::Pops::Serialization::JSON::Unpacker
  def initialize(io); end

  def re_initialize(io); end

  def read(); end

  def register_type(extension_number, &block); end
end

class Puppet::Pops::Serialization::JSON::Unpacker
end

class Puppet::Pops::Serialization::JSON::Writer
  def clear_io(); end

  def initialize(io, options=T.unsafe(nil)); end

  def packer(); end

  def to_a(); end

  def to_json(); end
end

class Puppet::Pops::Serialization::JSON::Writer
end

module Puppet::Pops::Serialization::JSON
  extend ::T::Sig
end

module Puppet::Pops::Serialization::JsonPath
end

class Puppet::Pops::Serialization::JsonPath::Resolver
  def resolve(context, path); end

  def resolve_AccessExpression(ast, context, path); end

  def resolve_CallMethodExpression(ast, context, path); end

  def resolve_LiteralDefault(_, _, _); end

  def resolve_LiteralUndef(_, _, _); end

  def resolve_LiteralValue(ast, _, _); end

  def resolve_NamedAccessExpression(ast, context, path); end

  def resolve_Object(ast, _, path); end

  def resolve_QualifiedName(ast, _, _); end

  def resolve_QualifiedReference(ast, _, _); end

  def resolve_ReservedWord(ast, _, _); end

  def resolve_VariableExpression(ast, context, path); end

  def resolve_any(ast, context, path); end
end

class Puppet::Pops::Serialization::JsonPath::Resolver
  def self.singleton(); end
end

module Puppet::Pops::Serialization::JsonPath
  extend ::T::Sig
  def self.to_json_path(path); end
end

class Puppet::Pops::Serialization::ObjectArrayBuilder
  def initialize(instance); end
end

class Puppet::Pops::Serialization::ObjectArrayBuilder
end

class Puppet::Pops::Serialization::ObjectHashBuilder
  def initialize(instance); end
end

class Puppet::Pops::Serialization::ObjectHashBuilder
end

class Puppet::Pops::Serialization::ObjectReader
  include ::Puppet::Pops::Serialization::InstanceReader
  def read(type, impl_class, value_count, deserializer); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Serialization::ObjectReader
end

class Puppet::Pops::Serialization::ObjectWriter
  include ::Puppet::Pops::Serialization::InstanceWriter
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Serialization::ObjectWriter
end

class Puppet::Pops::Serialization::SerializationError
end

class Puppet::Pops::Serialization::SerializationError
end

class Puppet::Pops::Serialization::Serializer
  def finish(); end

  def initialize(writer, options=T.unsafe(nil)); end

  def push_written(value); end

  def start_array(size); end

  def start_map(size); end

  def start_object(attr_count); end

  def start_pcore_object(type_ref, attr_count); end

  def start_sensitive(); end

  def type_by_reference?(); end

  def write(value); end

  def write_tabulated_first_time(value); end

  def writer(); end
end

class Puppet::Pops::Serialization::Serializer
end

class Puppet::Pops::Serialization::TimeFactory
  NANO_DENOMINATOR = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Serialization::TimeFactory
  def self.at(*args); end

  def self.from_sec_nsec(sec, nsec); end

  def self.gm(*args); end

  def self.local(*args); end

  def self.mktime(*args); end

  def self.new(*args); end

  def self.now(); end

  def self.sec_nsec_safe(t); end

  def self.utc(*args); end
end

class Puppet::Pops::Serialization::ToDataConverter
  include ::Puppet::Pops::Evaluator::Runtime3Support
  def convert(value); end

  def initialize(options=T.unsafe(nil)); end
end

class Puppet::Pops::Serialization::ToDataConverter
  def self.convert(value, options=T.unsafe(nil)); end
end

class Puppet::Pops::Serialization::ToStringifiedConverter
  include ::Puppet::Pops::Evaluator::Runtime3Support
  def convert(value); end

  def initialize(options=T.unsafe(nil)); end
end

class Puppet::Pops::Serialization::ToStringifiedConverter
  def self.convert(value, options=T.unsafe(nil)); end
end

module Puppet::Pops::Serialization
  extend ::T::Sig
  def self.not_implemented(impl, method_name); end
end

module Puppet::Pops::Time
  KEY_DAYS = ::T.let(nil, ::T.untyped)
  KEY_FORMAT = ::T.let(nil, ::T.untyped)
  KEY_HOURS = ::T.let(nil, ::T.untyped)
  KEY_MICROSECONDS = ::T.let(nil, ::T.untyped)
  KEY_MILLISECONDS = ::T.let(nil, ::T.untyped)
  KEY_MINUTES = ::T.let(nil, ::T.untyped)
  KEY_NANOSECONDS = ::T.let(nil, ::T.untyped)
  KEY_NEGATIVE = ::T.let(nil, ::T.untyped)
  KEY_SECONDS = ::T.let(nil, ::T.untyped)
  KEY_STRING = ::T.let(nil, ::T.untyped)
  NSECS_PER_DAY = ::T.let(nil, ::T.untyped)
  NSECS_PER_HOUR = ::T.let(nil, ::T.untyped)
  NSECS_PER_MIN = ::T.let(nil, ::T.untyped)
  NSECS_PER_MSEC = ::T.let(nil, ::T.untyped)
  NSECS_PER_SEC = ::T.let(nil, ::T.untyped)
  NSECS_PER_USEC = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Time::TimeData
  include ::Puppet::Pops::LabelProvider
  def initialize(nanoseconds); end

  def nsecs(); end

  def to_f(); end

  def to_i(); end

  def to_r(); end
end

class Puppet::Pops::Time::TimeData
end

class Puppet::Pops::Time::Timespan
  def %(o); end

  def *(o); end

  def +(o); end

  def -(o); end

  def /(o); end

  def days(); end

  def div(o); end

  def divmod(o); end

  def format(format); end

  def hours(); end

  def milliseconds(); end

  def minutes(); end

  def modulo(o); end

  def nanoseconds(); end

  def seconds(); end

  def to_hash(compact=T.unsafe(nil)); end

  def total_days(); end

  def total_hours(); end

  def total_microseconds(); end

  def total_milliseconds(); end

  def total_minutes(); end

  def total_nanoseconds(); end

  def total_seconds(); end
end

class Puppet::Pops::Time::Timespan::Format
  def format(timespan); end

  def initialize(format, segments); end

  def parse(timespan); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Time::Timespan::Format::DaySegment
  def initialize(padchar, width); end
end

class Puppet::Pops::Time::Timespan::Format::DaySegment
end

class Puppet::Pops::Time::Timespan::Format::FragmentSegment
end

class Puppet::Pops::Time::Timespan::Format::FragmentSegment
end

class Puppet::Pops::Time::Timespan::Format::HourSegment
  def initialize(padchar, width); end
end

class Puppet::Pops::Time::Timespan::Format::HourSegment
end

class Puppet::Pops::Time::Timespan::Format::LiteralSegment
  def append_regexp(bld); end

  def concat(codepoint); end

  def initialize(literal); end

  def nanoseconds(); end
end

class Puppet::Pops::Time::Timespan::Format::LiteralSegment
end

class Puppet::Pops::Time::Timespan::Format::MilliSecondSegment
  def initialize(padchar, width); end
end

class Puppet::Pops::Time::Timespan::Format::MilliSecondSegment
end

class Puppet::Pops::Time::Timespan::Format::MinuteSegment
  def initialize(padchar, width); end
end

class Puppet::Pops::Time::Timespan::Format::MinuteSegment
end

class Puppet::Pops::Time::Timespan::Format::NanoSecondSegment
  def initialize(padchar, width); end
end

class Puppet::Pops::Time::Timespan::Format::NanoSecondSegment
end

class Puppet::Pops::Time::Timespan::Format::SecondSegment
  def initialize(padchar, width); end
end

class Puppet::Pops::Time::Timespan::Format::SecondSegment
end

class Puppet::Pops::Time::Timespan::Format::Segment
  def append_regexp(bld, ts); end

  def append_to(bld, ts); end

  def multiplier(); end
end

class Puppet::Pops::Time::Timespan::Format::Segment
end

class Puppet::Pops::Time::Timespan::Format::ValueSegment
  def append_regexp(bld); end

  def append_value(bld, n); end

  def create_format(); end

  def initialize(padchar, width, default_width); end

  def nanoseconds(group); end

  def set_use_total(); end

  def use_total?(); end
end

class Puppet::Pops::Time::Timespan::Format::ValueSegment
end

class Puppet::Pops::Time::Timespan::Format
end

class Puppet::Pops::Time::Timespan::FormatParser
  def parse_format(format); end
  DAY_MAX = ::T.let(nil, ::T.untyped)
  HOUR_MAX = ::T.let(nil, ::T.untyped)
  MIN_MAX = ::T.let(nil, ::T.untyped)
  MSEC_MAX = ::T.let(nil, ::T.untyped)
  NSEC_MAX = ::T.let(nil, ::T.untyped)
  SEC_MAX = ::T.let(nil, ::T.untyped)
  SEGMENT_CLASS_BY_ORDINAL = ::T.let(nil, ::T.untyped)
  STATE_LITERAL = ::T.let(nil, ::T.untyped)
  STATE_PAD = ::T.let(nil, ::T.untyped)
  STATE_WIDTH = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Time::Timespan::FormatParser
  def self.singleton(); end
end

class Puppet::Pops::Time::Timespan
  def self.from_fields(negative, days, hours, minutes, seconds, milliseconds=T.unsafe(nil), microseconds=T.unsafe(nil), nanoseconds=T.unsafe(nil)); end

  def self.from_fields_hash(hash); end

  def self.from_hash(hash); end

  def self.from_string_hash(hash); end

  def self.parse(str, format=T.unsafe(nil)); end
end

class Puppet::Pops::Time::Timestamp
  def +(o); end

  def -(o); end

  def format(format, timezone=T.unsafe(nil)); end

  def to_time(); end
  CURRENT_TIMEZONE = ::T.let(nil, ::T.untyped)
  DEFAULT_FORMATS = ::T.let(nil, ::T.untyped)
  DEFAULT_FORMATS_WO_TZ = ::T.let(nil, ::T.untyped)
  KEY_TIMEZONE = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Time::Timestamp
  def self.convert_timezone(tz); end

  def self.format_time(format, time, timezone); end

  def self.from_hash(args_hash); end

  def self.from_time(t); end

  def self.now(); end

  def self.parse(str, format=T.unsafe(nil), timezone=T.unsafe(nil)); end

  def self.utc_offset(timezone); end
end

module Puppet::Pops::Time
  extend ::T::Sig
end

module Puppet::Pops::Types
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  FLOAT_DEC = ::T.let(nil, ::T.untyped)
  FLOAT_PATTERN = ::T.let(nil, ::T.untyped)
  INTEGER_BIN = ::T.let(nil, ::T.untyped)
  INTEGER_DEC = ::T.let(nil, ::T.untyped)
  INTEGER_DEC_OR_OCT = ::T.let(nil, ::T.untyped)
  INTEGER_HEX = ::T.let(nil, ::T.untyped)
  INTEGER_OCT = ::T.let(nil, ::T.untyped)
  INTEGER_PATTERN = ::T.let(nil, ::T.untyped)
  INTEGER_PATTERN_LENIENT = ::T.let(nil, ::T.untyped)
  KEY_ALIAS = ::T.let(nil, ::T.untyped)
  KEY_ANNOTATIONS = ::T.let(nil, ::T.untyped)
  KEY_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  KEY_CHECKS = ::T.let(nil, ::T.untyped)
  KEY_CONSTANTS = ::T.let(nil, ::T.untyped)
  KEY_EQUALITY = ::T.let(nil, ::T.untyped)
  KEY_EQUALITY_INCLUDE_TYPE = ::T.let(nil, ::T.untyped)
  KEY_FINAL = ::T.let(nil, ::T.untyped)
  KEY_FUNCTIONS = ::T.let(nil, ::T.untyped)
  KEY_KIND = ::T.let(nil, ::T.untyped)
  KEY_NAME = ::T.let(nil, ::T.untyped)
  KEY_NAME_AUTHORITY = ::T.let(nil, ::T.untyped)
  KEY_OVERRIDE = ::T.let(nil, ::T.untyped)
  KEY_PARENT = ::T.let(nil, ::T.untyped)
  KEY_REFERENCES = ::T.let(nil, ::T.untyped)
  KEY_TYPE = ::T.let(nil, ::T.untyped)
  KEY_TYPES = ::T.let(nil, ::T.untyped)
  KEY_TYPE_PARAMETERS = ::T.let(nil, ::T.untyped)
  KEY_VALUE = ::T.let(nil, ::T.untyped)
  KEY_VERSION = ::T.let(nil, ::T.untyped)
  KEY_VERSION_RANGE = ::T.let(nil, ::T.untyped)
  OPTIONAL_EXPONENT = ::T.let(nil, ::T.untyped)
  OPTIONAL_FRACTION = ::T.let(nil, ::T.untyped)
  SIGN_PREFIX = ::T.let(nil, ::T.untyped)
end

module Puppet::Pops::Types::Annotatable
  def _pcore_init_hash(); end

  def annotatable_accept(visitor, guard); end

  def annotations(); end

  def init_annotatable(init_hash); end
  TYPE_ANNOTATIONS = ::T.let(nil, ::T.untyped)
end

module Puppet::Pops::Types::Annotatable
  extend ::T::Sig
end

class Puppet::Pops::Types::Annotation
  include ::Puppet::Pops::Types::PuppetObject
  CLEAR = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::Annotation
  def self._pcore_type(); end

  def self.annotate(o); end

  def self.annotate_new(o, init_hash); end

  def self.register_ptype(loader, ir); end
end

class Puppet::Pops::Types::ArrayPathElement
end

class Puppet::Pops::Types::ArrayPathElement
end

class Puppet::Pops::Types::AttrReader
  include ::Puppet::Pops::Types::InvocableMember
  def initialize(message); end
end

class Puppet::Pops::Types::AttrReader
end

class Puppet::Pops::Types::BlockPathElement
  def initialize(name=T.unsafe(nil)); end
end

class Puppet::Pops::Types::BlockPathElement
end

class Puppet::Pops::Types::ClassLoader
end

class Puppet::Pops::Types::ClassLoader
  def self.provide(name); end

  def self.provide_from_name_path(name, name_path); end
end

class Puppet::Pops::Types::CountMismatch
end

class Puppet::Pops::Types::CountMismatch
end

class Puppet::Pops::Types::EntryKeyPathElement
end

class Puppet::Pops::Types::EntryKeyPathElement
end

class Puppet::Pops::Types::EntryValuePathElement
end

class Puppet::Pops::Types::EntryValuePathElement
end

class Puppet::Pops::Types::Enumeration
  def enumerator(o); end
end

class Puppet::Pops::Types::Enumeration
  def self.enumerator(o); end
end

class Puppet::Pops::Types::ExpectedActualMismatch
  def actual(); end

  def expected(); end

  def initialize(path, expected, actual); end
end

class Puppet::Pops::Types::ExpectedActualMismatch
end

class Puppet::Pops::Types::ExtraneousKey
end

class Puppet::Pops::Types::ExtraneousKey
end

class Puppet::Pops::Types::HashIterator
end

class Puppet::Pops::Types::HashIterator
end

class Puppet::Pops::Types::ImplementationRegistry
  def initialize(parent=T.unsafe(nil)); end

  def module_for_type(type); end

  def module_name_for_type(type); end

  def register_implementation(type, impl_module, _=T.unsafe(nil)); end

  def register_implementation_namespace(type_namespace, impl_namespace, _=T.unsafe(nil)); end

  def register_implementation_regexp(type_name_subst, impl_name_subst, _=T.unsafe(nil)); end

  def register_type_mapping(runtime_type, puppet_type_or_pattern, _=T.unsafe(nil)); end

  def type_for_module(impl_module); end

  def type_name_for_module(impl_module); end
  TYPE_REGEXP_SUBST = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::ImplementationRegistry
end

class Puppet::Pops::Types::IntegerRangeIterator
  include ::Enumerable
  def initialize(range, step=T.unsafe(nil)); end

  def next(); end

  def reverse_each(&block); end
end

class Puppet::Pops::Types::IntegerRangeIterator
end

class Puppet::Pops::Types::InvalidParameter
end

class Puppet::Pops::Types::InvalidParameter
end

module Puppet::Pops::Types::InvocableMember
  def invoke(receiver, scope, args, &block); end
end

module Puppet::Pops::Types::InvocableMember
  extend ::T::Sig
end

module Puppet::Pops::Types::Iterable
  def each(&block); end

  def element_type(); end

  def hash_style?(); end

  def reverse_each(&block); end

  def step(step, &block); end

  def to_a(); end

  def unbounded?(); end
end

class Puppet::Pops::Types::Iterable::BreadthFirstTreeIterator
  def next(); end
end

class Puppet::Pops::Types::Iterable::BreadthFirstTreeIterator
end

class Puppet::Pops::Types::Iterable::DepthFirstTreeIterator
  def next(); end
end

class Puppet::Pops::Types::Iterable::DepthFirstTreeIterator
end

class Puppet::Pops::Types::Iterable::TreeIterator
  include ::Puppet::Pops::Types::Iterable
  def initialize(enum, options=T.unsafe(nil)); end

  def size(); end

  def to_array(); end
  DEFAULT_CONTAINERS = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::Iterable::TreeIterator
end

module Puppet::Pops::Types::Iterable
  extend ::T::Sig
  def self.asserted_iterable(caller, obj); end

  def self.on(o, element_type=T.unsafe(nil)); end

  def self.unbounded?(object); end
end

class Puppet::Pops::Types::Iterator
  include ::Puppet::Pops::Types::Iterable
  def initialize(element_type, enumeration); end

  def method_missing(name, *arguments, &block); end

  def size(); end

  def step_iterator(step); end
end

class Puppet::Pops::Types::Iterator
end

module Puppet::Pops::Types::IteratorProducer
  def iterator(); end
end

module Puppet::Pops::Types::IteratorProducer
  extend ::T::Sig
end

class Puppet::Pops::Types::KeyMismatch
  def initialize(path, key); end

  def key(); end
end

class Puppet::Pops::Types::KeyMismatch
end

class Puppet::Pops::Types::Mismatch
  def ==(o); end

  def canonical_path(); end

  def chop_path(element_index); end

  def eql?(o); end

  def format(); end

  def initialize(path); end

  def merge(path, o); end

  def message(variant, position); end

  def path(); end

  def path_string(); end
end

class Puppet::Pops::Types::Mismatch
end

class Puppet::Pops::Types::MissingKey
end

class Puppet::Pops::Types::MissingKey
end

class Puppet::Pops::Types::MissingParameter
end

class Puppet::Pops::Types::MissingParameter
end

class Puppet::Pops::Types::MissingRequiredBlock
end

class Puppet::Pops::Types::MissingRequiredBlock
end

class Puppet::Pops::Types::NoopTypeAcceptor
  include ::Puppet::Pops::Types::TypeAcceptor
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::NoopTypeAcceptor
end

class Puppet::Pops::Types::PAbstractTimeDataType
  def convert_arg(arg, min); end

  def from(); end

  def initialize(from, to=T.unsafe(nil)); end

  def intersect?(o); end

  def merge(o); end

  def numeric_from(); end

  def numeric_to(); end

  def to(); end

  def unbounded?(); end
end

class Puppet::Pops::Types::PAbstractTimeDataType
end

class Puppet::Pops::Types::PAnyType
  def ==(o); end

  def _assignable?(o, guard); end

  def accept(visitor, guard); end

  def alter_type_array(types, method, *method_args); end

  def assignable?(o, guard=T.unsafe(nil)); end

  def callable?(args_type, guard=T.unsafe(nil)); end

  def callable_args?(callable, guard); end

  def callable_with?(args, block=T.unsafe(nil)); end

  def check_self_recursion(originator); end

  def create(*args); end

  def eql?(o); end

  def generalize(); end

  def instance?(o, guard=T.unsafe(nil)); end

  def iterable?(guard=T.unsafe(nil)); end

  def iterable_type(guard=T.unsafe(nil)); end

  def kind_of_callable?(optional=T.unsafe(nil), guard=T.unsafe(nil)); end

  def loader(); end

  def name(); end

  def new_function(); end

  def normalize(guard=T.unsafe(nil)); end

  def really_instance?(o, guard=T.unsafe(nil)); end

  def resolve(loader); end

  def roundtrip_with_string?(); end

  def simple_name(); end

  def to_alias_expanded_s(); end

  def tuple_entry_at(tuple_t, to, index); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PAnyType
  def self.create(*args); end

  def self.new_function(type); end

  def self.register_ptype(loader, ir); end

  def self.simple_name(); end
end

class Puppet::Pops::Types::PArrayType
  def callable_args?(callable, guard=T.unsafe(nil)); end

  def element_type(); end

  def initialize(element_type, size_type=T.unsafe(nil)); end
  DEFAULT = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PArrayType
end

class Puppet::Pops::Types::PBinaryType
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PBinaryType::Binary
  def ==(o); end

  def binary_buffer(); end

  def eql?(o); end

  def initialize(bin); end

  def length(); end

  def relaxed_to_s(); end

  def urlsafe_to_s(); end
end

class Puppet::Pops::Types::PBinaryType::Binary
  def self.from_base64(str); end

  def self.from_base64_strict(str); end

  def self.from_base64_urlsafe(str); end

  def self.from_binary_string(bin); end

  def self.from_string(encoded_string); end
end

class Puppet::Pops::Types::PBinaryType
end

class Puppet::Pops::Types::PBooleanType
  def initialize(value=T.unsafe(nil)); end

  def value(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
  FALSE = ::T.let(nil, ::T.untyped)
  TRUE = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PBooleanType
end

class Puppet::Pops::Types::PCallableType
  def block_range(); end

  def block_type(); end

  def callable_args?(required_callable_t, guard); end

  def initialize(param_types, block_type=T.unsafe(nil), return_type=T.unsafe(nil)); end

  def last_range(); end

  def param_types(); end

  def return_type(); end

  def size_range(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PCallableType
end

class Puppet::Pops::Types::PCatalogEntryType
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PCatalogEntryType
end

class Puppet::Pops::Types::PClassType
  def class_name(); end

  def initialize(class_name); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PClassType
end

class Puppet::Pops::Types::PCollectionType
  def has_empty_range?(); end

  def initialize(size_type); end

  def size_range(); end

  def size_type(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
  DEFAULT_SIZE = ::T.let(nil, ::T.untyped)
  NOT_EMPTY_SIZE = ::T.let(nil, ::T.untyped)
  ZERO_SIZE = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PCollectionType
end

class Puppet::Pops::Types::PDefaultType
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PDefaultType
end

class Puppet::Pops::Types::PEnumType
  def case_insensitive(); end

  def case_insensitive?(); end

  def each(&block); end

  def initialize(values, case_insensitive=T.unsafe(nil)); end

  def values(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PEnumType
end

class Puppet::Pops::Types::PFloatType
  def merge(o); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PFloatType
end

class Puppet::Pops::Types::PHashType
  def element_type(); end

  def initialize(key_type, value_type, size_type=T.unsafe(nil)); end

  def is_the_empty_hash?(); end

  def key_type(); end

  def key_type=(key_type); end

  def value_type(); end

  def value_type=(value_type); end
  DEFAULT = ::T.let(nil, ::T.untyped)
  DEFAULT_KEY_PAIR_TUPLE = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  KEY_PAIR_TUPLE_SIZE = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PHashType
  def self.array_as_hash(value); end
end

Puppet::Pops::Types::PHostClassType = Puppet::Pops::Types::PClassType

class Puppet::Pops::Types::PInitType
  def assert_initialized(); end

  def init_args(); end

  def initialize(type, init_args); end
  DEFAULT = ::T.let(nil, ::T.untyped)
  EXACTLY_ONE = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PInitType
end

class Puppet::Pops::Types::PIntegerType
  def adjacent?(o); end

  def each(&block); end

  def finite_range?(); end

  def merge(o); end

  def range(); end

  def size(); end

  def to_size(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PIntegerType
end

class Puppet::Pops::Types::PIterableType
  def element_type(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PIterableType
end

class Puppet::Pops::Types::PIteratorType
  def element_type(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PIteratorType
end

class Puppet::Pops::Types::PMetaType
  include ::Puppet::Pops::Types::Annotatable
  def resolve_hash(loader, init_hash); end

  def resolve_literal_hash(loader, init_hash_expression); end

  def resolve_type_refs(loader, o); end

  def resolved?(); end
end

class Puppet::Pops::Types::PMetaType
end

class Puppet::Pops::Types::PNotUndefType
  def initialize(type=T.unsafe(nil)); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PNotUndefType
end

class Puppet::Pops::Types::PNumericType
  def from(); end

  def initialize(from, to=T.unsafe(nil)); end

  def intersect?(o); end

  def numeric_from(); end

  def numeric_to(); end

  def to(); end

  def unbounded?(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PNumericType
end

class Puppet::Pops::Types::PObjectType
  include ::Puppet::Pops::Types::TypeWithMembers
  def [](name); end

  def _pcore_init_from_hash(init_hash); end

  def _pcore_init_hash(include_name=T.unsafe(nil)); end

  def allocate(); end

  def attr_reader_name(se); end

  def attributes(include_parent=T.unsafe(nil)); end

  def checks(); end

  def collect_equality_attributes(collector); end

  def collect_members(collector, include_parent, member_type); end

  def collect_type_parameters(collector, include_parent); end

  def create_init_hash_type(); end

  def create_new_function(); end

  def equality(); end

  def equality_attributes(); end

  def equality_include_type?(); end

  def extract_init_hash(o); end

  def from_hash(hash); end

  def functions(include_parent=T.unsafe(nil)); end

  def get_members(include_parent, member_type); end

  def implementation_class(create=T.unsafe(nil)); end

  def implementation_class=(cls); end

  def implementation_override=(block); end

  def init_hash_type(); end

  def initialize(_pcore_init_hash, init_hash_expression=T.unsafe(nil)); end

  def label(); end

  def members(include_parent=T.unsafe(nil)); end

  def parameter_info(impl_class); end

  def parameterized?(); end

  def parent(); end

  def read(value_count, deserializer); end

  def reader=(reader); end

  def resolved_parent(); end

  def type_parameters(include_parent=T.unsafe(nil)); end

  def write(value, serializer); end

  def writer=(writer); end
  ATTRIBUTE_KIND_CONSTANT = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_KIND_DERIVED = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_KIND_GIVEN_OR_DERIVED = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_KIND_REFERENCE = ::T.let(nil, ::T.untyped)
  DEFAULT = ::T.let(nil, ::T.untyped)
  TYPE_ATTRIBUTE = ::T.let(nil, ::T.untyped)
  TYPE_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  TYPE_ATTRIBUTE_CALLABLE = ::T.let(nil, ::T.untyped)
  TYPE_ATTRIBUTE_KIND = ::T.let(nil, ::T.untyped)
  TYPE_CHECKS = ::T.let(nil, ::T.untyped)
  TYPE_CONSTANTS = ::T.let(nil, ::T.untyped)
  TYPE_EQUALITY = ::T.let(nil, ::T.untyped)
  TYPE_FUNCTION = ::T.let(nil, ::T.untyped)
  TYPE_FUNCTIONS = ::T.let(nil, ::T.untyped)
  TYPE_FUNCTION_TYPE = ::T.let(nil, ::T.untyped)
  TYPE_OBJECT_I12N = ::T.let(nil, ::T.untyped)
  TYPE_OBJECT_NAME = ::T.let(nil, ::T.untyped)
  TYPE_PARAMETER = ::T.let(nil, ::T.untyped)
  TYPE_PARAMETERS = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PObjectType::PAnnotatedMember
  include ::Puppet::Pops::Types::Annotatable
  include ::Puppet::Pops::Types::InvocableMember
  def ==(o); end

  def accept(visitor, guard); end

  def assert_can_be_overridden(member); end

  def assert_override(parent_members); end

  def constant?(); end

  def container(); end

  def create_dispatch(instance); end

  def eql?(o); end

  def feature_type(); end

  def final?(); end

  def initialize(name, container, init_hash); end

  def label(); end

  def name(); end

  def override?(); end

  def type(); end
end

class Puppet::Pops::Types::PObjectType::PAnnotatedMember
  def self.feature_type(); end

  def self.label(container, name); end
end

class Puppet::Pops::Types::PObjectType::PAttribute
  def callable_type(); end

  def default_value?(value); end

  def kind(); end

  def value(); end

  def value?(); end
end

class Puppet::Pops::Types::PObjectType::PAttribute
end

class Puppet::Pops::Types::PObjectType::PFunction
  def callable_type(); end
end

class Puppet::Pops::Types::PObjectType::PFunction
end

class Puppet::Pops::Types::PObjectType::PTypeParameter
end

class Puppet::Pops::Types::PObjectType::PTypeParameter
end

class Puppet::Pops::Types::PObjectType
  def self.from_hash(hash); end
end

class Puppet::Pops::Types::PObjectTypeExtension
  include ::Puppet::Pops::Types::TypeWithMembers
  def [](name); end

  def _assignable?(o, guard=T.unsafe(nil)); end

  def base_type(); end

  def check_param(type_param, v); end

  def init_parameters(); end

  def initialize(base_type, init_parameters); end

  def parameters(); end

  def test_assignable?(param_values, guard); end

  def test_instance?(o, guard); end
end

class Puppet::Pops::Types::PObjectTypeExtension
  def self.create(base_type, init_parameters); end

  def self.create_from_instance(base_type, instance); end
end

class Puppet::Pops::Types::POptionalType
  def optional_type(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::POptionalType
end

class Puppet::Pops::Types::PPatternType
  def initialize(patterns); end

  def patterns(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PPatternType
end

class Puppet::Pops::Types::PRegexpType
  def initialize(pattern); end

  def pattern(); end

  def regexp(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PRegexpType
  def self.append_flags_group(rx_string, options); end

  def self.regexp_to_s(regexp); end

  def self.regexp_to_s_with_delimiters(regexp); end
end

class Puppet::Pops::Types::PResourceType
  def downcased_name(); end

  def initialize(type_name, title=T.unsafe(nil)); end

  def title(); end

  def type_name(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PResourceType
end

class Puppet::Pops::Types::PRuntimeType
  def class_or_module(); end

  def from_puppet_name(puppet_name); end

  def initialize(runtime, name_or_pattern); end

  def name_or_pattern(); end

  def runtime(); end

  def runtime_type_name(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
  TYPE_NAME_OR_PATTERN = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PRuntimeType
end

class Puppet::Pops::Types::PScalarDataType
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PScalarDataType
end

class Puppet::Pops::Types::PScalarType
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PScalarType
end

class Puppet::Pops::Types::PSemVerRangeType
  def hash?(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PSemVerRangeType
  def self.convert(version_range); end

  def self.covered_by?(a, b); end

  def self.include?(range, version); end

  def self.merge(a, b); end
end

class Puppet::Pops::Types::PSemVerType
  def hash?(); end

  def initialize(ranges); end

  def merge_ranges(ranges); end

  def ranges(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PSemVerType
  def self.convert(version); end
end

class Puppet::Pops::Types::PSensitiveType
  def initialize(type=T.unsafe(nil)); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PSensitiveType::Sensitive
  def initialize(value); end

  def unwrap(); end
end

class Puppet::Pops::Types::PSensitiveType::Sensitive
end

class Puppet::Pops::Types::PSensitiveType
end

class Puppet::Pops::Types::PStringType
  def derived_size_type(); end

  def initialize(size_type_or_value, deprecated_multi_args=T.unsafe(nil)); end

  def size_type(); end

  def size_type_or_value(); end

  def value(); end

  def values(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
  ITERABLE_TYPE = ::T.let(nil, ::T.untyped)
  NON_EMPTY = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PStringType
end

class Puppet::Pops::Types::PStructElement
  def ==(o); end

  def accept(visitor, guard); end

  def eql?(o); end

  def generalize(); end

  def initialize(key_type, value_type); end

  def key_type(); end

  def key_type=(key_type); end

  def name(); end

  def normalize(guard=T.unsafe(nil)); end

  def replace_value_type(new_type); end

  def resolve(loader); end

  def value_type(); end

  def value_type=(value_type); end
end

class Puppet::Pops::Types::PStructElement
  def self.register_ptype(loader, ir); end
end

class Puppet::Pops::Types::PStructType
  include ::Enumerable
  def each(); end

  def elements(); end

  def hashed_elements(); end

  def initialize(elements); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PStructType
end

class Puppet::Pops::Types::PTimespanType
  def impl_class(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PTimespanType
end

class Puppet::Pops::Types::PTimestampType
  def impl_class(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PTimestampType
end

class Puppet::Pops::Types::PTupleType
  include ::Enumerable
  def callable_args?(callable_t, guard); end

  def each(); end

  def initialize(types, size_type=T.unsafe(nil)); end

  def repeat_last_range(); end

  def size_range(); end

  def size_type(); end

  def types(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PTupleType
end

Puppet::Pops::Types::PType = Puppet::Pops::Types::PTypeType

class Puppet::Pops::Types::PTypeAliasType
  def initialize(name, type_expr, resolved_type=T.unsafe(nil)); end

  def method_missing(name, *arguments, &block); end

  def resolved_type(); end

  def self_recursion?(); end

  def set_self_recursion_status(); end

  def type_expr(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PTypeAliasType::AssertOtherTypeAcceptor
  def other_type_detected?(); end

  def visit(type, _); end
end

class Puppet::Pops::Types::PTypeAliasType::AssertOtherTypeAcceptor
end

class Puppet::Pops::Types::PTypeAliasType::AssertSelfRecursionStatusAcceptor
  def visit(type, _); end
end

class Puppet::Pops::Types::PTypeAliasType::AssertSelfRecursionStatusAcceptor
end

class Puppet::Pops::Types::PTypeAliasType
end

class Puppet::Pops::Types::PTypeReferenceType
  def callable?(args); end

  def initialize(type_string); end

  def type_string(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PTypeReferenceType
end

class Puppet::Pops::Types::PTypeSetType
  def [](qname); end

  def _pcore_init_from_hash(init_hash); end

  def defines_type?(t); end

  def initialize(name_or_init_hash, init_hash_expression=T.unsafe(nil), name_authority=T.unsafe(nil)); end

  def label(); end

  def name_authority(); end

  def name_for(t, default_name); end

  def pcore_uri(); end

  def pcore_version(); end

  def references(); end

  def types(); end

  def version(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
  TYPE_STRING_OR_RANGE = ::T.let(nil, ::T.untyped)
  TYPE_STRING_OR_VERSION = ::T.let(nil, ::T.untyped)
  TYPE_TYPESET_I12N = ::T.let(nil, ::T.untyped)
  TYPE_TYPE_REFERENCE_I12N = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PTypeSetType::TypeSetLoader
  def initialize(type_set, parent); end

  def model_loader(); end

  def name_authority(); end
end

class Puppet::Pops::Types::PTypeSetType::TypeSetLoader
end

class Puppet::Pops::Types::PTypeSetType
end

class Puppet::Pops::Types::PTypeType
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PTypeType
end

class Puppet::Pops::Types::PTypeWithContainedType
  def initialize(type); end

  def type(); end
end

class Puppet::Pops::Types::PTypeWithContainedType
end

class Puppet::Pops::Types::PURIType
  include ::Puppet::Pops::Types::TypeWithMembers
  def [](key); end

  def _assignable?(o, guard=T.unsafe(nil)); end

  def initialize(parameters=T.unsafe(nil)); end

  def parameters(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  OPAQUE = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TYPE_INTEGER_PARAM = ::T.let(nil, ::T.untyped)
  TYPE_STRING_PARAM = ::T.let(nil, ::T.untyped)
  TYPE_URI_INIT_HASH = ::T.let(nil, ::T.untyped)
  TYPE_URI_PARAM_HASH_TYPE = ::T.let(nil, ::T.untyped)
  TYPE_URI_PARAM_TYPE = ::T.let(nil, ::T.untyped)
  URI_MEMBERS = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PURIType
end

class Puppet::Pops::Types::PUndefType
  def callable_args?(callable_t, guard); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PUndefType
end

class Puppet::Pops::Types::PUnitType
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PUnitType
end

class Puppet::Pops::Types::PVariantType
  include ::Enumerable
  def each(); end

  def initialize(types); end

  def merge_enums(array); end

  def merge_numbers(clazz, array); end

  def merge_patterns(array); end

  def merge_ranges(ranges); end

  def merge_version_ranges(array); end

  def swap_not_undefs(array); end

  def types(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::PVariantType
  def self.flatten_variants(types); end

  def self.maybe_create(types); end
end

class Puppet::Pops::Types::ParameterPathElement
end

class Puppet::Pops::Types::ParameterPathElement
end

class Puppet::Pops::Types::PatternMismatch
  def actual_string(); end
end

class Puppet::Pops::Types::PatternMismatch
end

module Puppet::Pops::Types::PuppetObject
  def _pcore_all_contents(path, &block); end

  def _pcore_contents(); end

  def _pcore_init_hash(); end

  def _pcore_type(); end

  def to_s(); end
end

module Puppet::Pops::Types::PuppetObject
  extend ::T::Sig
end

class Puppet::Pops::Types::RecursionGuard
  def add_that(instance); end

  def add_this(instance); end

  def recursive_that?(instance); end

  def recursive_this?(instance); end

  def state(); end

  def that_count(); end

  def this_count(); end

  def with_that(instance); end

  def with_this(instance); end
  NO_SELF_RECURSION = ::T.let(nil, ::T.untyped)
  SELF_RECURSION_IN_BOTH = ::T.let(nil, ::T.untyped)
  SELF_RECURSION_IN_THAT = ::T.let(nil, ::T.untyped)
  SELF_RECURSION_IN_THIS = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::RecursionGuard
end

class Puppet::Pops::Types::ReturnTypeElement
  def initialize(name=T.unsafe(nil)); end
end

class Puppet::Pops::Types::ReturnTypeElement
end

class Puppet::Pops::Types::RubyGenerator
  def array_type?(t); end

  def class_body(obj, segments, bld); end

  def class_definition(obj, namespace_segments, bld, class_name, *impl_subst); end

  def content_participant?(a); end

  def create_class(obj); end

  def default_string(bld, a); end

  def end_module(common_prefix, aliases, class_names, bld); end

  def equals_default_string(bld, a); end

  def implementation_names(object_types); end

  def module_definition(types, comment, *impl_subst); end

  def module_definition_from_typeset(typeset, *impl_subst); end

  def namespace_relative(namespace_segments, name); end

  def obj_type?(t); end

  def remove_common_namespace(namespace_segments, name); end

  def rname(name); end

  def scoped_class_definition(obj, leaf_name, bld, class_name, *impl_subst); end

  def start_module(common_prefix, comment, bld); end
  RUBY_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
  RUBY_RESERVED_WORDS_REVERSED = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::RubyGenerator
  def self.protect_reserved_name(name); end

  def self.unprotect_reserved_name(name); end
end

class Puppet::Pops::Types::RubyMethod
  def body(); end

  def initialize(body, parameters=T.unsafe(nil)); end

  def parameters(); end
end

class Puppet::Pops::Types::RubyMethod
  def self.from_asserted_hash(init_hash); end

  def self.from_hash(init_hash); end
end

class Puppet::Pops::Types::SignaturePathElement
end

class Puppet::Pops::Types::SignaturePathElement
end

class Puppet::Pops::Types::SizeMismatch
  def from(); end

  def range_to_s(range, zero_string); end

  def to(); end
end

class Puppet::Pops::Types::SizeMismatch
end

class Puppet::Pops::Types::StepIterator
  include ::Enumerable
  def initialize(element_type, enumeration, step_size); end

  def next(); end

  def reverse_each(&block); end
end

class Puppet::Pops::Types::StepIterator
end

class Puppet::Pops::Types::StringConverter
  def convert(value, string_formats=T.unsafe(nil)); end

  def is_a_or_h?(x); end

  def is_container?(t); end

  def puppet_double_quote(str); end

  def puppet_quote(str, enforce_double_quotes=T.unsafe(nil)); end

  def string_PAnyType(val_type, val, format_map, _); end

  def string_PArrayType(val_type, val, format_map, indentation); end

  def string_PBinaryType(val_type, val, format_map, _); end

  def string_PBooleanType(val_type, val, format_map, indentation); end

  def string_PDefaultType(val_type, val, format_map, _); end

  def string_PFloatType(val_type, val, format_map, _); end

  def string_PHashType(val_type, val, format_map, indentation); end

  def string_PIntegerType(val_type, val, format_map, _); end

  def string_PIteratorType(val_type, val, format_map, indentation); end

  def string_PObjectType(val_type, val, format_map, indentation); end

  def string_PObjectTypeExtension(val_type, val, format_map, indentation); end

  def string_PRegexpType(val_type, val, format_map, _); end

  def string_PRuntimeType(val_type, val, format_map, indent); end

  def string_PStringType(val_type, val, format_map, _); end

  def string_PStructType(val_type, val, format_map, indentation); end

  def string_PTupleType(val_type, val, format_map, indentation); end

  def string_PTypeType(val_type, val, format_map, _); end

  def string_PURIType(val_type, val, format_map, indentation); end

  def string_PUndefType(val_type, val, format_map, _); end
  DEFAULT_ARRAY_DELIMITERS = ::T.let(nil, ::T.untyped)
  DEFAULT_ARRAY_FORMAT = ::T.let(nil, ::T.untyped)
  DEFAULT_CONTAINER_FORMATS = ::T.let(nil, ::T.untyped)
  DEFAULT_HASH_DELIMITERS = ::T.let(nil, ::T.untyped)
  DEFAULT_HASH_FORMAT = ::T.let(nil, ::T.untyped)
  DEFAULT_INDENTATION = ::T.let(nil, ::T.untyped)
  DEFAULT_PARAMETER_FORMAT = ::T.let(nil, ::T.untyped)
  DEFAULT_STRING_FORMATS = ::T.let(nil, ::T.untyped)
  FMT_KEYS = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::StringConverter::Format
  def alt(); end

  def alt?(); end

  def container_string_formats(); end

  def container_string_formats=(container_string_formats); end

  def delimiter_pair(default=T.unsafe(nil)); end

  def delimiters(); end

  def format(); end

  def initialize(fmt); end

  def left(); end

  def merge(other); end

  def orig_fmt(); end

  def plus(); end

  def prec(); end

  def separator(); end

  def separator2(); end

  def separator2=(separator2); end

  def separator=(separator); end

  def width(); end

  def zero_pad(); end
  DELIMITERS = ::T.let(nil, ::T.untyped)
  DELIMITER_MAP = ::T.let(nil, ::T.untyped)
  FMT_PATTERN = ::T.let(nil, ::T.untyped)
  FMT_PATTERN_STR = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::StringConverter::Format
  def self.merge(lower, higher); end

  def self.merge_string_formats(lower, higher); end

  def self.sort_formats(format_map); end

  def self.type_rank(t); end
end

class Puppet::Pops::Types::StringConverter::FormatError
  def initialize(type_string, actual, expected); end
end

class Puppet::Pops::Types::StringConverter::FormatError
end

class Puppet::Pops::Types::StringConverter::Indentation
  def breaks?(); end

  def first(); end

  def first?(); end

  def increase(indenting_flag=T.unsafe(nil)); end

  def indenting(indenting_flag); end

  def initialize(level, first, is_indenting); end

  def is_indenting(); end

  def is_indenting?(); end

  def level(); end

  def padding(); end

  def subsequent(); end
end

class Puppet::Pops::Types::StringConverter::Indentation
end

class Puppet::Pops::Types::StringConverter
  def self.convert(value, string_formats=T.unsafe(nil)); end

  def self.singleton(); end
end

class Puppet::Pops::Types::SubjectPathElement
end

class Puppet::Pops::Types::SubjectPathElement
end

module Puppet::Pops::Types::TypeAcceptor
  def visit(type, guard); end
end

module Puppet::Pops::Types::TypeAcceptor
  extend ::T::Sig
end

module Puppet::Pops::Types::TypeAsserter
end

module Puppet::Pops::Types::TypeAsserter
  extend ::T::Sig
  def self.assert_assignable(subject, expected_type, type_to_check, &block); end

  def self.assert_instance_of(subject, expected_type, value, nil_ok=T.unsafe(nil), &block); end
end

class Puppet::Pops::Types::TypeAssertionError
  def actual_type(); end

  def expected_type(); end

  def initialize(message, expected_type, actual_type); end
end

class Puppet::Pops::Types::TypeAssertionError
end

class Puppet::Pops::Types::TypeCalculator
  def assignable?(t, t2); end

  def callable?(callable, args); end

  def common_type(t1, t2); end

  def enumerable(t); end

  def equals(left, right); end

  def generalize(o); end

  def infer(o); end

  def infer_Array(o); end

  def infer_Binary(o); end

  def infer_Closure(o); end

  def infer_FalseClass(o); end

  def infer_Float(o); end

  def infer_Function(o); end

  def infer_Hash(o); end

  def infer_Integer(o); end

  def infer_Iterator(o); end

  def infer_Module(o); end

  def infer_NilClass(o); end

  def infer_Object(o); end

  def infer_PAnyType(o); end

  def infer_PTypeType(o); end

  def infer_Proc(o); end

  def infer_PuppetProc(o); end

  def infer_Regexp(o); end

  def infer_Resource(o); end

  def infer_Sensitive(o); end

  def infer_String(o); end

  def infer_Symbol(o); end

  def infer_Timespan(o); end

  def infer_Timestamp(o); end

  def infer_TrueClass(o); end

  def infer_URI(o); end

  def infer_Version(o); end

  def infer_VersionRange(o); end

  def infer_and_reduce_type(enumerable); end

  def infer_generic(o); end

  def infer_set(o); end

  def infer_set_Array(o); end

  def infer_set_Hash(o); end

  def infer_set_Object(o); end

  def infer_set_Version(o); end

  def instance?(t, o); end

  def is_pnil?(t); end

  def is_ptype?(t); end

  def iterable(t); end

  def max(a, b); end

  def min(a, b); end

  def reduce_type(enumerable); end

  def size_as_type(collection); end

  def size_range(range); end

  def superclasses(c); end

  def tuple_entry_at(tuple_t, from, to, index); end

  def type(c); end

  def unwrap_single_variant(possible_variant); end
end

class Puppet::Pops::Types::TypeCalculator
  def self.assignable?(t1, t2); end

  def self.callable?(callable, args); end

  def self.generalize(o); end

  def self.infer(o); end

  def self.infer_set(o); end

  def self.instance?(t, o); end

  def self.is_kind_of_callable?(t, optional=T.unsafe(nil)); end

  def self.iterable(t); end

  def self.singleton(); end
end

class Puppet::Pops::Types::TypeConversionError
  def initialize(message); end
end

class Puppet::Pops::Types::TypeConversionError
end

module Puppet::Pops::Types::TypeFactory
end

module Puppet::Pops::Types::TypeFactory
  extend ::T::Sig
  def self.all_callables(); end

  def self.any(); end

  def self.array_of(o, size_type=T.unsafe(nil)); end

  def self.array_of_any(); end

  def self.array_of_data(); end

  def self.binary(); end

  def self.boolean(value=T.unsafe(nil)); end

  def self.callable(*params); end

  def self.catalog_entry(); end

  def self.clear(); end

  def self.collection(size_type=T.unsafe(nil)); end

  def self.data(); end

  def self.default(); end

  def self.deferred(); end

  def self.enum(*values); end

  def self.error(); end

  def self.float(); end

  def self.float_range(from, to); end

  def self.hash_kv(key_type, value_type, size_type=T.unsafe(nil)); end

  def self.hash_of(value, key=T.unsafe(nil), size_type=T.unsafe(nil)); end

  def self.hash_of_any(); end

  def self.hash_of_data(); end

  def self.host_class(class_name=T.unsafe(nil)); end

  def self.init(*args); end

  def self.integer(); end

  def self.is_range_parameter?(t); end

  def self.iterable(elem_type=T.unsafe(nil)); end

  def self.iterator(elem_type=T.unsafe(nil)); end

  def self.label(t); end

  def self.not_undef(inst_type=T.unsafe(nil)); end

  def self.numeric(); end

  def self.object(hash=T.unsafe(nil), loader=T.unsafe(nil)); end

  def self.optional(optional_type=T.unsafe(nil)); end

  def self.pattern(*regular_expressions); end

  def self.range(from, to); end

  def self.regexp(pattern=T.unsafe(nil)); end

  def self.resource(type_name=T.unsafe(nil), title=T.unsafe(nil)); end

  def self.rich_data(); end

  def self.rich_data_key(); end

  def self.ruby(o); end

  def self.ruby_type(class_name=T.unsafe(nil)); end

  def self.runtime(runtime=T.unsafe(nil), runtime_type_name=T.unsafe(nil)); end

  def self.scalar(); end

  def self.scalar_data(); end

  def self.sem_ver(*ranges); end

  def self.sem_ver_range(); end

  def self.sensitive(type=T.unsafe(nil)); end

  def self.string(size_type_or_value=T.unsafe(nil), *deprecated_second_argument); end

  def self.struct(hash=T.unsafe(nil)); end

  def self.task(); end

  def self.timespan(*args); end

  def self.timestamp(*args); end

  def self.tuple(types=T.unsafe(nil), size_type=T.unsafe(nil)); end

  def self.type_alias(name=T.unsafe(nil), expression=T.unsafe(nil)); end

  def self.type_of(o); end

  def self.type_reference(type_string=T.unsafe(nil)); end

  def self.type_set(hash=T.unsafe(nil)); end

  def self.type_type(inst_type=T.unsafe(nil)); end

  def self.undef(); end

  def self.uri(string_uri_or_hash=T.unsafe(nil)); end

  def self.variant(*types); end
end

class Puppet::Pops::Types::TypeFormatter
  def alias_expanded_string(t); end

  def append_callable_params(t); end

  def append_default(); end

  def append_indented_string(t, indent=T.unsafe(nil), indent_width=T.unsafe(nil), skip_initial_indent=T.unsafe(nil)); end

  def append_string(t); end

  def capitalize_segments(qualified_name); end

  def debug_string(t); end

  def expanded(); end

  def format_type_alias_type(t, expand); end

  def indented(indent=T.unsafe(nil), indent_width=T.unsafe(nil)); end

  def indented_string(t, indent=T.unsafe(nil), indent_width=T.unsafe(nil)); end

  def ruby(ref_ctor); end

  def ruby_string(ref_ctor, indent, t); end

  def string(t); end

  def string_Array(t); end

  def string_FalseClass(t); end

  def string_Hash(t); end

  def string_Module(t); end

  def string_NilClass(t); end

  def string_Numeric(t); end

  def string_Object(t); end

  def string_PAnnotatedMember(m); end

  def string_PAnyType(_); end

  def string_PArrayType(t); end

  def string_PBinaryType(_); end

  def string_PBooleanType(t); end

  def string_PCallableType(t); end

  def string_PCatalogEntryType(_); end

  def string_PClassType(t); end

  def string_PCollectionType(t); end

  def string_PDefaultType(_); end

  def string_PEnumType(t); end

  def string_PFloatType(t); end

  def string_PHashType(t); end

  def string_PInitType(t); end

  def string_PIntegerType(t); end

  def string_PIterableType(t); end

  def string_PIteratorType(t); end

  def string_PNotUndefType(t); end

  def string_PNumericType(_); end

  def string_PObjectType(t); end

  def string_PObjectTypeExtension(t); end

  def string_POptionalType(t); end

  def string_PPatternType(t); end

  def string_PRegexpType(t); end

  def string_PResourceType(t); end

  def string_PRuntimeType(t); end

  def string_PScalarDataType(_); end

  def string_PScalarType(_); end

  def string_PSemVerRangeType(t); end

  def string_PSemVerType(t); end

  def string_PSensitiveType(t); end

  def string_PStringType(t); end

  def string_PStructType(t); end

  def string_PTimespanType(t); end

  def string_PTimestampType(t); end

  def string_PTupleType(t); end

  def string_PTypeAliasType(t); end

  def string_PTypeReferenceType(t); end

  def string_PTypeSetType(t); end

  def string_PTypeType(t); end

  def string_PURIType(t); end

  def string_PUndefType(_); end

  def string_PUnitType(_); end

  def string_PVariantType(t); end

  def string_PuppetObject(t); end

  def string_Regexp(t); end

  def string_String(t); end

  def string_Symbol(t); end

  def string_Timespan(t); end

  def string_Timestamp(t); end

  def string_TrueClass(t); end

  def string_URI(t); end

  def string_Version(t); end

  def string_VersionRange(t); end

  def struct_element_pair(t); end

  def symbolic_key(key); end
  COMMA_SEP = ::T.let(nil, ::T.untyped)
  HASH_ENTRY_OP = ::T.let(nil, ::T.untyped)
  NAME_SEGMENT_SEPARATOR = ::T.let(nil, ::T.untyped)
  STARTS_WITH_ASCII_CAPITAL = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Types::TypeFormatter
  def self.singleton(); end

  def self.string(t); end
end

class Puppet::Pops::Types::TypeMismatch
  include ::Puppet::Pops::LabelProvider
end

class Puppet::Pops::Types::TypeMismatch
end

class Puppet::Pops::Types::TypeMismatchDescriber
  def describe(expected, actual, path); end

  def describe_PAnyType(expected, original, actual, path); end

  def describe_PArrayType(expected, original, actual, path); end

  def describe_PCallableType(expected, original, actual, path); end

  def describe_PEnumType(expected, original, actual, path); end

  def describe_PHashType(expected, original, actual, path); end

  def describe_POptionalType(expected, original, actual, path); end

  def describe_PPatternType(expected, original, actual, path); end

  def describe_PStructType(expected, original, actual, path); end

  def describe_PTupleType(expected, original, actual, path); end

  def describe_PTypeAliasType(expected, original, actual, path); end

  def describe_PVariantType(expected, original, actual, path); end

  def describe_argument_tuple(expected, actual, path); end

  def describe_mismatch(name, expected, actual, tense=T.unsafe(nil)); end

  def describe_no_block_arguments(signature, atypes, path, expected_size, actual_size, arg_count); end

  def describe_signature_arguments(signature, args_tuple, path); end

  def describe_signature_block(signature, args_tuple, path); end

  def describe_signatures(closure, signatures, args_tuple, tense=T.unsafe(nil)); end

  def describe_struct_signature(params_struct, param_hash, missing_ok=T.unsafe(nil)); end

  def describe_tuple(expected, original, actual, path, size_mismatch_class); end

  def max(a, b); end

  def merge_descriptions(varying_path_position, size_mismatch_class, variant_descriptions); end

  def optional(index, required_count); end

  def signature_string(signature); end

  def tense_deprecated(); end

  def validate_default_parameter(subject, param_name, param_type, value, tense=T.unsafe(nil)); end

  def validate_parameters(subject, params_struct, given_hash, missing_ok=T.unsafe(nil), tense=T.unsafe(nil)); end
end

class Puppet::Pops::Types::TypeMismatchDescriber::UnresolvedTypeFinder
  include ::Puppet::Pops::Types::TypeAcceptor
  def unresolved(); end
end

class Puppet::Pops::Types::TypeMismatchDescriber::UnresolvedTypeFinder
end

class Puppet::Pops::Types::TypeMismatchDescriber
  def self.describe_signatures(closure, signatures, args_tuple); end

  def self.singleton(); end

  def self.validate_default_parameter(subject, param_name, param_type, value); end

  def self.validate_parameters(subject, params_struct, given_hash, missing_ok=T.unsafe(nil)); end
end

class Puppet::Pops::Types::TypeParser
  def interpret(ast, context=T.unsafe(nil)); end

  def interpret_AccessExpression(ast, context); end

  def interpret_HeredocExpression(o, context); end

  def interpret_LambdaExpression(o, context); end

  def interpret_LiteralBoolean(o, context); end

  def interpret_LiteralDefault(o, context); end

  def interpret_LiteralFloat(o, context); end

  def interpret_LiteralHash(o, context); end

  def interpret_LiteralInteger(o, context); end

  def interpret_LiteralList(o, context); end

  def interpret_LiteralRegularExpression(o, context); end

  def interpret_LiteralString(o, context); end

  def interpret_LiteralUndef(o, context); end

  def interpret_Object(o, context); end

  def interpret_Program(o, context); end

  def interpret_QualifiedName(o, context); end

  def interpret_QualifiedReference(name_ast, context); end

  def interpret_String(o, context); end

  def interpret_SubLocatedExpression(o, context); end

  def interpret_TypeAlias(o, context); end

  def interpret_TypeDefinition(o, context); end

  def interpret_UnaryMinusExpression(o, context); end

  def interpret_any(ast, context); end

  def loader_from_context(ast, context); end

  def parse(string, context=T.unsafe(nil)); end

  def parse_literal(string, context=T.unsafe(nil)); end
end

class Puppet::Pops::Types::TypeParser
  def self.opt_type_map(); end

  def self.singleton(); end

  def self.type_map(); end
end

class Puppet::Pops::Types::TypePathElement
  def ==(o); end

  def eql?(o); end

  def initialize(key); end

  def key(); end
end

class Puppet::Pops::Types::TypePathElement
end

class Puppet::Pops::Types::TypeSetReference
  include ::Puppet::Pops::Types::Annotatable
  def accept(visitor, guard); end

  def eql?(o); end

  def initialize(owner, init_hash); end

  def name(); end

  def name_authority(); end

  def resolve(loader); end

  def type_set(); end

  def version_range(); end
end

class Puppet::Pops::Types::TypeSetReference
end

module Puppet::Pops::Types::TypeWithMembers
  def [](member_name); end
end

module Puppet::Pops::Types::TypeWithMembers
  extend ::T::Sig
end

class Puppet::Pops::Types::TypedModelObject
  include ::Puppet::Pops::Types::PuppetObject
  include ::Puppet::Pops::Visitable
  include ::Puppet::Pops::Adaptable
end

class Puppet::Pops::Types::TypedModelObject
  def self._pcore_type(); end

  def self.create_ptype(loader, ir, parent_name, attributes_hash=T.unsafe(nil)); end

  def self.register_ptypes(loader, ir); end
end

class Puppet::Pops::Types::UnexpectedBlock
end

class Puppet::Pops::Types::UnexpectedBlock
end

class Puppet::Pops::Types::UnresolvedTypeReference
  def initialize(path, unresolved); end

  def unresolved(); end
end

class Puppet::Pops::Types::UnresolvedTypeReference
end

class Puppet::Pops::Types::VariantPathElement
end

class Puppet::Pops::Types::VariantPathElement
end

module Puppet::Pops::Types
  extend ::T::Sig
end

class Puppet::Pops::UnconstrainedDeepMergeStrategy
end

class Puppet::Pops::UnconstrainedDeepMergeStrategy
end

class Puppet::Pops::UniqueMergeStrategy
  def convert_value(e); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::UniqueMergeStrategy
end

module Puppet::Pops::Utils
end

module Puppet::Pops::Utils
  extend ::T::Sig
  def self.is_absolute?(name); end

  def self.is_numeric?(o); end

  def self.match_to_fp(match); end

  def self.name_to_segments(name); end

  def self.relativize_name(name); end

  def self.to_n(o); end

  def self.to_n_with_radix(o); end
end

module Puppet::Pops::Validation
end

class Puppet::Pops::Validation::Acceptor
  def accept(diagnostic); end

  def diagnostics(); end

  def error_count(); end

  def errors(); end

  def errors?(); end

  def errors_and_warnings(); end

  def errors_or_warnings?(); end

  def ignored(); end

  def prune(&block); end

  def warning_count(); end

  def warnings(); end

  def warnings?(); end
end

class Puppet::Pops::Validation::Acceptor
end

class Puppet::Pops::Validation::Checker4_0
  include ::Puppet::Pops::Evaluator::ExternalSyntaxSupport
  def acceptor(); end

  def assign(o, via_index=T.unsafe(nil)); end

  def assign_AccessExpression(o, via_index); end

  def assign_LiteralList(o, via_index); end

  def assign_Object(o, via_index); end

  def assign_VariableExpression(o, via_index); end

  def check(o); end

  def check_AccessExpression(o); end

  def check_AssignmentExpression(o); end

  def check_AttributeOperation(o); end

  def check_AttributesOperation(o); end

  def check_BinaryExpression(o); end

  def check_BlockExpression(o); end

  def check_CallNamedFunctionExpression(o); end

  def check_CapabilityMapping(o); end

  def check_CaseExpression(o); end

  def check_CaseOption(o); end

  def check_CollectExpression(o); end

  def check_EppExpression(o); end

  def check_Factory(o); end

  def check_FunctionDefinition(o); end

  def check_HeredocExpression(o); end

  def check_HostClassDefinition(o); end

  def check_IfExpression(o); end

  def check_KeyedEntry(o); end

  def check_LambdaExpression(o); end

  def check_LiteralHash(o); end

  def check_LiteralInteger(o); end

  def check_LiteralList(o); end

  def check_MethodCallExpression(o); end

  def check_NamedAccessExpression(o); end

  def check_NamedDefinition(o); end

  def check_NodeDefinition(o); end

  def check_Object(o); end

  def check_Parameter(o); end

  def check_QualifiedName(o); end

  def check_QualifiedReference(o); end

  def check_QueryExpression(o); end

  def check_RelationshipExpression(o); end

  def check_ReservedWord(o); end

  def check_ResourceBody(o); end

  def check_ResourceDefaultsExpression(o); end

  def check_ResourceExpression(o); end

  def check_ResourceOverrideExpression(o); end

  def check_ResourceTypeDefinition(o); end

  def check_SelectorEntry(o); end

  def check_SelectorExpression(o); end

  def check_TypeAlias(o); end

  def check_TypeDefinition(o); end

  def check_TypeMapping(o); end

  def check_UnaryExpression(o); end

  def check_UnlessExpression(o); end

  def check_VariableExpression(o); end

  def container(index=T.unsafe(nil)); end

  def dir_to_names(relative_path); end

  def ends_with_idem(o); end

  def get_module_relative_path(file_path, modulepath_directories); end

  def hostname(o, semantic); end

  def hostname_Array(o, semantic); end

  def hostname_ConcatenatedString(o, semantic); end

  def hostname_LiteralDefault(o, semantic); end

  def hostname_LiteralNumber(o, semantic); end

  def hostname_LiteralRegularExpression(o, semantic); end

  def hostname_LiteralValue(o, semantic); end

  def hostname_Object(o, semantic); end

  def hostname_QualifiedName(o, semantic); end

  def hostname_QualifiedReference(o, semantic); end

  def hostname_String(o, semantic); end

  def idem(o); end

  def idem_AccessExpression(o); end

  def idem_ApplyExpression(o); end

  def idem_AssignmentExpression(o); end

  def idem_BinaryExpression(o); end

  def idem_BlockExpression(o); end

  def idem_CaseExpression(o); end

  def idem_CaseOption(o); end

  def idem_ConcatenatedString(o); end

  def idem_Factory(o); end

  def idem_HeredocExpression(o); end

  def idem_IfExpression(o); end

  def idem_Literal(o); end

  def idem_LiteralHash(o); end

  def idem_LiteralList(o); end

  def idem_MatchExpression(o); end

  def idem_NilClass(o); end

  def idem_Nop(o); end

  def idem_Object(o); end

  def idem_ParenthesizedExpression(o); end

  def idem_RelationshipExpression(o); end

  def idem_RenderExpression(o); end

  def idem_RenderStringExpression(o); end

  def idem_SelectorExpression(o); end

  def idem_UnaryExpression(o); end

  def initial_manifest?(path, manifest_setting); end

  def initialize(diagnostics_producer); end

  def internal_check_capture_last(o); end

  def internal_check_file_namespace(o); end

  def internal_check_future_reserved_word(o, name); end

  def internal_check_illegal_assignment(o); end

  def internal_check_no_capture(o, container=T.unsafe(nil)); end

  def internal_check_no_idem_last(o); end

  def internal_check_parameter_name_uniqueness(o); end

  def internal_check_reserved_params(o); end

  def internal_check_reserved_type_name(o, name); end

  def internal_check_return_type(o); end

  def internal_check_top_construct_in_module(prog); end

  def internal_check_type_ref(o, r); end

  def is_parent_dir_of(parent_dir, child_dir); end

  def migration_checker(); end

  def namespace_for_file(file); end

  def pattern_with_replacement?(o); end

  def query(o); end

  def query_BooleanExpression(o); end

  def query_ComparisonExpression(o); end

  def query_LiteralBoolean(o); end

  def query_LiteralNumber(o); end

  def query_LiteralString(o); end

  def query_Object(o); end

  def query_ParenthesizedExpression(o); end

  def query_QualifiedName(o); end

  def query_VariableExpression(o); end

  def relation(o); end

  def relation_CollectExpression(o); end

  def relation_Object(o); end

  def relation_RelationshipExpression(o); end

  def resource_without_title?(o); end

  def rvalue(o); end

  def rvalue_CollectExpression(o); end

  def rvalue_Definition(o); end

  def rvalue_Expression(o); end

  def rvalue_NodeDefinition(o); end

  def rvalue_UnaryExpression(o); end

  def top(definition, idx=T.unsafe(nil)); end

  def type_ref?(o); end

  def valid_top_construct?(o); end

  def validate(model); end

  def varname_to_s(o); end
  BAD_MODULE_FILE = ::T.let(nil, ::T.untyped)
  FUTURE_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
  NO_NAMESPACE = ::T.let(nil, ::T.untyped)
  NO_PATH = ::T.let(nil, ::T.untyped)
  RESERVED_PARAMETERS = ::T.let(nil, ::T.untyped)
  RESERVED_TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Validation::Checker4_0
  def self.check_visitor(); end
end

class Puppet::Pops::Validation::Diagnostic
  def ==(o); end

  def arguments(); end

  def eql?(o); end

  def exception(); end

  def file(); end

  def initialize(severity, issue, file, source_pos, arguments=T.unsafe(nil), exception=T.unsafe(nil)); end

  def issue(); end

  def severity(); end

  def source_pos(); end
end

class Puppet::Pops::Validation::Diagnostic
end

class Puppet::Pops::Validation::DiagnosticFormatter
  def format(diagnostic); end

  def format_location(diagnostic); end

  def format_message(diagnostic); end

  def format_severity(diagnostic); end
end

class Puppet::Pops::Validation::DiagnosticFormatter
end

class Puppet::Pops::Validation::DiagnosticFormatterPuppetStyle
end

class Puppet::Pops::Validation::DiagnosticFormatterPuppetStyle
end

class Puppet::Pops::Validation::DiagnosticProducer
  def accept(issue, semantic, arguments=T.unsafe(nil), except=T.unsafe(nil)); end

  def initialize(acceptor, severity_producer, label_provider); end

  def label_provider(); end

  def severity_producer(); end

  def will_accept?(issue); end
end

class Puppet::Pops::Validation::DiagnosticProducer
end

class Puppet::Pops::Validation::Factory
  def checker(diagnostic_producer); end

  def diagnostic_producer(acceptor); end

  def label_provider(); end

  def severity_producer(); end

  def validator(acceptor); end
end

class Puppet::Pops::Validation::Factory
end

class Puppet::Pops::Validation::SeverityProducer
  def [](issue); end

  def []=(issue, level); end

  def assert_issue(issue); end

  def initialize(default_severity=T.unsafe(nil)); end

  def severity(issue); end

  def should_report?(issue); end
end

class Puppet::Pops::Validation::SeverityProducer
end

class Puppet::Pops::Validation::ValidatorFactory_4_0
end

Puppet::Pops::Validation::ValidatorFactory_4_0::Issues = Puppet::Pops::Issues

class Puppet::Pops::Validation::ValidatorFactory_4_0
end

module Puppet::Pops::Validation
  extend ::T::Sig
end

module Puppet::Pops::Visitable
  def accept(visitor, *arguments); end
end

module Puppet::Pops::Visitable
  extend ::T::Sig
end

class Puppet::Pops::Visitor
  def cache(); end

  def initialize(receiver, message, min_args=T.unsafe(nil), max_args=T.unsafe(nil)); end

  def max_args(); end

  def message(); end

  def min_args(); end

  def receiver(); end

  def visit(thing, *args); end

  def visit_this(receiver, thing, args); end

  def visit_this_0(receiver, thing); end

  def visit_this_1(receiver, thing, arg); end

  def visit_this_2(receiver, thing, arg1, arg2); end

  def visit_this_3(receiver, thing, arg1, arg2, arg3); end

  def visit_this_class(receiver, clazz, args); end
  NO_ARGS = ::T.let(nil, ::T.untyped)
end

class Puppet::Pops::Visitor
end

module Puppet::Pops
  extend ::T::Sig
end

class Puppet::PreformattedError
end

class Puppet::PreformattedError
end

class Puppet::Property
  def call_provider(value); end

  def change_to_s(current_value, newvalue); end

  def event(options=T.unsafe(nil)); end

  def event_name(); end

  def idempotent?(); end

  def insync?(is); end

  def insync_values?(should, is); end

  def is_to_s(value); end

  def match_all?(); end

  def noop=(noop); end

  def property_matches?(current, desired); end

  def retrieve(); end

  def safe_insync?(is); end

  def set(value); end

  def should(); end

  def should=(values); end

  def should_to_s(value); end

  def shouldorig(); end

  def sync(); end

  def validate_features_per_value(value); end

  def value=(values); end
end

class Puppet::Property::Ensure
  def change_to_s(currentvalue, newvalue); end

  def default(); end
end

class Puppet::Property::Ensure
  def self.defaultvalues(); end

  def self.inherited(sub); end
end

class Puppet::Property
  def self.array_matching(); end

  def self.array_matching=(value); end

  def self.idempotent(); end

  def self.idempotent=(value); end

  def self.method_added(sym); end

  def self.newvalue(name, options=T.unsafe(nil), &block); end

  def self.unmanaged(); end

  def self.unmanaged=(unmanaged); end

  def self.value_name(name); end

  def self.value_option(name, option); end
end

class Puppet::Provider
  include ::Puppet::Util
  include ::Puppet::Util::Errors
  include ::Puppet::Util::Warnings
  include ::Comparable
  def alert(args); end

  def clear(); end

  def command(name); end

  def crit(args); end

  def debug(args); end

  def emerg(args); end

  def err(args); end

  def execfail(*args); end

  def execpipe(*args, &block); end

  def execute(*args); end

  def get(param); end

  def info(args); end

  def initialize(resource=T.unsafe(nil)); end

  def name(); end

  def notice(args); end

  def resource(); end

  def resource=(resource); end

  def set(params); end

  def warning(args); end
end

class Puppet::Provider::Command
  def executable(); end

  def execute(*args); end

  def initialize(name, executable, resolver, executor, options=T.unsafe(nil)); end

  def name(); end
end

class Puppet::Provider::Command
end

class Puppet::Provider::CommandDefiner
  def command(); end

  def environment(env); end

  def initialize(name, path, confiner); end

  def is_optional(); end
end

class Puppet::Provider::CommandDefiner
  def self.define(name, path, confiner, &block); end
end

class Puppet::Provider
  extend ::Puppet::Util::Warnings
  extend ::Puppet::Confiner
  extend ::Puppet::Util::Docs
  extend ::Puppet::Util
  extend ::Puppet::Util::Logging
  def self.command(name); end

  def self.commands(command_specs); end

  def self.declared_feature?(name); end

  def self.default?(); end

  def self.default_match(); end

  def self.defaultfor(hash); end

  def self.dochook_commands(); end

  def self.dochook_defaults(); end

  def self.dochook_features(); end

  def self.execfail(*args); end

  def self.execpipe(*args, &block); end

  def self.execute(*args); end

  def self.fact_match(fact, values); end

  def self.feature_match(value); end

  def self.has_command(name, path, &block); end

  def self.initvars(); end

  def self.instances(); end

  def self.mk_resource_methods(); end

  def self.name=(name); end

  def self.notdefaultfor(hash); end

  def self.optional_commands(hash); end

  def self.resource_type(); end

  def self.resource_type=(resource_type); end

  def self.some_default_match(defaultlist); end

  def self.source(); end

  def self.source=(source); end

  def self.specificity(); end

  def self.supports_parameter?(param); end
end

class Puppet::Relationship
  include ::Puppet::Network::FormatSupport
  include ::Puppet::Util::PsychSupport
  def callback(); end

  def callback=(callback); end

  def event(); end

  def event=(event); end

  def initialize(source, target, options=T.unsafe(nil)); end

  def label(); end

  def match?(event); end

  def ref(); end

  def source(); end

  def source=(source); end

  def target(); end

  def target=(target); end

  def to_data_hash(); end
end

class Puppet::Relationship
  def self.from_data_hash(data); end
end

class Puppet::Reports
end

class Puppet::Reports
  extend ::Puppet::Util::ClassGen
  extend ::Puppet::Util::InstanceLoader
  extend ::Puppet::Util
  def self.hooks(); end

  def self.register_report(name, options=T.unsafe(nil), &block); end

  def self.report(name); end

  def self.reportdocs(); end

  def self.reports(); end
end

class Puppet::Resource
  include ::Puppet::Util::Tagging
  include ::Puppet::Util::PsychSupport
  include ::Enumerable
  include ::Puppet::Indirector::Envelope
  include ::Puppet::Network::FormatSupport
  def <<(*args); end

  def ==(other); end

  def [](param); end

  def []=(param, value); end

  def builtin?(); end

  def builtin_type?(); end

  def catalog(); end

  def catalog=(catalog); end

  def class?(); end

  def copy_as_resource(); end

  def delete(*args); end

  def each(); end

  def empty?(*args); end

  def environment(); end

  def environment=(environment); end

  def export(); end

  def exported(); end

  def exported=(exported); end

  def exported?(); end

  def file(); end

  def file=(file); end

  def has_key?(*args); end

  def include?(parameter); end

  def initialize(type, title=T.unsafe(nil), attributes=T.unsafe(nil)); end

  def initialize_from_hash(data); end

  def is_application_component?(); end

  def is_capability?(); end

  def key_attributes(); end

  def keys(*args); end

  def length(*args); end

  def line(); end

  def line=(line); end

  def name(); end

  def parameters(); end

  def pos(); end

  def prune_parameters(options=T.unsafe(nil)); end

  def ref(); end

  def resolve(); end

  def resource_type(); end

  def resource_type=(type); end

  def sensitive_parameters(); end

  def sensitive_parameters=(sensitive_parameters); end

  def set_default_parameters(scope); end

  def stage?(); end

  def strict(); end

  def strict=(strict); end

  def strict?(); end

  def title(); end

  def to_data_hash(); end

  def to_hash(); end

  def to_hierayaml(); end

  def to_manifest(); end

  def to_ral(); end

  def to_ref(); end

  def type(); end

  def uniqueness_key(); end

  def valid_parameter?(name); end

  def validate_complete(); end

  def validate_parameter(name); end

  def validate_parameters(); end

  def validate_parameters=(validate_parameters); end

  def virtual(); end

  def virtual=(virtual); end

  def virtual?(); end

  def yaml_property_munge(x); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  PCORE_TYPE_KEY = ::T.let(nil, ::T.untyped)
  TYPE_CLASS = ::T.let(nil, ::T.untyped)
  TYPE_NODE = ::T.let(nil, ::T.untyped)
  TYPE_SITE = ::T.let(nil, ::T.untyped)
  VALUE_KEY = ::T.let(nil, ::T.untyped)
end

module Puppet::Resource::CapabilityFinder
end

module Puppet::Resource::CapabilityFinder
  extend ::T::Sig
  def self.find(environment, code_id, cap); end

  def self.query_puppetdb(query); end

  def self.search(environment, code_id, cap); end
end

class Puppet::Resource::Catalog
  include ::Puppet::Indirector::Envelope
  include ::Puppet::Network::FormatSupport
  include ::Puppet::Util::Tagging
  def add_class(*classes); end

  def add_resource(*resources); end

  def add_resource_after(other, *resources); end

  def add_resource_before(other, *resources); end

  def alias(resource, key); end

  def apply(options=T.unsafe(nil)); end

  def catalog_format(); end

  def catalog_format=(catalog_format); end

  def catalog_uuid(); end

  def catalog_uuid=(catalog_uuid); end

  def classes(); end

  def clear(remove_resources=T.unsafe(nil)); end

  def client_version(); end

  def client_version=(client_version); end

  def code_id(); end

  def code_id=(code_id); end

  def container_of(resource); end

  def create_resource(type, options); end

  def environment(); end

  def environment=(environment); end

  def environment_instance(); end

  def environment_instance=(environment_instance); end

  def filter(&block); end

  def finalize(); end

  def from_cache(); end

  def from_cache=(from_cache); end

  def host_config(); end

  def host_config=(host_config); end

  def host_config?(); end

  def initialize(name=T.unsafe(nil), environment=T.unsafe(nil), code_id=T.unsafe(nil)); end

  def make_default_resources(); end

  def metadata(); end

  def metadata=(metadata); end

  def name(); end

  def name=(name); end

  def recursive_metadata(); end

  def recursive_metadata=(recursive_metadata); end

  def relationship_graph(given_prioritizer=T.unsafe(nil)); end

  def remove_resource(*resources); end

  def resource(type, title=T.unsafe(nil)); end

  def resource_keys(); end

  def resource_refs(); end

  def resources(); end

  def retrieval_duration(); end

  def retrieval_duration=(retrieval_duration); end

  def server_version(); end

  def server_version=(server_version); end

  def title_key_for_ref(ref); end

  def to_ral(); end

  def to_resource(); end

  def version(); end

  def version=(version); end

  def write_class_file(); end

  def write_resource_file(); end
end

class Puppet::Resource::Catalog::DuplicateResourceError
  include ::Puppet::ExternalFileError
end

class Puppet::Resource::Catalog::DuplicateResourceError
end

class Puppet::Resource::Catalog
  extend ::Puppet::Indirector
  extend ::Puppet::Indirector::ClassMethods
  def self.from_data_hash(data); end
end

class Puppet::Resource::Ral
  include ::Puppet::Resource::Validator
  def find(request); end

  def save(request); end

  def search(request); end
end

class Puppet::Resource::Ral
end

class Puppet::Resource::Status
  include ::Puppet::Util::PsychSupport
  include ::Puppet::Util::Tagging
  include ::Puppet::Network::FormatSupport
  def <<(event); end

  def add_event(event); end

  def change_count(); end

  def changed(); end

  def changed=(changed); end

  def changed?(); end

  def containment_path(); end

  def corrective_change(); end

  def corrective_change=(corrective_change); end

  def corrective_change?(); end

  def dependency_failed?(); end

  def evaluation_time(); end

  def evaluation_time=(evaluation_time); end

  def events(); end

  def fail_with_event(message); end

  def failed(); end

  def failed=(failed); end

  def failed?(); end

  def failed_because(detail); end

  def failed_dependencies(); end

  def failed_dependencies=(failed_dependencies); end

  def failed_to_restart(); end

  def failed_to_restart=(failed_to_restart); end

  def failed_to_restart?(); end

  def file(); end

  def file=(file); end

  def initialize(resource); end

  def initialize_from_hash(data); end

  def line(); end

  def line=(line); end

  def out_of_sync(); end

  def out_of_sync=(out_of_sync); end

  def out_of_sync?(); end

  def out_of_sync_count(); end

  def provider_used(); end

  def provider_used=(provider_used); end

  def resource(); end

  def resource_type(); end

  def restarted(); end

  def restarted=(restarted); end

  def restarted?(); end

  def scheduled(); end

  def scheduled=(scheduled); end

  def scheduled?(); end

  def skipped(); end

  def skipped=(skipped); end

  def skipped?(); end

  def source_description(); end

  def time(); end

  def title(); end

  def to_data_hash(); end
  STATES = ::T.let(nil, ::T.untyped)
end

class Puppet::Resource::Status
  def self.from_data_hash(data); end
end

class Puppet::Resource::Type
  include ::Puppet::Util::Warnings
  include ::Puppet::Util::Errors
  def add_consumes(blueprint); end

  def add_produces(blueprint); end

  def application?(); end

  def argument_types(); end

  def arguments(); end

  def assign_parameter_values(parameters, resource); end

  def behaves_like(); end

  def capability_mapping?(); end

  def child_of?(klass); end

  def code(); end

  def code=(code); end

  def consumes(); end

  def definition?(); end

  def doc(); end

  def doc=(doc); end

  def ensure_in_catalog(scope, parameters=T.unsafe(nil)); end

  def evaluate_code(resource); end

  def evaluate_produces(resource, scope); end

  def file(); end

  def file=(file); end

  def hostclass?(); end

  def initialize(type, name, options=T.unsafe(nil)); end

  def instantiate_resource(scope, resource); end

  def is_capability?(); end

  def line(); end

  def line=(line); end

  def match(string); end

  def merge(other); end

  def module_name(); end

  def name(); end

  def name_is_regex?(); end

  def namespace(); end

  def node?(); end

  def parent(); end

  def parent=(parent); end

  def parent_type(scope=T.unsafe(nil)); end

  def produces(); end

  def resource_type_collection(); end

  def resource_type_collection=(resource_type_collection); end

  def set_argument_types(name_to_type_hash); end

  def set_arguments(arguments); end

  def set_resource_parameters(resource, scope); end

  def site?(); end

  def type(); end

  def valid_parameter?(param); end

  def validate_resource(resource); end
  CALLER_MODULE_NAME = ::T.let(nil, ::T.untyped)
  DOUBLE_COLON = ::T.let(nil, ::T.untyped)
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  KIND = ::T.let(nil, ::T.untyped)
  MODULE_NAME = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NODES = ::T.let(nil, ::T.untyped)
  PARAMETERS = ::T.let(nil, ::T.untyped)
  RESOURCE_EXTERNAL_NAMES_TO_KINDS = ::T.let(nil, ::T.untyped)
  RESOURCE_KINDS = ::T.let(nil, ::T.untyped)
  RESOURCE_KINDS_TO_EXTERNAL_NAMES = ::T.let(nil, ::T.untyped)
  TITLE = ::T.let(nil, ::T.untyped)
end

class Puppet::Resource::Type
end

class Puppet::Resource::TypeCollection
  include ::Puppet::Util::Warnings
  def <<(thing); end

  def add(instance); end

  def add_application(instance); end

  def add_capability_mapping(instance); end

  def add_definition(instance); end

  def add_hostclass(instance); end

  def add_node(instance); end

  def add_site(instance); end

  def application(name); end

  def applications(); end

  def capability_mappings(); end

  def clear(); end

  def definition(name); end

  def definitions(); end

  def environment(); end

  def find_application(name); end

  def find_definition(name); end

  def find_hostclass(name); end

  def find_node(name); end

  def find_site(); end

  def handle_hostclass_merge(instance); end

  def hostclass(name); end

  def hostclasses(); end

  def import_ast(ast, modname); end

  def initialize(env); end

  def loader(); end

  def node(name); end

  def node_exists?(name); end

  def nodes(); end

  def nodes?(); end

  def parse_failed(); end

  def parse_failed=(parse_failed); end

  def parse_failed?(); end

  def replace_settings(instance); end

  def site(_); end

  def version(); end
  COLON_COLON = ::T.let(nil, ::T.untyped)
end

class Puppet::Resource::TypeCollection
end

module Puppet::Resource::Validator
  def validate_key(request); end
end

module Puppet::Resource::Validator
  extend ::T::Sig
end

class Puppet::Resource
  extend ::Puppet::Indirector
  extend ::Puppet::Indirector::ClassMethods
  def self.from_data_hash(data); end

  def self.resource_type(type, title, environment); end

  def self.type_and_title(type, title); end

  def self.value_to_json_data(value); end
end

class Puppet::ResourceError
  include ::Puppet::ExternalFileError
end

class Puppet::ResourceError
end

Puppet::ResourceType = Puppet::Resource::Type

module Puppet::Rest
end

class Puppet::Rest::ResponseError
  def initialize(msg, response=T.unsafe(nil)); end

  def response(); end
end

class Puppet::Rest::ResponseError
end

class Puppet::Rest::Route
  def initialize(api:, server_setting: T.unsafe(nil), port_setting: T.unsafe(nil), srv_service: T.unsafe(nil)); end

  def server(); end

  def with_base_url(dns_resolver); end
end

class Puppet::Rest::Route
end

module Puppet::Rest::Routes
  ACCEPT_ENCODING = ::T.let(nil, ::T.untyped)
end

module Puppet::Rest::Routes
  extend ::Puppet::Network::HTTP::Compression::Active
  extend ::T::Sig
  def self.ca(); end

  def self.clear(); end

  def self.get_certificate(name, ssl_context); end

  def self.get_certificate_request(name, ssl_context); end

  def self.get_crls(name, ssl_context, if_modified_since: T.unsafe(nil)); end

  def self.put_certificate_request(csr_pem, name, ssl_context); end
end

module Puppet::Rest
  extend ::T::Sig
end

module Puppet::SSL
  CA_NAME = ::T.let(nil, ::T.untyped)
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Puppet::SSL::Base
  def content(); end

  def content=(content); end

  def digest(algorithm=T.unsafe(nil)); end

  def digest_algorithm(); end

  def fingerprint(md=T.unsafe(nil)); end

  def generate(); end

  def initialize(name); end

  def name(); end

  def name=(name); end

  def read(path); end

  def to_data_hash(); end

  def to_text(); end
  SEPARATOR = ::T.let(nil, ::T.untyped)
  VALID_CERTNAME = ::T.let(nil, ::T.untyped)
end

class Puppet::SSL::Base
  def self.from_instance(instance, name=T.unsafe(nil)); end

  def self.from_multiple_s(text); end

  def self.from_s(string, name=T.unsafe(nil)); end

  def self.name_from_subject(subject); end

  def self.to_multiple_s(instances); end

  def self.validate_certname(name); end

  def self.wrapped_class(); end

  def self.wraps(klass); end
end

class Puppet::SSL::CertMismatchError
  def initialize(peer_cert, host); end
end

class Puppet::SSL::CertMismatchError
end

class Puppet::SSL::CertVerifyError
  def cert(); end

  def code(); end

  def initialize(message, code, cert); end
end

class Puppet::SSL::CertVerifyError
end

class Puppet::SSL::Certificate
  include ::Puppet::Indirector::Envelope
  include ::Puppet::Network::FormatSupport
  def custom_extensions(); end

  def subject_alt_names(); end

  def unmunged_name(); end
end

class Puppet::SSL::Certificate::File
end

class Puppet::SSL::Certificate::File
end

class Puppet::SSL::Certificate
  extend ::Puppet::Indirector
  extend ::Puppet::Indirector::ClassMethods
  def self.subject_alt_names_for(cert); end
end

class Puppet::SSL::CertificateRequest
  include ::Puppet::Indirector::Envelope
  include ::Puppet::Network::FormatSupport
  def custom_attributes(); end

  def ext_value_to_ruby_value(asn1_arr); end

  def extension_factory(); end

  def generate(key, options=T.unsafe(nil)); end

  def request_extensions(); end

  def subject_alt_names(); end
  PRIVATE_CSR_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  PRIVATE_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class Puppet::SSL::CertificateRequest::File
end

class Puppet::SSL::CertificateRequest::File
end

class Puppet::SSL::CertificateRequest
  extend ::Puppet::Indirector
  extend ::Puppet::Indirector::ClassMethods
end

class Puppet::SSL::CertificateRequestAttributes
  def custom_attributes(); end

  def extension_requests(); end

  def initialize(path); end

  def load(); end

  def path(); end
end

class Puppet::SSL::CertificateRequestAttributes
end

class Puppet::SSL::CertificateSigner
  def digest(); end

  def sign(content, key); end
end

class Puppet::SSL::CertificateSigner
end

class Puppet::SSL::Digest
  def digest(); end

  def initialize(algorithm, content); end

  def name(); end

  def to_hex(); end
end

class Puppet::SSL::Digest
end

class Puppet::SSL::Host
  def certificate(); end

  def certificate=(certificate); end

  def certificate_request(); end

  def certificate_request=(certificate_request); end

  def check_for_certificate_on_disk(cert_name); end

  def clean_params(); end

  def crl_path(); end

  def crl_usage=(crl_usage); end

  def device(); end

  def download_certificate_from_ca(cert_name); end

  def download_host_certificate(); end

  def generate(); end

  def generate_certificate_request(options=T.unsafe(nil)); end

  def generate_key(); end

  def initialize(name=T.unsafe(nil), device=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def name(); end

  def public_key(); end

  def puppet_params(); end

  def save_host_certificate(cert); end

  def ssl_store(purpose=T.unsafe(nil)); end

  def use_crl?(); end

  def use_crl_chain?(); end

  def validate_certificate_with_key(cert); end

  def wait_for_cert(time); end
  CA_NAME = ::T.let(nil, ::T.untyped)
end

Puppet::SSL::Host::Certificate = Puppet::SSL::Certificate

Puppet::SSL::Host::CertificateRequest = Puppet::SSL::CertificateRequest

Puppet::SSL::Host::Key = Puppet::SSL::Key

class Puppet::SSL::Host
  def self.configure_indirection(terminus, cache=T.unsafe(nil)); end

  def self.from_data_hash(data); end

  def self.localhost(); end

  def self.reset(); end
end

class Puppet::SSL::Key
  include ::Puppet::Indirector::Envelope
  include ::Puppet::Network::FormatSupport
  def password(); end

  def password_file(); end

  def password_file=(password_file); end
end

class Puppet::SSL::Key::File
  def public_key_path(name); end
end

class Puppet::SSL::Key::File
end

class Puppet::SSL::Key
  extend ::Puppet::Indirector
  extend ::Puppet::Indirector::ClassMethods
end

module Puppet::SSL::Oids
  PUPPET_OIDS = ::T.let(nil, ::T.untyped)
end

module Puppet::SSL::Oids
  extend ::T::Sig
  def self.load_custom_oid_file(custom_oid_file, map_key=T.unsafe(nil)); end

  def self.parse_custom_oid_file(custom_oid_file, map_key=T.unsafe(nil)); end

  def self.register_puppet_oids(); end

  def self.subtree_of?(first, second, exclusive=T.unsafe(nil)); end
end

class Puppet::SSL::SSLContext
  def cacerts(); end

  def cacerts=(_); end

  def client_cert(); end

  def client_cert=(_); end

  def client_chain(); end

  def client_chain=(_); end

  def crls(); end

  def crls=(_); end

  def initialize(**kwargs); end

  def private_key(); end

  def private_key=(_); end

  def revocation(); end

  def revocation=(_); end

  def store(); end

  def store=(_); end

  def verify_peer(); end

  def verify_peer=(_); end
end

class Puppet::SSL::SSLContext
  def self.[](*_); end

  def self.members(); end
end

class Puppet::SSL::SSLError
end

class Puppet::SSL::SSLError
end

class Puppet::SSL::SSLProvider
  def create_context(cacerts:, crls:, private_key:, client_cert:, revocation: T.unsafe(nil)); end

  def create_insecure_context(); end

  def create_root_context(cacerts:, crls: T.unsafe(nil), revocation: T.unsafe(nil)); end

  def load_context(certname: T.unsafe(nil), revocation: T.unsafe(nil), password: T.unsafe(nil)); end

  def verify_request(csr, public_key); end
end

class Puppet::SSL::SSLProvider
end

class Puppet::SSL::StateMachine
  def cert_provider(); end

  def ensure_ca_certificates(); end

  def ensure_client_certificate(); end

  def initialize(waitforcert: T.unsafe(nil), maxwaitforcert: T.unsafe(nil), cert_provider: T.unsafe(nil), ssl_provider: T.unsafe(nil), lockfile: T.unsafe(nil)); end

  def ssl_provider(); end

  def wait_deadline(); end

  def waitforcert(); end
end

class Puppet::SSL::StateMachine::Done
end

class Puppet::SSL::StateMachine::Done
end

class Puppet::SSL::StateMachine::KeySSLState
  def initialize(machine, ssl_context, private_key); end

  def private_key(); end
end

class Puppet::SSL::StateMachine::KeySSLState
end

class Puppet::SSL::StateMachine::NeedCACerts
  def initialize(machine); end

  def next_state(); end
end

class Puppet::SSL::StateMachine::NeedCACerts
end

class Puppet::SSL::StateMachine::NeedCRLs
  def next_state(); end
end

class Puppet::SSL::StateMachine::NeedCRLs
end

class Puppet::SSL::StateMachine::NeedCert
  def next_state(); end
end

class Puppet::SSL::StateMachine::NeedCert
end

class Puppet::SSL::StateMachine::NeedKey
  def next_state(); end
end

class Puppet::SSL::StateMachine::NeedKey
end

class Puppet::SSL::StateMachine::NeedSubmitCSR
  def next_state(); end
end

class Puppet::SSL::StateMachine::NeedSubmitCSR
end

class Puppet::SSL::StateMachine::SSLState
  def initialize(machine, ssl_context); end

  def ssl_context(); end
end

class Puppet::SSL::StateMachine::SSLState
end

class Puppet::SSL::StateMachine::Wait
  def next_state(); end
end

class Puppet::SSL::StateMachine::Wait
end

class Puppet::SSL::StateMachine
end

class Puppet::SSL::Validator
  def peer_certs(); end

  def setup_connection(connection); end

  def verify_errors(); end
end

class Puppet::SSL::Validator::DefaultValidator
  def call(preverify_ok, store_context); end

  def decode_cert_bundle(bundle_str); end

  def has_authz_peer_cert(peer_certs, authz_certs); end

  def initialize(ca_path=T.unsafe(nil)); end

  def last_error(); end

  def peer_certs(); end

  def read_file(path); end

  def reset!(); end

  def setup_connection(connection, ssl_host=T.unsafe(nil)); end

  def ssl_certificates_are_present?(); end

  def valid_peer?(); end

  def verify_errors(); end
  FIVE_MINUTES_AS_SECONDS = ::T.let(nil, ::T.untyped)
end

class Puppet::SSL::Validator::DefaultValidator
end

class Puppet::SSL::Validator::NoValidator
end

class Puppet::SSL::Validator::NoValidator
end

class Puppet::SSL::Validator
  def self.default_validator(); end

  def self.no_validator(); end
end

class Puppet::SSL::Verifier
  def call(preverify_ok, store_context); end

  def handle_connection_error(http, error); end

  def initialize(hostname, ssl_context); end

  def reusable?(verifier); end

  def setup_connection(http); end

  def ssl_context(); end
  FIVE_MINUTES_AS_SECONDS = ::T.let(nil, ::T.untyped)
end

class Puppet::SSL::Verifier
end

class Puppet::SSL::VerifierAdapter
  def handle_connection_error(http, error); end

  def initialize(validator); end

  def reusable?(verifier); end

  def setup_connection(http); end

  def validator(); end
end

class Puppet::SSL::VerifierAdapter
end

module Puppet::SSL
  extend ::T::Sig
end

class Puppet::Settings
  include ::Enumerable
  def [](param); end

  def []=(param, value); end

  def addargs(options); end

  def app_defaults_initialized?(); end

  def apply_metadata_from_section(section); end

  def boolean?(param); end

  def clear(); end

  def clear_environment_settings(environment); end

  def clearused(); end

  def configsearchpath(environment=T.unsafe(nil), run_mode=T.unsafe(nil)); end

  def define_settings(section, defs); end

  def description(name); end

  def each(*args, &block); end

  def each_key(*args, &block); end

  def each_pair(*args, &block); end

  def eachsection(); end

  def files=(files); end

  def flush_cache(); end

  def generate_config(); end

  def generate_manifest(); end

  def global_defaults_initialized?(); end

  def handlearg(opt, value=T.unsafe(nil)); end

  def include?(name); end

  def initialize_app_defaults(app_defaults); end

  def initialize_global_settings(args=T.unsafe(nil), require_config=T.unsafe(nil)); end

  def optparse_addargs(options); end

  def override_default(param, value); end

  def parse_config(text, file=T.unsafe(nil)); end

  def parse_file(file, allowed_sections=T.unsafe(nil)); end

  def patch_value(param, value, type); end

  def persection(section); end

  def preferred_run_mode(); end

  def preferred_run_mode=(mode); end

  def print_config_options(); end

  def print_configs(); end

  def print_configs?(); end

  def reparse_config_files(); end

  def reuse(); end

  def searchpath(environment=T.unsafe(nil), run_mode=T.unsafe(nil)); end

  def searchpath_values(source); end

  def service_group_available?(); end

  def service_user_available?(); end

  def set_by_cli?(param); end

  def set_by_config?(param, environment=T.unsafe(nil), run_mode=T.unsafe(nil)); end

  def setting(param); end

  def timer(); end

  def to_catalog(*sections); end

  def to_config(); end

  def to_manifest(); end

  def use(*sections); end

  def valid?(param); end

  def value(param, environment=T.unsafe(nil), bypass_interpolation=T.unsafe(nil)); end

  def value_sym(param, environment=T.unsafe(nil), bypass_interpolation=T.unsafe(nil)); end

  def values(environment, section); end

  def which_configuration_file(); end
  ALLOWED_SECTION_NAMES = ::T.let(nil, ::T.untyped)
  DEPRECATION_REFS = ::T.let(nil, ::T.untyped)
  NONE = ::T.let(nil, ::T.untyped)
  REQUIRED_APP_SETTINGS = ::T.let(nil, ::T.untyped)
  SETTING_TYPES = ::T.let(nil, ::T.untyped)
end

class Puppet::Settings::ArraySetting
  def type(); end
end

class Puppet::Settings::ArraySetting
end

class Puppet::Settings::AutosignSetting
end

class Puppet::Settings::AutosignSetting
end

class Puppet::Settings::BaseSetting
  def allowed_on_commandline?(); end

  def call_hook(); end

  def call_hook=(value); end

  def call_hook_on_define?(); end

  def call_hook_on_initialize?(); end

  def completely_deprecated?(); end

  def default(check_application_defaults_first=T.unsafe(nil)); end

  def default=(default); end

  def deprecated(); end

  def deprecated=(deprecation); end

  def deprecated?(); end

  def desc(); end

  def desc=(desc); end

  def getopt_args(); end

  def has_hook?(); end

  def hook=(block); end

  def initialize(args=T.unsafe(nil)); end

  def iscreated(); end

  def iscreated?(); end

  def munge(value); end

  def name(); end

  def name=(name); end

  def optparse_args(); end

  def print(value); end

  def section(); end

  def section=(section); end

  def set_meta(meta); end

  def short(); end

  def short=(value); end

  def to_config(); end

  def value(bypass_interpolation=T.unsafe(nil)); end
end

class Puppet::Settings::BaseSetting
  def self.available_call_hook_values(); end
end

class Puppet::Settings::BooleanSetting
  def type(); end
end

class Puppet::Settings::BooleanSetting
end

class Puppet::Settings::CertificateRevocationSetting
  def type(); end
end

class Puppet::Settings::CertificateRevocationSetting
end

class Puppet::Settings::ChainedValues
  def initialize(mode, environment, value_sets, defaults); end

  def interpolate(name); end

  def lookup(name); end

  def print(name); end
  ENVIRONMENT_INTERPOLATION_ALLOWED = ::T.let(nil, ::T.untyped)
  ENVIRONMENT_SETTING = ::T.let(nil, ::T.untyped)
end

class Puppet::Settings::ChainedValues
end

class Puppet::Settings::ConfigFile
  def initialize(value_converter); end

  def parse_file(file, text, allowed_section_names=T.unsafe(nil)); end
  NO_META = ::T.let(nil, ::T.untyped)
end

class Puppet::Settings::ConfigFile::Conf
  def initialize(); end

  def sections(); end

  def sections=(_); end

  def with_section(section); end
end

class Puppet::Settings::ConfigFile::Conf
  def self.[](*_); end

  def self.members(); end
end

class Puppet::Settings::ConfigFile::Meta
  def group(); end

  def group=(_); end

  def mode(); end

  def mode=(_); end

  def owner(); end

  def owner=(_); end
end

class Puppet::Settings::ConfigFile::Meta
  def self.[](*_); end

  def self.members(); end
end

class Puppet::Settings::ConfigFile::Section
  def initialize(name); end

  def name(); end

  def name=(_); end

  def setting(name); end

  def settings(); end

  def settings=(_); end

  def with_setting(name, value, meta); end
end

class Puppet::Settings::ConfigFile::Section
  def self.[](*_); end

  def self.members(); end
end

class Puppet::Settings::ConfigFile::Setting
  def has_metadata?(); end

  def meta(); end

  def meta=(_); end

  def name(); end

  def name=(_); end

  def value(); end

  def value=(_); end
end

class Puppet::Settings::ConfigFile::Setting
  def self.[](*_); end

  def self.members(); end
end

class Puppet::Settings::ConfigFile
end

class Puppet::Settings::DirectorySetting
  def open_file(filename, option=T.unsafe(nil), &block); end
end

class Puppet::Settings::DirectorySetting
end

class Puppet::Settings::DurationSetting
  def type(); end
  FORMAT = ::T.let(nil, ::T.untyped)
  UNITMAP = ::T.let(nil, ::T.untyped)
end

class Puppet::Settings::DurationSetting
end

class Puppet::Settings::EnumSetting
  def type(); end

  def values(); end

  def values=(values); end
end

class Puppet::Settings::EnumSetting
end

class Puppet::Settings::EnvironmentConf
  def config_version(); end

  def environment_data_provider(); end

  def environment_timeout(); end

  def global_modulepath(); end

  def initialize(path_to_env, section, global_module_path); end

  def manifest(); end

  def modulepath(); end

  def path_to_env(); end

  def raw_setting(setting_name); end

  def rich_data(); end

  def section(); end

  def static_catalogs(); end
  ENVIRONMENT_CONF_ONLY_SETTINGS = ::T.let(nil, ::T.untyped)
  VALID_SETTINGS = ::T.let(nil, ::T.untyped)
end

class Puppet::Settings::EnvironmentConf::Static
  def config_version(); end

  def environment_data_provider(); end

  def environment_timeout(); end

  def initialize(environment, environment_timeout, static_catalogs, environment_data_provider=T.unsafe(nil), rich_data=T.unsafe(nil)); end

  def manifest(); end

  def modulepath(); end

  def path_to_env(); end

  def rich_data(); end

  def static_catalogs(); end
end

class Puppet::Settings::EnvironmentConf::Static
end

class Puppet::Settings::EnvironmentConf
  def self.load_from(path_to_env, global_module_path); end

  def self.static_for(environment, environment_timeout=T.unsafe(nil), static_catalogs=T.unsafe(nil), rich_data=T.unsafe(nil)); end

  def self.validate(path_to_conf_file, config); end
end

class Puppet::Settings::FileOrDirectorySetting
  def open_file(filename, option=T.unsafe(nil), &block); end
end

class Puppet::Settings::FileOrDirectorySetting
end

class Puppet::Settings::FileSetting
  def create(); end

  def create=(create); end

  def create_files?(); end

  def exclusive_open(option=T.unsafe(nil), &block); end

  def group(); end

  def group=(value); end

  def initialize(args); end

  def mode(); end

  def mode=(mode); end

  def open(option=T.unsafe(nil), &block); end

  def owner(); end

  def owner=(value); end

  def to_resource(); end
end

class Puppet::Settings::FileSetting::Root
  def value(); end
end

class Puppet::Settings::FileSetting::Root
end

class Puppet::Settings::FileSetting::Service
  def initialize(name, fallback, settings, available_method); end

  def value(); end
end

class Puppet::Settings::FileSetting::Service
end

class Puppet::Settings::FileSetting::SettingError
end

class Puppet::Settings::FileSetting::SettingError
end

class Puppet::Settings::FileSetting::Unspecified
  def value(); end
end

class Puppet::Settings::FileSetting::Unspecified
end

class Puppet::Settings::FileSetting
end

class Puppet::Settings::IniFile
  def append(line); end

  def delete(section, name); end

  def initialize(lines=T.unsafe(nil)); end

  def insert_after(line, new_line); end

  def lines_in(section_name); end

  def section_exists_with_default_section_name?(); end

  def section_line(name); end

  def section_lines(); end

  def set_default_section_write_sectionline(value); end

  def setting(section, name); end

  def settings_exist_in_default_section?(); end

  def settings_in(lines); end

  def write(fh); end
  DEFAULT_SECTION_NAME = ::T.let(nil, ::T.untyped)
end

class Puppet::Settings::IniFile::DefaultSection
  def initialize(); end

  def write_sectionline(); end

  def write_sectionline=(write_sectionline); end
end

class Puppet::Settings::IniFile::DefaultSection
end

class Puppet::Settings::IniFile::Line
  include ::Puppet::Settings::IniFile::LineNumber
  def text(); end

  def text=(_); end

  def write(fh); end
end

class Puppet::Settings::IniFile::Line
  def self.[](*_); end

  def self.members(); end
end

module Puppet::Settings::IniFile::LineNumber
  def line_number(); end

  def previous(); end

  def previous=(previous); end
end

module Puppet::Settings::IniFile::LineNumber
  extend ::T::Sig
end

class Puppet::Settings::IniFile::Manipulator
  def delete(section_name, name); end

  def initialize(config); end

  def set(section, name, value); end
end

class Puppet::Settings::IniFile::Manipulator
end

class Puppet::Settings::IniFile::SectionLine
  include ::Puppet::Settings::IniFile::LineNumber
  def name(); end

  def name=(_); end

  def prefix(); end

  def prefix=(_); end

  def suffix(); end

  def suffix=(_); end

  def write(fh); end
end

class Puppet::Settings::IniFile::SectionLine
  def self.[](*_); end

  def self.members(); end
end

class Puppet::Settings::IniFile::SettingLine
  include ::Puppet::Settings::IniFile::LineNumber
  def ==(other); end

  def infix(); end

  def infix=(_); end

  def name(); end

  def name=(_); end

  def prefix(); end

  def prefix=(_); end

  def suffix(); end

  def suffix=(_); end

  def value(); end

  def value=(_); end

  def write(fh); end
end

class Puppet::Settings::IniFile::SettingLine
  def self.[](*_); end

  def self.members(); end
end

class Puppet::Settings::IniFile
  def self.parse(config_fh); end

  def self.update(config_fh, &block); end
end

class Puppet::Settings::InterpolationError
end

class Puppet::Settings::InterpolationError
end

class Puppet::Settings::ParseError
  include ::Puppet::ExternalFileError
end

class Puppet::Settings::ParseError
end

class Puppet::Settings::PathSetting
end

class Puppet::Settings::PathSetting
end

class Puppet::Settings::PrioritySetting
  def type(); end
  PRIORITY_MAP = ::T.let(nil, ::T.untyped)
end

class Puppet::Settings::PrioritySetting
end

Puppet::Settings::PuppetOptionParser = Puppet::Util::CommandLine::PuppetOptionParser

class Puppet::Settings::SearchPathElement
end

class Puppet::Settings::SearchPathElement
end

class Puppet::Settings::ServerListSetting
end

class Puppet::Settings::ServerListSetting
end

class Puppet::Settings::SettingsError
end

class Puppet::Settings::SettingsError
end

class Puppet::Settings::StringSetting
  def type(); end

  def validate(value); end
end

class Puppet::Settings::StringSetting
end

class Puppet::Settings::SymbolicEnumSetting
  def type(); end

  def values(); end

  def values=(values); end
end

class Puppet::Settings::SymbolicEnumSetting
end

class Puppet::Settings::TTLSetting
  def type(); end
  FORMAT = ::T.let(nil, ::T.untyped)
  UNITMAP = ::T.let(nil, ::T.untyped)
end

class Puppet::Settings::TTLSetting
  def self.munge(value, param_name); end
end

class Puppet::Settings::TerminusSetting
end

class Puppet::Settings::TerminusSetting
end

class Puppet::Settings::ValidationError
end

class Puppet::Settings::ValidationError
end

class Puppet::Settings::ValueTranslator
  def [](value); end
end

class Puppet::Settings::ValueTranslator
end

class Puppet::Settings::Values
  def include?(*args, &block); end

  def initialize(name, defaults); end

  def lookup(*args, &block); end

  def name(); end

  def set(name, value); end
end

class Puppet::Settings::Values
  extend ::Forwardable
end

class Puppet::Settings::ValuesFromEnvironmentConf
  def conf(); end

  def include?(name); end

  def initialize(environment_name); end

  def lookup(name); end

  def name(); end
end

class Puppet::Settings::ValuesFromEnvironmentConf
end

class Puppet::Settings::ValuesFromSection
  def include?(name); end

  def initialize(name, section); end

  def lookup(name); end

  def name(); end
end

class Puppet::Settings::ValuesFromSection
end

class Puppet::Settings
  extend ::Forwardable
  def self.app_defaults_for_run_mode(run_mode); end

  def self.clean_opt(opt, val); end

  def self.default_certname(); end

  def self.default_config_file_name(); end

  def self.domain_fact(); end

  def self.hostname_fact(); end
end

class Puppet::Status
  include ::Puppet::Indirector::Envelope
  include ::Puppet::Network::FormatSupport
  def initialize(status=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def status(); end

  def status=(status); end

  def to_data_hash(); end

  def version(); end

  def version=(version); end
end

class Puppet::Status
  extend ::Puppet::Indirector
  extend ::Puppet::Indirector::ClassMethods
  def self.from_data_hash(data); end
end

class Puppet::SubclassAlreadyDefined
end

class Puppet::SubclassAlreadyDefined
end

module Puppet::SyntaxCheckers
end

class Puppet::SyntaxCheckers::Base64
  def check(text, syntax, acceptor, source_pos); end
end

class Puppet::SyntaxCheckers::Base64
end

class Puppet::SyntaxCheckers::EPP
  def check(text, syntax, acceptor, source_pos); end
end

class Puppet::SyntaxCheckers::EPP
end

class Puppet::SyntaxCheckers::Json
  def check(text, syntax, acceptor, source_pos); end
end

class Puppet::SyntaxCheckers::Json
end

class Puppet::SyntaxCheckers::PP
  def check(text, syntax, acceptor, source_pos); end
end

class Puppet::SyntaxCheckers::PP
end

module Puppet::SyntaxCheckers
  extend ::T::Sig
end

module Puppet::Test
end

class Puppet::Test::LogCollector
  def <<(value); end

  def initialize(logs); end
end

class Puppet::Test::LogCollector
end

module Puppet::Test
  extend ::T::Sig
end

class Puppet::Transaction
  include ::Puppet::Util
  include ::Puppet::Util::Tagging
  def any_failed?(); end

  def catalog(); end

  def catalog=(catalog); end

  def changed?(); end

  def evaluate(&block); end

  def event_manager(); end

  def for_network_device(); end

  def for_network_device=(for_network_device); end

  def ignoreschedules(); end

  def ignoreschedules=(ignoreschedules); end

  def initialize(catalog, report, prioritizer); end

  def missing_tags?(resource); end

  def perform_pre_run_checks(); end

  def persistence(); end

  def prefetch_failed_providers(); end

  def prefetch_if_necessary(resource); end

  def prefetched_providers(); end

  def relationship_graph(); end

  def report(); end

  def resource_harness(); end

  def resource_status(resource); end

  def skip?(resource); end

  def skip_tags(); end

  def stop_processing?(); end
end

class Puppet::Transaction::AdditionalResourceGenerator
  def eval_generate(resource); end

  def generate_additional_resources(resource); end

  def initialize(catalog, relationship_graph, prioritizer); end

  def relationship_graph=(relationship_graph); end

  def resources_failed_to_generate(); end
end

class Puppet::Transaction::AdditionalResourceGenerator
end

class Puppet::Transaction::Event
  include ::Puppet::Util::Tagging
  include ::Puppet::Util::Logging
  include ::Puppet::Network::FormatSupport
  def ==(event); end

  def audited(); end

  def audited=(audited); end

  def calculate_corrective_change(old_system_value); end

  def corrective_change(); end

  def corrective_change=(corrective_change); end

  def default_log_level(); end

  def desired_value(); end

  def desired_value=(desired_value); end

  def eql?(event); end

  def file(); end

  def file=(file); end

  def historical_value(); end

  def historical_value=(historical_value); end

  def initialize(audited: T.unsafe(nil), corrective_change: T.unsafe(nil), desired_value: T.unsafe(nil), file: T.unsafe(nil), historical_value: T.unsafe(nil), invalidate_refreshes: T.unsafe(nil), line: T.unsafe(nil), message: T.unsafe(nil), name: T.unsafe(nil), previous_value: T.unsafe(nil), property: T.unsafe(nil), redacted: T.unsafe(nil), resource: T.unsafe(nil), source_description: T.unsafe(nil), status: T.unsafe(nil), tags: T.unsafe(nil)); end

  def initialize_from_hash(data); end

  def invalidate_refreshes(); end

  def invalidate_refreshes=(invalidate_refreshes); end

  def line(); end

  def line=(line); end

  def message(); end

  def message=(message); end

  def name(); end

  def name=(name); end

  def previous_value(); end

  def previous_value=(previous_value); end

  def property(); end

  def property=(prop); end

  def redacted(); end

  def redacted=(redacted); end

  def resource(); end

  def resource=(res); end

  def send_log(); end

  def source_description(); end

  def source_description=(source_description); end

  def status(); end

  def status=(value); end

  def time(); end

  def time=(time); end

  def to_data_hash(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
  EVENT_STATUSES = ::T.let(nil, ::T.untyped)
end

class Puppet::Transaction::Event
  def self.from_data_hash(data); end
end

class Puppet::Transaction::EventManager
  def dequeue_all_events_for_resource(target); end

  def dequeue_events_for_resource(target, callback); end

  def events(); end

  def initialize(transaction); end

  def process_events(resource); end

  def queue_events(resource, events); end

  def queue_events_for_resource(source, target, callback, events); end

  def queued_events(resource); end

  def relationship_graph(); end

  def transaction(); end
end

class Puppet::Transaction::EventManager
end

class Puppet::Transaction::Persistence
  def copy_skipped(resource_name); end

  def data(); end

  def enabled?(catalog); end

  def get_system_value(resource_name, param_name); end

  def load(); end

  def save(); end

  def set_system_value(resource_name, param_name, value); end
end

class Puppet::Transaction::Persistence
end

class Puppet::Transaction::Report
  include ::Puppet::Util::PsychSupport
  include ::Puppet::Indirector::Envelope
  include ::Puppet::Network::FormatSupport
  def <<(msg); end

  def add_metric(name, hash); end

  def add_resource_status(status); end

  def add_times(name, value, accumulate=T.unsafe(nil)); end

  def as_logging_destination(&block); end

  def cached_catalog_status(); end

  def cached_catalog_status=(cached_catalog_status); end

  def catalog_uuid(); end

  def catalog_uuid=(catalog_uuid); end

  def code_id(); end

  def code_id=(code_id); end

  def compute_status(resource_metrics, change_metric); end

  def configuration_version(); end

  def configuration_version=(configuration_version); end

  def corrective_change(); end

  def environment(); end

  def environment=(environment); end

  def exit_status(); end

  def finalize_report(); end

  def has_noop_events?(resource); end

  def host(); end

  def host=(host); end

  def initialize(configuration_version=T.unsafe(nil), environment=T.unsafe(nil), transaction_uuid=T.unsafe(nil), job_id=T.unsafe(nil)); end

  def initialize_from_hash(data); end

  def job_id(); end

  def job_id=(job_id); end

  def logs(); end

  def master_used(); end

  def master_used=(master_used); end

  def metrics(); end

  def name(); end

  def noop(); end

  def noop_pending(); end

  def noop_pending=(noop_pending); end

  def prune_internal_data(); end

  def puppet_version(); end

  def raw_summary(); end

  def report_format(); end

  def resource_statuses(); end

  def resources_failed_to_generate(); end

  def resources_failed_to_generate=(resources_failed_to_generate); end

  def status(); end

  def summary(); end

  def time(); end

  def to_data_hash(); end

  def transaction_completed(); end

  def transaction_completed=(transaction_completed); end

  def transaction_uuid(); end

  def transaction_uuid=(transaction_uuid); end
  TOTAL = ::T.let(nil, ::T.untyped)
end

class Puppet::Transaction::Report::Processor
  def destroy(request); end

  def save(request); end
end

class Puppet::Transaction::Report::Processor
end

class Puppet::Transaction::Report
  extend ::Puppet::Indirector
  extend ::Puppet::Indirector::ClassMethods
  def self.from_data_hash(data); end
end

class Puppet::Transaction::ResourceHarness
  def cache(resource, name, value); end

  def cached(resource, name); end

  def evaluate(resource); end

  def initialize(transaction); end

  def relationship_graph(*args, &block); end

  def schedule(resource); end

  def scheduled?(resource); end

  def transaction(); end
  NO_ACTION = ::T.let(nil, ::T.untyped)
end

class Puppet::Transaction::ResourceHarness::ResourceApplicationContext
  def audited_params(); end

  def audited_params=(_); end

  def current_values(); end

  def current_values=(_); end

  def historical_values(); end

  def historical_values=(_); end

  def record(event); end

  def resource(); end

  def resource=(_); end

  def resource_present?(); end

  def status(); end

  def status=(_); end

  def synced_params(); end

  def synced_params=(_); end

  def system_value_params(); end

  def system_value_params=(_); end
end

class Puppet::Transaction::ResourceHarness::ResourceApplicationContext
  def self.[](*_); end

  def self.from_resource(resource, status); end

  def self.members(); end
end

class Puppet::Transaction::ResourceHarness
  extend ::Forwardable
end

class Puppet::Transaction
end

class Puppet::Type
  include ::Puppet::Util
  include ::Puppet::Util::Errors
  include ::Puppet::Util::Logging
  include ::Puppet::Util::Tagging
  include ::Comparable
  include ::Enumerable
  def [](name); end

  def []=(name, value); end

  def add_property_parameter(prop_name); end

  def ancestors(); end

  def appliable_to_device?(); end

  def appliable_to_host?(); end

  def autobefore(rel_catalog=T.unsafe(nil)); end

  def autonotify(rel_catalog=T.unsafe(nil)); end

  def autorelation(rel_type, rel_catalog=T.unsafe(nil)); end

  def autorequire(rel_catalog=T.unsafe(nil)); end

  def autosubscribe(rel_catalog=T.unsafe(nil)); end

  def builddepends(); end

  def catalog(); end

  def catalog=(catalog); end

  def currentpropvalues(); end

  def delete(attr); end

  def deleting?(); end

  def depthfirst?(); end

  def eachparameter(); end

  def eachproperty(); end

  def event(options=T.unsafe(nil)); end

  def exported(); end

  def exported=(exported); end

  def exported?(); end

  def file(); end

  def file=(file); end

  def finish(); end

  def flush(); end

  def initialize(resource); end

  def insync?(is); end

  def isomorphic?(); end

  def line(); end

  def line=(line); end

  def log(msg); end

  def managed?(); end

  def name(); end

  def name_var(); end

  def newattr(name); end

  def noop(); end

  def noop=(noop); end

  def noop?(); end

  def original_parameters(); end

  def parameter(name); end

  def parameters(); end

  def parameters_with_value(); end

  def parent(); end

  def path(); end

  def pathbuilder(); end

  def pre_run_check(); end

  def present?(current_values); end

  def properties(); end

  def property(name); end

  def propertydefined?(name); end

  def provider(); end

  def provider=(name); end

  def purging(); end

  def purging?(); end

  def ref(); end

  def remove(); end

  def retrieve(); end

  def retrieve_resource(); end

  def self_refresh?(); end

  def set_default(attr); end

  def set_sensitive_parameters(sensitive_parameters); end

  def should(name); end

  def suitable?(); end

  def tags=(list); end

  def title(); end

  def title=(title); end

  def to_hash(); end

  def to_resource(); end

  def type(); end

  def uniqueness_key(); end

  def value(name); end

  def version(); end

  def virtual(); end

  def virtual=(virtual); end

  def virtual?(); end
end

class Puppet::Type::MetaParamAlias
  def unsafe_munge(aliases); end
end

class Puppet::Type::MetaParamAlias
end

class Puppet::Type::MetaParamAudit
  def all_properties(); end

  def properties_to_audit(list); end

  def unsafe_munge(args); end

  def unsafe_validate(list); end
end

class Puppet::Type::MetaParamAudit
end

class Puppet::Type::MetaParamBefore
end

class Puppet::Type::MetaParamBefore
end

class Puppet::Type::MetaParamConsume
end

class Puppet::Type::MetaParamConsume
end

class Puppet::Type::MetaParamExport
end

class Puppet::Type::MetaParamExport
end

class Puppet::Type::MetaParamLoglevel
  def default(); end

  def unsafe_munge(loglevel); end
end

class Puppet::Type::MetaParamLoglevel
end

class Puppet::Type::MetaParamNoop
end

class Puppet::Type::MetaParamNoop
end

class Puppet::Type::MetaParamNotify
end

class Puppet::Type::MetaParamNotify
end

class Puppet::Type::MetaParamRequire
end

class Puppet::Type::MetaParamRequire
end

class Puppet::Type::MetaParamSchedule
end

class Puppet::Type::MetaParamSchedule
end

class Puppet::Type::MetaParamStage
end

class Puppet::Type::MetaParamStage
end

class Puppet::Type::MetaParamSubscribe
end

class Puppet::Type::MetaParamSubscribe
end

class Puppet::Type::MetaParamTag
  def unsafe_munge(tags); end
end

class Puppet::Type::MetaParamTag
end

class Puppet::Type::RelationshipMetaparam
  def munge(references); end

  def to_edges(); end

  def validate_relationship(); end
end

class Puppet::Type::RelationshipMetaparam
  def self.callback(); end

  def self.callback=(callback); end

  def self.direction(); end

  def self.direction=(direction); end

  def self.events(); end

  def self.events=(events); end

  def self.inherited(sub); end

  def self.subclasses(); end

  def self.subclasses=(subclasses); end
end

class Puppet::Type
  extend ::Puppet::CompilableResourceType
  extend ::Puppet::Util::Warnings
  extend ::Puppet::Util::ProviderFeatures
  extend ::Puppet::Util::Docs
  extend ::Enumerable
  extend ::Puppet::MetaType::Manager
  extend ::Puppet::Util::ClassGen
  extend ::Puppet::Util
  extend ::Puppet::Util::Logging
  def self.allattrs(); end

  def self.application?(); end

  def self.apply_to(); end

  def self.apply_to_all(); end

  def self.apply_to_device(); end

  def self.apply_to_host(); end

  def self.attrclass(name); end

  def self.attrtype(attr); end

  def self.autobefore(name, &block); end

  def self.autonotify(name, &block); end

  def self.autorequire(name, &block); end

  def self.autosubscribe(name, &block); end

  def self.can_apply_to(target); end

  def self.defaultprovider(); end

  def self.defaultprovider=(defaultprovider); end

  def self.eachautobefore(); end

  def self.eachautonotify(); end

  def self.eachautorequire(); end

  def self.eachautosubscribe(); end

  def self.eachmetaparam(); end

  def self.ensurable(&block); end

  def self.ensurable?(); end

  def self.handle_param_options(name, options); end

  def self.hash2resource(hash); end

  def self.initvars(); end

  def self.instances(); end

  def self.is_capability(); end

  def self.is_capability=(is_capability); end

  def self.is_capability?(); end

  def self.isomorphic?(); end

  def self.key_attribute_parameters(); end

  def self.key_attributes(); end

  def self.metaparam?(param); end

  def self.metaparamclass(name); end

  def self.metaparamdoc(metaparam); end

  def self.metaparams(); end

  def self.needs_ensure_retrieved(); end

  def self.newmetaparam(name, options=T.unsafe(nil), &block); end

  def self.newparam(name, options=T.unsafe(nil), &block); end

  def self.newproperty(name, options=T.unsafe(nil), &block); end

  def self.paramclass(name); end

  def self.paramdoc(param); end

  def self.parameters(); end

  def self.parameters_to_include(); end

  def self.properties(); end

  def self.propertybyname(name); end

  def self.provide(name, options=T.unsafe(nil), &block); end

  def self.provider(name); end

  def self.provider_hash(); end

  def self.provider_hash_by_type(type); end

  def self.providerloader(); end

  def self.providerloader=(providerloader); end

  def self.providers(); end

  def self.providers_by_source(); end

  def self.providify(); end

  def self.relationship_params(); end

  def self.self_refresh(); end

  def self.self_refresh=(self_refresh); end

  def self.suitableprovider(); end

  def self.title_patterns(); end

  def self.unprovide(name); end

  def self.valid_parameter?(name); end

  def self.validate(&block); end

  def self.validattr?(name); end

  def self.validparameter?(name); end

  def self.validproperties(); end

  def self.validproperty?(name); end

  def self.validprovider?(name); end
end

module Puppet::Util
  AbsolutePathPosix = ::T.let(nil, ::T.untyped)
  AbsolutePathWindows = ::T.let(nil, ::T.untyped)
  DEFAULT_POSIX_MODE = ::T.let(nil, ::T.untyped)
  DEFAULT_WINDOWS_MODE = ::T.let(nil, ::T.untyped)
  RFC_3986_URI_REGEX = ::T.let(nil, ::T.untyped)
end

class Puppet::Util::Autoload
  def changed?(name, env); end

  def expand(name); end

  def files_to_load(env); end

  def initialize(obj, path); end

  def load(name, env); end

  def loadall(env); end

  def loaded?(name); end

  def object(); end

  def object=(object); end

  def path(); end

  def path=(path); end
end

class Puppet::Util::Autoload
  def self.changed?(name, env); end

  def self.cleanpath(path); end

  def self.files_in_dir(dir, path); end

  def self.files_to_load(path, env); end

  def self.gem_directories(); end

  def self.gem_source(); end

  def self.get_file(name, env); end

  def self.load_file(name, env); end

  def self.loadall(path, env); end

  def self.loaded(); end

  def self.loaded=(loaded); end

  def self.loaded?(path); end

  def self.mark_loaded(name, file); end

  def self.module_directories(env); end

  def self.reload_changed(env); end

  def self.search_directories(env); end

  def self.vendored_modules(); end
end

module Puppet::Util::CharacterEncoding
end

module Puppet::Util::CharacterEncoding
  extend ::T::Sig
  def self.convert_to_utf_8(string); end

  def self.override_encoding_to_utf_8(string); end
end

module Puppet::Util::Checksums
end

class Puppet::Util::Checksums::DigestLite
  def <<(str); end

  def initialize(digest, lite=T.unsafe(nil)); end
end

class Puppet::Util::Checksums::DigestLite
end

class Puppet::Util::Checksums::FakeChecksum
  def <<(*args); end
end

class Puppet::Util::Checksums::FakeChecksum
end

module Puppet::Util::Checksums
  extend ::T::Sig
  def self.checksum?(string); end

  def self.checksum_file(digest, filename, lite=T.unsafe(nil)); end

  def self.checksum_stream(digest, block, lite=T.unsafe(nil)); end

  def self.ctime(content); end

  def self.ctime?(string); end

  def self.ctime_file(filename); end

  def self.ctime_stream(&block); end

  def self.known_checksum_types(); end

  def self.md5(content); end

  def self.md5?(string); end

  def self.md5_file(filename, lite=T.unsafe(nil)); end

  def self.md5_hex_length(); end

  def self.md5_stream(lite=T.unsafe(nil), &block); end

  def self.md5lite(content); end

  def self.md5lite?(string); end

  def self.md5lite_file(filename); end

  def self.md5lite_hex_length(); end

  def self.md5lite_stream(&block); end

  def self.mtime(content); end

  def self.mtime?(string); end

  def self.mtime_file(filename); end

  def self.mtime_stream(&block); end

  def self.none(content); end

  def self.none?(string); end

  def self.none_file(filename); end

  def self.none_stream(); end

  def self.sha1(content); end

  def self.sha1?(string); end

  def self.sha1_file(filename, lite=T.unsafe(nil)); end

  def self.sha1_hex_length(); end

  def self.sha1_stream(lite=T.unsafe(nil), &block); end

  def self.sha1lite(content); end

  def self.sha1lite?(string); end

  def self.sha1lite_file(filename); end

  def self.sha1lite_hex_length(); end

  def self.sha1lite_stream(&block); end

  def self.sha224(content); end

  def self.sha224?(string); end

  def self.sha224_file(filename, lite=T.unsafe(nil)); end

  def self.sha224_hex_length(); end

  def self.sha224_stream(lite=T.unsafe(nil), &block); end

  def self.sha256(content); end

  def self.sha256?(string); end

  def self.sha256_file(filename, lite=T.unsafe(nil)); end

  def self.sha256_hex_length(); end

  def self.sha256_stream(lite=T.unsafe(nil), &block); end

  def self.sha256lite(content); end

  def self.sha256lite?(string); end

  def self.sha256lite_file(filename); end

  def self.sha256lite_hex_length(); end

  def self.sha256lite_stream(&block); end

  def self.sha384(content); end

  def self.sha384?(string); end

  def self.sha384_file(filename, lite=T.unsafe(nil)); end

  def self.sha384_hex_length(); end

  def self.sha384_stream(lite=T.unsafe(nil), &block); end

  def self.sha512(content); end

  def self.sha512?(string); end

  def self.sha512_file(filename, lite=T.unsafe(nil)); end

  def self.sha512_hex_length(); end

  def self.sha512_stream(lite=T.unsafe(nil), &block); end

  def self.sumdata(checksum); end

  def self.sumtype(checksum); end
end

module Puppet::Util::ClassGen
  include ::Puppet::Util
  def genclass(name, options=T.unsafe(nil), &block); end

  def genmodule(name, options=T.unsafe(nil), &block); end

  def rmclass(name, options); end
end

module Puppet::Util::ClassGen
  extend ::T::Sig
end

module Puppet::Util::Colors
  def colorize(color, str); end

  def console_color(color, str); end

  def html_color(color, str); end
  BG_BLUE = ::T.let(nil, ::T.untyped)
  BG_CYAN = ::T.let(nil, ::T.untyped)
  BG_GREEN = ::T.let(nil, ::T.untyped)
  BG_HBLUE = ::T.let(nil, ::T.untyped)
  BG_HCYAN = ::T.let(nil, ::T.untyped)
  BG_HGREEN = ::T.let(nil, ::T.untyped)
  BG_HMAGENTA = ::T.let(nil, ::T.untyped)
  BG_HRED = ::T.let(nil, ::T.untyped)
  BG_HWHITE = ::T.let(nil, ::T.untyped)
  BG_HYELLOW = ::T.let(nil, ::T.untyped)
  BG_MAGENTA = ::T.let(nil, ::T.untyped)
  BG_RED = ::T.let(nil, ::T.untyped)
  BG_WHITE = ::T.let(nil, ::T.untyped)
  BG_YELLOW = ::T.let(nil, ::T.untyped)
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  Colormap = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  HBLACK = ::T.let(nil, ::T.untyped)
  HBLUE = ::T.let(nil, ::T.untyped)
  HCYAN = ::T.let(nil, ::T.untyped)
  HGREEN = ::T.let(nil, ::T.untyped)
  HMAGENTA = ::T.let(nil, ::T.untyped)
  HRED = ::T.let(nil, ::T.untyped)
  HWHITE = ::T.let(nil, ::T.untyped)
  HYELLOW = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  RESET = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

module Puppet::Util::Colors
  extend ::T::Sig
end

class Puppet::Util::CommandLine
  include ::Puppet::Util::Limits
  def args(); end

  def execute(); end

  def external_subcommand(); end

  def initialize(zero=T.unsafe(nil), argv=T.unsafe(nil), stdin=T.unsafe(nil)); end

  def subcommand_name(); end
  OPTION_OR_MANIFEST_FILE = ::T.let(nil, ::T.untyped)
end

class Puppet::Util::CommandLine::ApplicationSubcommand
  def initialize(subcommand_name, command_line); end

  def run(); end
end

class Puppet::Util::CommandLine::ApplicationSubcommand
end

class Puppet::Util::CommandLine::ExternalSubcommand
  def initialize(path_to_subcommand, command_line); end

  def run(); end
end

class Puppet::Util::CommandLine::ExternalSubcommand
end

class Puppet::Util::CommandLine::NilSubcommand
  include ::Puppet::Util::Colors
  def initialize(command_line); end

  def run(); end
end

class Puppet::Util::CommandLine::NilSubcommand
end

class Puppet::Util::CommandLine::PuppetOptionError
end

class Puppet::Util::CommandLine::PuppetOptionError
end

class Puppet::Util::CommandLine::PuppetOptionParser
  def ignore_invalid_options(); end

  def ignore_invalid_options=(value); end

  def initialize(usage_msg=T.unsafe(nil)); end

  def on(*args, &block); end

  def parse(*args); end
end

class Puppet::Util::CommandLine::PuppetOptionParser
end

module Puppet::Util::CommandLine::Trollop
  FLOAT_RE = ::T.let(nil, ::T.untyped)
  PARAM_RE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Puppet::Util::CommandLine::Trollop::CommandlineError
end

class Puppet::Util::CommandLine::Trollop::CommandlineError
end

class Puppet::Util::CommandLine::Trollop::HelpNeeded
end

class Puppet::Util::CommandLine::Trollop::HelpNeeded
end

class Puppet::Util::CommandLine::Trollop::Parser
  def banner(s); end

  def conflicts(*syms); end

  def create_default_short_options(); end

  def create_default_short_options=(create_default_short_options); end

  def depends(*syms); end

  def die(arg, msg); end

  def educate(stream=T.unsafe(nil)); end

  def handle_help_and_version(); end

  def handle_help_and_version=(handle_help_and_version); end

  def ignore_invalid_options(); end

  def ignore_invalid_options=(ignore_invalid_options); end

  def initialize(*a, &b); end

  def leftovers(); end

  def opt(name, desc=T.unsafe(nil), opts=T.unsafe(nil)); end

  def parse(cmdline=T.unsafe(nil)); end

  def parse_date_parameter(param, arg); end

  def specs(); end

  def stop_on(*words); end

  def stop_on_unknown(); end

  def text(s); end

  def version(s=T.unsafe(nil)); end

  def width(); end

  def wrap(str, opts=T.unsafe(nil)); end
  FLAG_TYPES = ::T.let(nil, ::T.untyped)
  INVALID_SHORT_ARG_REGEX = ::T.let(nil, ::T.untyped)
  MULTI_ARG_TYPES = ::T.let(nil, ::T.untyped)
  SINGLE_ARG_TYPES = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Puppet::Util::CommandLine::Trollop::Parser
end

class Puppet::Util::CommandLine::Trollop::VersionNeeded
end

class Puppet::Util::CommandLine::Trollop::VersionNeeded
end

module Puppet::Util::CommandLine::Trollop
  extend ::T::Sig
  def self.die(arg, msg=T.unsafe(nil)); end

  def self.options(args=T.unsafe(nil), *a, &b); end

  def self.with_standard_exception_handling(parser); end
end

class Puppet::Util::CommandLine::TrollopCommandlineError
end

class Puppet::Util::CommandLine::TrollopCommandlineError
end

class Puppet::Util::CommandLine::UnknownSubcommand
  def initialize(subcommand_name, command_line); end
end

class Puppet::Util::CommandLine::UnknownSubcommand
end

class Puppet::Util::CommandLine
end

module Puppet::Util::Connection
end

module Puppet::Util::Connection
  extend ::Puppet::Util::Warnings
  extend ::T::Sig
  def self.determine_port(port_setting, server_setting); end

  def self.determine_server(setting); end
end

module Puppet::Util::ConstantInflector
end

module Puppet::Util::ConstantInflector
  extend ::T::Sig
  def self.constant2file(constant); end

  def self.file2constant(file); end
end

module Puppet::Util::Docs
  def desc(str); end

  def doc(); end

  def doc=(doc); end

  def dochook(name, &block); end

  def doctable(headers, data); end

  def markdown_definitionlist(term, definition); end

  def markdown_header(name, level); end

  def nodoc(); end

  def nodoc?(); end

  def pad(value, length); end
  HEADER_LEVELS = ::T.let(nil, ::T.untyped)
end

module Puppet::Util::Docs
  extend ::T::Sig
  def self.scrub(text); end
end

module Puppet::Util::Errors
  def adderrorcontext(error, other=T.unsafe(nil)); end

  def devfail(msg); end

  def error_context(); end

  def exceptwrap(options=T.unsafe(nil)); end

  def fail(*args); end
end

module Puppet::Util::Errors
  extend ::T::Sig
  def self.error_location(file, line=T.unsafe(nil), column=T.unsafe(nil)); end

  def self.error_location_with_space(file, line=T.unsafe(nil), column=T.unsafe(nil)); end

  def self.error_location_with_unknowns(file, line); end
end

module Puppet::Util::Execution
  NoOptionsSpecified = ::T.let(nil, ::T.untyped)
end

class Puppet::Util::Execution::ProcessOutput
  def exitstatus(); end

  def initialize(value, exitstatus); end
end

class Puppet::Util::Execution::ProcessOutput
end

module Puppet::Util::Execution
  extend ::T::Sig
  def self.execfail(command, exception); end

  def self.execpipe(command, failonfail=T.unsafe(nil)); end

  def self.execute(command, options=T.unsafe(nil)); end

  def self.ruby_path(); end

  def self.util_execute(command, options=T.unsafe(nil)); end
end

class Puppet::Util::ExecutionStub
end

class Puppet::Util::ExecutionStub
  def self.current_value(); end

  def self.reset(); end

  def self.set(&block); end
end

class Puppet::Util::Feature
  include ::Puppet::Util::Warnings
  def add(name, options=T.unsafe(nil), &block); end

  def initialize(path); end

  def load(); end

  def method_missing(method, *args); end

  def path(); end

  def test(name, options, &block); end
end

class Puppet::Util::Feature
end

class Puppet::Util::FileNamespaceAdapter
  def file_to_namespace(); end

  def file_to_namespace=(file_to_namespace); end
end

class Puppet::Util::FileNamespaceAdapter
end

class Puppet::Util::FileWatcher
  include ::Enumerable
  def changed?(); end

  def clear(); end

  def each(&blk); end

  def watch(filename); end

  def watching?(filename); end
end

class Puppet::Util::FileWatcher
end

module Puppet::Util::HttpProxy
end

module Puppet::Util::HttpProxy
  extend ::T::Sig
  def self.get_http_object(uri); end

  def self.http_proxy_env(); end

  def self.http_proxy_host(); end

  def self.http_proxy_password(); end

  def self.http_proxy_port(); end

  def self.http_proxy_user(); end

  def self.no_proxy?(dest); end

  def self.proxy(uri); end

  def self.request_with_redirects(uri, method, redirect_limit=T.unsafe(nil), &block); end
end

module Puppet::Util::InstanceLoader
  include ::Puppet::Util
  def instance_hash(type); end

  def instance_load(type, path); end

  def instance_loader(type); end

  def instance_loading?(type); end

  def loaded_instance(type, name); end

  def loaded_instances(type); end
end

module Puppet::Util::InstanceLoader
  extend ::T::Sig
end

module Puppet::Util::Json
end

class Puppet::Util::Json::ParseError
  def data(); end
end

class Puppet::Util::Json::ParseError
  def self.build(original_exception, data); end
end

module Puppet::Util::Json
  extend ::T::Sig
  def self.dump(object, options=T.unsafe(nil)); end

  def self.load(string, options=T.unsafe(nil)); end
end

module Puppet::Util::Limits
  def setpriority(priority); end
end

module Puppet::Util::Limits
  extend ::T::Sig
end

class Puppet::Util::Lockfile
  def file_path(); end

  def initialize(file_path); end

  def lock(lock_data=T.unsafe(nil)); end

  def lock_data(); end

  def locked?(); end

  def unlock(); end
end

class Puppet::Util::Lockfile
end

class Puppet::Util::Log
  include ::Puppet::Util
  include ::Puppet::Util::PsychSupport
  include ::Puppet::Util::Tagging
  include ::Puppet::Network::FormatSupport
  def backtrace(); end

  def backtrace=(backtrace); end

  def environment(); end

  def environment=(environment); end

  def file(); end

  def file=(file); end

  def initialize(args); end

  def initialize_from_hash(data); end

  def issue_code(); end

  def issue_code=(issue_code); end

  def level(); end

  def level=(level); end

  def line(); end

  def line=(line); end

  def message(); end

  def message=(msg); end

  def node(); end

  def node=(node); end

  def pos(); end

  def pos=(pos); end

  def remote(); end

  def remote=(remote); end

  def source(); end

  def source=(source); end

  def time(); end

  def time=(time); end

  def to_data_hash(); end

  def to_hash(); end

  def to_report(); end

  def to_structured_hash(); end
end

class Puppet::Util::Log::DestArray
  def handle(msg); end

  def initialize(messages); end
end

class Puppet::Util::Log::DestArray
end

class Puppet::Util::Log::DestConsole
  include ::Puppet::Util::Colors
  def handle(msg); end
end

class Puppet::Util::Log::DestConsole
end

class Puppet::Util::Log::DestEventlog
  def close(); end

  def handle(msg); end

  def to_native(level); end
  EVENTLOG_CHARACTER_LIMIT = ::T.let(nil, ::T.untyped)
  EVENTLOG_ERROR_TYPE = ::T.let(nil, ::T.untyped)
  EVENTLOG_INFORMATION_TYPE = ::T.let(nil, ::T.untyped)
  EVENTLOG_WARNING_TYPE = ::T.let(nil, ::T.untyped)
end

class Puppet::Util::Log::DestEventlog
  def self.suitable?(obj); end
end

class Puppet::Util::Log::DestFile
  def autoflush(); end

  def autoflush=(autoflush); end

  def close(); end

  def flush(); end

  def handle(msg); end

  def initialize(path); end
end

class Puppet::Util::Log::DestFile
end

class Puppet::Util::Log::DestLogstash_event
  def format(msg); end

  def handle(msg); end
end

class Puppet::Util::Log::DestLogstash_event
end

class Puppet::Util::Log::DestReport
  def handle(msg); end

  def initialize(report); end

  def report(); end
end

class Puppet::Util::Log::DestReport
end

class Puppet::Util::Log::DestSyslog
  def close(); end

  def handle(msg); end
end

class Puppet::Util::Log::DestSyslog
  def self.suitable?(obj); end
end

class Puppet::Util::Log::Destination
  def name(); end
end

class Puppet::Util::Log::Destination
  def self.initvars(); end

  def self.match(obj); end

  def self.match?(obj); end

  def self.name=(name); end

  def self.sethandler(&block); end

  def self.setinit(&block); end
end

class Puppet::Util::Log
  extend ::Puppet::Util::ClassGen
  extend ::Puppet::Util
  def self.autoflush=(v); end

  def self.close(destination); end

  def self.close_all(); end

  def self.create(hash); end

  def self.destinations(); end

  def self.desttypes(); end

  def self.eachlevel(); end

  def self.flush(); end

  def self.flushqueue(); end

  def self.force_flushqueue(); end

  def self.from_data_hash(data); end

  def self.level(); end

  def self.level=(level); end

  def self.levels(); end

  def self.log_func(scope, level, vals); end

  def self.newdestination(dest); end

  def self.newdesttype(name, options=T.unsafe(nil), &block); end

  def self.newmessage(msg); end

  def self.queuemessage(msg); end

  def self.reopen(); end

  def self.sendlevel?(level); end

  def self.setup_default(); end

  def self.validlevel?(level); end

  def self.with_destination(destination, &block); end
end

module Puppet::Util::Logging
  def alert(args); end

  def clear_deprecation_warnings(); end

  def crit(args); end

  def debug(*args); end

  def deprecation_warning(message, key=T.unsafe(nil)); end

  def emerg(args); end

  def err(args); end

  def format_exception(exception, message=T.unsafe(nil), trace=T.unsafe(nil)); end

  def get_deprecation_offender(); end

  def info(args); end

  def log_and_raise(exception, message); end

  def log_deprecations_to_file(deprecations_file, pattern=T.unsafe(nil)); end

  def log_exception(exception, message=T.unsafe(nil), options=T.unsafe(nil)); end

  def notice(args); end

  def puppet_deprecation_warning(message, options=T.unsafe(nil)); end

  def send_log(level, message); end

  def warn_once(kind, key, message, file=T.unsafe(nil), line=T.unsafe(nil), level=T.unsafe(nil)); end

  def warning(args); end
end

module Puppet::Util::Logging
  extend ::T::Sig
  def self.setup_facter_logging!(); end
end

class Puppet::Util::Metric
  include ::Puppet::Util::PsychSupport
  include ::Puppet::Network::FormatSupport
  def [](name); end

  def initialize(name, label=T.unsafe(nil)); end

  def initialize_from_hash(data); end

  def label(); end

  def label=(label); end

  def name(); end

  def name=(name); end

  def newvalue(name, value, label=T.unsafe(nil)); end

  def to_data_hash(); end

  def type(); end

  def type=(type); end

  def value(); end

  def value=(value); end

  def values(); end

  def values=(values); end
end

class Puppet::Util::Metric
  def self.from_data_hash(data); end

  def self.labelize(name); end
end

class Puppet::Util::ModuleDirectoriesAdapter
  def directories(); end

  def directories=(directories); end
end

class Puppet::Util::ModuleDirectoriesAdapter
end

module Puppet::Util::MonkeyPatches
end

module Puppet::Util::MonkeyPatches
  extend ::T::Sig
end

class Puppet::Util::MultiMatch
  def ===(other); end

  def initialize(*values); end

  def values(); end
  NOT_NIL = ::T.let(nil, ::T.untyped)
  TRIPLE = ::T.let(nil, ::T.untyped)
  TUPLE = ::T.let(nil, ::T.untyped)
end

class Puppet::Util::MultiMatch::MatchNotNil
  def ===(v); end
end

class Puppet::Util::MultiMatch::MatchNotNil
end

class Puppet::Util::MultiMatch
end

module Puppet::Util::POSIX
  def get_posix_field(space, field, id); end

  def gid(group); end

  def idfield(space); end

  def methodbyid(space); end

  def methodbyname(space); end

  def search_posix_field(type, field, id); end

  def uid(user); end
  LOCALE_ENV_VARS = ::T.let(nil, ::T.untyped)
  USER_ENV_VARS = ::T.let(nil, ::T.untyped)
end

module Puppet::Util::POSIX
  extend ::T::Sig
  def self.groups_of(user); end
end

module Puppet::Util::Package
end

module Puppet::Util::Package
  extend ::T::Sig
  def self.versioncmp(version_a, version_b); end
end

class Puppet::Util::Pidlock
  def file_path(); end

  def initialize(lockfile); end

  def lock(); end

  def lock_pid(); end

  def locked?(); end

  def mine?(); end

  def unlock(); end
end

class Puppet::Util::Pidlock
end

module Puppet::Util::Platform
  FIPS_STATUS_FILE = ::T.let(nil, ::T.untyped)
end

module Puppet::Util::Platform
  extend ::T::Sig
  def self.default_paths(); end

  def self.fips_enabled?(); end

  def self.jruby?(); end

  def self.windows?(); end
end

module Puppet::Util::Profiler
end

class Puppet::Util::Profiler::Aggregate
  def print_metrics(metrics_hash, prefix); end

  def update_metric(metrics_hash, metric_id, time); end

  def values(); end
end

class Puppet::Util::Profiler::Aggregate::Metric
  def [](key); end

  def add_time(time); end

  def count(); end

  def increment(); end

  def initialize(); end

  def time(); end
end

class Puppet::Util::Profiler::Aggregate::Metric
end

class Puppet::Util::Profiler::Aggregate::Timer
  def stop(); end
end

class Puppet::Util::Profiler::Aggregate::Timer
end

class Puppet::Util::Profiler::Aggregate
end

class Puppet::Util::Profiler::AroundProfiler
  def add_profiler(profiler); end

  def clear(); end

  def current(); end

  def profile(message, metric_id); end

  def remove_profiler(profiler); end
end

class Puppet::Util::Profiler::AroundProfiler
end

class Puppet::Util::Profiler::Logging
  def finish(context, description, metric_id); end

  def initialize(logger, identifier); end

  def shutdown(); end

  def start(description, metric_id); end
end

class Puppet::Util::Profiler::Logging::Sequence
  def down(); end

  def next(); end

  def up(); end
  INITIAL = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Puppet::Util::Profiler::Logging::Sequence
end

class Puppet::Util::Profiler::Logging
end

class Puppet::Util::Profiler::ObjectCounts
  def finish(before); end

  def start(); end
end

class Puppet::Util::Profiler::ObjectCounts
end

class Puppet::Util::Profiler::WallClock
  def do_finish(context, description, metric_id); end

  def do_start(description, metric_id); end
end

class Puppet::Util::Profiler::WallClock::Timer
  def stop(); end
  FOUR_DECIMAL_DIGITS = ::T.let(nil, ::T.untyped)
end

class Puppet::Util::Profiler::WallClock::Timer
end

class Puppet::Util::Profiler::WallClock
end

module Puppet::Util::Profiler
  extend ::T::Sig
  def self.add_profiler(profiler); end

  def self.clear(); end

  def self.current(); end

  def self.profile(message, metric_id, &block); end

  def self.remove_profiler(profiler); end
end

module Puppet::Util::ProviderFeatures
  include ::Puppet::Util::Docs
  def feature(name, docs, hash=T.unsafe(nil)); end

  def feature_module(); end

  def featuredocs(); end

  def features(); end

  def provider_feature(name); end
end

class Puppet::Util::ProviderFeatures::ProviderFeature
  include ::Puppet::Util
  include ::Puppet::Util::Docs
  def available?(obj); end

  def docs(); end

  def docs=(docs); end

  def initialize(name, docs, methods: T.unsafe(nil)); end

  def methods(); end

  def methods=(methods); end

  def name(); end

  def name=(name); end
end

class Puppet::Util::ProviderFeatures::ProviderFeature
end

module Puppet::Util::ProviderFeatures
  extend ::T::Sig
end

module Puppet::Util::PsychSupport
  def encode_with(psych_encoder); end

  def init_with(psych_coder); end
end

module Puppet::Util::PsychSupport
  extend ::T::Sig
end

module Puppet::Util::RubyGems
end

class Puppet::Util::RubyGems::Gems18Source
  def clear_paths(); end

  def directories(); end
end

class Puppet::Util::RubyGems::Gems18Source
end

class Puppet::Util::RubyGems::NoGemsSource
  def clear_paths(); end

  def directories(); end
end

class Puppet::Util::RubyGems::NoGemsSource
end

class Puppet::Util::RubyGems::Source
end

class Puppet::Util::RubyGems::Source
  def self.has_rubygems?(); end

  def self.new(*args); end

  def self.source(); end
end

module Puppet::Util::RubyGems
  extend ::T::Sig
end

class Puppet::Util::RunMode
  def agent?(); end

  def initialize(name); end

  def log_dir(); end

  def master?(); end

  def name(); end

  def run_dir(); end

  def user?(); end
end

class Puppet::Util::RunMode
  def self.[](name); end
end

module Puppet::Util::SSL
end

module Puppet::Util::SSL
  extend ::T::Sig
  def self.cn_from_subject(subject); end

  def self.handle_connection_error(error, verifier, host); end

  def self.is_possibly_valid_dn?(dn); end

  def self.subject_from_dn(dn); end
end

module Puppet::Util::SUIDManager
  include ::Puppet::Util::Warnings
end

module Puppet::Util::SUIDManager
  extend ::Forwardable
  extend ::T::Sig
  def self.asuser(new_uid=T.unsafe(nil), new_gid=T.unsafe(nil)); end

  def self.change_group(group, permanently=T.unsafe(nil)); end

  def self.change_privileges(uid=T.unsafe(nil), gid=T.unsafe(nil), permanently=T.unsafe(nil)); end

  def self.change_user(user, permanently=T.unsafe(nil)); end

  def self.convert_xid(type, id); end

  def self.egid(*args, &block); end

  def self.egid=(*args, &block); end

  def self.euid(*args, &block); end

  def self.euid=(*args, &block); end

  def self.gid(*args, &block); end

  def self.gid=(*args, &block); end

  def self.groups(*args, &block); end

  def self.groups=(grouplist); end

  def self.initgroups(uid); end

  def self.osx_maj_ver(); end

  def self.root?(); end

  def self.uid(*args, &block); end

  def self.uid=(*args, &block); end
end

class Puppet::Util::SkipTags
  include ::Puppet::Util::Tagging
  def initialize(stags); end
end

class Puppet::Util::SkipTags
end

class Puppet::Util::Storage
  include ::Singleton
  include ::Puppet::Util
end

class Puppet::Util::Storage
  extend ::Singleton::SingletonClassMethods
  def self.cache(object); end

  def self.clear(); end

  def self.init(); end

  def self.instance(); end

  def self.load(); end

  def self.state(); end

  def self.stateinspect(); end

  def self.store(); end
end

module Puppet::Util::SymbolicFileMode
  def normalize_symbolic_mode(value); end

  def symbolic_mode_to_int(modification, to_mode=T.unsafe(nil), is_a_directory=T.unsafe(nil)); end

  def valid_symbolic_mode?(value); end
  ExecBit = ::T.let(nil, ::T.untyped)
  ReadBit = ::T.let(nil, ::T.untyped)
  SetGIDBit = ::T.let(nil, ::T.untyped)
  SetUIDBit = ::T.let(nil, ::T.untyped)
  StickyBit = ::T.let(nil, ::T.untyped)
  SymbolicMode = ::T.let(nil, ::T.untyped)
  SymbolicSpecialToBit = ::T.let(nil, ::T.untyped)
  WriteBit = ::T.let(nil, ::T.untyped)
end

module Puppet::Util::SymbolicFileMode
  extend ::T::Sig
end

class Puppet::Util::TagSet
  include ::Puppet::Network::FormatSupport
  def join(*args); end

  def to_data_hash(); end

  def to_yaml(); end
end

class Puppet::Util::TagSet
  def self.from_data_hash(data); end

  def self.from_yaml(yaml); end
end

module Puppet::Util::Tagging
  def merge_into(tag_set); end

  def merge_tags_from(tag_source); end

  def raw_tagged?(tag_array); end

  def set_tags(tag_source); end

  def tag(*ary); end

  def tag_if_valid(name); end

  def tagged?(*tags); end

  def tags(); end

  def tags=(tags); end

  def valid_tag?(maybe_tag); end
  ValidTagRegex = ::T.let(nil, ::T.untyped)
end

module Puppet::Util::Tagging
  extend ::T::Sig
end

class Puppet::Util::UnixRunMode
  def code_dir(); end

  def conf_dir(); end

  def var_dir(); end
end

class Puppet::Util::UnixRunMode
end

module Puppet::Util::Warnings
end

module Puppet::Util::Warnings
  extend ::T::Sig
  def self.clear_warnings(); end

  def self.debug_once(msg); end

  def self.maybe_log(message, klass); end

  def self.notice_once(msg); end

  def self.warnonce(msg); end
end

class Puppet::Util::WatchedFile
  def changed?(); end

  def filename(); end

  def initialize(filename, timer=T.unsafe(nil)); end

  def to_str(); end
end

class Puppet::Util::WatchedFile
end

module Puppet::Util::Watcher
end

class Puppet::Util::Watcher::ChangeWatcher
  def change_current_reading_to(new_value); end

  def changed?(); end

  def initialize(previous, current, value_reader); end

  def next_reading(); end

  def uncertain?(); end
end

class Puppet::Util::Watcher::ChangeWatcher
  def self.watch(reader); end
end

module Puppet::Util::Watcher::Common
end

module Puppet::Util::Watcher::Common
  extend ::T::Sig
  def self.file_ctime_change_watcher(filename); end
end

class Puppet::Util::Watcher::PeriodicWatcher
  def changed?(); end

  def initialize(watcher, timer); end
end

class Puppet::Util::Watcher::PeriodicWatcher
end

class Puppet::Util::Watcher::Timer
  def expired?(); end

  def initialize(timeout); end

  def now(); end

  def start(); end

  def timeout(); end
end

class Puppet::Util::Watcher::Timer
end

module Puppet::Util::Watcher
  extend ::T::Sig
end

class Puppet::Util::WindowsRunMode
  def code_dir(); end

  def conf_dir(); end

  def var_dir(); end
end

class Puppet::Util::WindowsRunMode
end

module Puppet::Util::Yaml
  YamlLoadExceptions = ::T.let(nil, ::T.untyped)
end

class Puppet::Util::Yaml::YamlLoadError
end

class Puppet::Util::Yaml::YamlLoadError
end

module Puppet::Util::Yaml
  extend ::T::Sig
  def self.dump(structure, filename); end

  def self.load_file(filename, default_value=T.unsafe(nil), strip_classes=T.unsafe(nil)); end

  def self.safe_load(yaml, allowed_classes=T.unsafe(nil), filename=T.unsafe(nil)); end

  def self.safe_load_file(filename, allowed_classes=T.unsafe(nil)); end
end

module Puppet::Util
  extend ::Puppet::Util::POSIX
  extend ::Puppet::Util::SymbolicFileMode
  extend ::T::Sig
  def self.absolute_path?(path, platform=T.unsafe(nil)); end

  def self.benchmark(*args); end

  def self.chuser(); end

  def self.clear_environment(mode=T.unsafe(nil)); end

  def self.default_env(); end

  def self.deterministic_rand(seed, max); end

  def self.deterministic_rand_int(seed, max); end

  def self.exit_on_fail(message, code=T.unsafe(nil)); end

  def self.get_env(name, mode=T.unsafe(nil)); end

  def self.get_environment(mode=T.unsafe(nil)); end

  def self.logmethods(klass, useself=T.unsafe(nil)); end

  def self.merge_environment(env_hash, mode=T.unsafe(nil)); end

  def self.path_to_uri(path); end

  def self.pretty_backtrace(backtrace=T.unsafe(nil)); end

  def self.replace_file(file, default_mode, staging_location: T.unsafe(nil), validate_callback: T.unsafe(nil), &block); end

  def self.safe_posix_fork(stdin=T.unsafe(nil), stdout=T.unsafe(nil), stderr=T.unsafe(nil), &block); end

  def self.set_env(name, value=T.unsafe(nil), mode=T.unsafe(nil)); end

  def self.symbolizehash(hash); end

  def self.thinmark(); end

  def self.uri_encode(path, opts=T.unsafe(nil)); end

  def self.uri_query_encode(query_string); end

  def self.uri_to_path(uri); end

  def self.which(bin); end

  def self.withenv(hash, mode=T.unsafe(nil)); end

  def self.withumask(mask); end
end

class Puppet::Vendor
end

class Puppet::Vendor
  def self.load_entry(entry); end

  def self.load_vendored(); end

  def self.require_libs(); end

  def self.vendor_dir(); end
end

module Puppet::X509
end

class Puppet::X509::CertProvider
  include ::Puppet::X509::PemStore
  def create_request(name, private_key); end

  def crl_last_update(); end

  def crl_last_update=(time); end

  def delete_request(name); end

  def initialize(capath: T.unsafe(nil), crlpath: T.unsafe(nil), privatekeydir: T.unsafe(nil), certdir: T.unsafe(nil), requestdir: T.unsafe(nil)); end

  def load_cacerts(required: T.unsafe(nil)); end

  def load_cacerts_from_pem(pem); end

  def load_client_cert(name, required: T.unsafe(nil)); end

  def load_client_cert_from_pem(pem); end

  def load_crls(required: T.unsafe(nil)); end

  def load_crls_from_pem(pem); end

  def load_private_key(name, required: T.unsafe(nil), password: T.unsafe(nil)); end

  def load_private_key_from_pem(pem, password: T.unsafe(nil)); end

  def load_private_key_password(); end

  def load_request(name); end

  def load_request_from_pem(pem); end

  def save_cacerts(certs); end

  def save_client_cert(name, cert); end

  def save_crls(crls); end

  def save_private_key(name, key, password: T.unsafe(nil)); end

  def save_request(name, csr); end
  CERT_DELIMITERS = ::T.let(nil, ::T.untyped)
  CRL_DELIMITERS = ::T.let(nil, ::T.untyped)
  EC_HEADER = ::T.let(nil, ::T.untyped)
  VALID_CERTNAME = ::T.let(nil, ::T.untyped)
end

class Puppet::X509::CertProvider
end

module Puppet::X509::PemStore
  def delete_pem(path); end

  def load_pem(path); end

  def save_pem(pem, path, owner: T.unsafe(nil), group: T.unsafe(nil), mode: T.unsafe(nil)); end
end

module Puppet::X509::PemStore
  extend ::T::Sig
end

module Puppet::X509
  extend ::T::Sig
end

module Puppet
  extend ::Puppet::Util
  extend ::Puppet::Util::Logging
  extend ::T::Sig
  def self.[](param); end

  def self.[]=(param, value); end

  def self.base_context(settings); end

  def self.bootstrap_context(); end

  def self.clear(); end

  def self.debug=(value); end

  def self.default_basemodulepath(); end

  def self.default_diffargs(); end

  def self.default_digest_algorithm(); end

  def self.default_file_checksum_types(); end

  def self.default_vendormoduledir(); end

  def self.define_settings(section, hash); end

  def self.features(); end

  def self.ignore(name); end

  def self.initialize_facts(); end

  def self.initialize_settings(args=T.unsafe(nil), require_config=T.unsafe(nil)); end

  def self.lookup(name, &block); end

  def self.mark_context(name); end

  def self.minor_version(); end

  def self.override(bindings, description=T.unsafe(nil), &block); end

  def self.pop_context(); end

  def self.push_context(overrides, description=T.unsafe(nil)); end

  def self.restore(name); end

  def self.rollback_context(name); end

  def self.run_mode(); end

  def self.settings(); end

  def self.valid_digest_algorithms(); end

  def self.valid_file_checksum_types(); end

  def self.version(); end

  def self.version=(version); end
end

Queue = Thread::Queue

module RDoc
end

module RDoc
  extend ::T::Sig
  def self.caller(skip=T.unsafe(nil)); end
end

module Racc
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::ParseError
  extend ::T::Sig
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

class Racc::Parser
  extend ::T::Sig
end

module Racc
  extend ::T::Sig
end

module Random::Formatter
  def alphanumeric(n=T.unsafe(nil)); end

  ALPHANUMERIC = ::T.let(nil, ::T.untyped)
end

module Random::Formatter
  extend ::T::Sig
end

class Random
  extend ::T::Sig
  def self.urandom(_); end
end

class Range
  extend ::T::Sig
end

class RangeError
  extend ::T::Sig
end

class Rational
  extend ::T::Sig
end

module RbConfig
  extend ::T::Sig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.ruby(); end
end

class Regexp
  def match?(*_); end
end

class Regexp
  extend ::T::Sig
  def self.union(*_); end
end

class RegexpError
  extend ::T::Sig
end

class Resolv::DNS
  def extract_resources(msg, name, typeclass); end

  def fetch_resource(name, typeclass); end

  def lazy_initialize(); end

  def make_tcp_requester(host, port); end

  def make_udp_requester(); end
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config
  def generate_candidates(name); end

  def generate_timeouts(); end

  def initialize(config_info=T.unsafe(nil)); end

  def lazy_initialize(); end

  def nameserver_port(); end

  def resolv(name); end

  def single?(); end

  def timeouts=(values); end
  InitialTimeout = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config::NXDomain
end

class Resolv::DNS::Config::NXDomain
end

class Resolv::DNS::Config::OtherResolvError
end

class Resolv::DNS::Config::OtherResolvError
end

class Resolv::DNS::Config
  def self.default_config_hash(filename=T.unsafe(nil)); end

  def self.parse_resolv_conf(filename); end
end

module Resolv::DNS::Label
end

class Resolv::DNS::Label::Str
  def ==(other); end

  def downcase(); end

  def eql?(other); end

  def initialize(string); end

  def string(); end
end

class Resolv::DNS::Label::Str
end

module Resolv::DNS::Label
  extend ::T::Sig
  def self.split(arg); end
end

class Resolv::DNS::Message
  def ==(other); end

  def aa(); end

  def aa=(aa); end

  def add_additional(name, ttl, data); end

  def add_answer(name, ttl, data); end

  def add_authority(name, ttl, data); end

  def add_question(name, typeclass); end

  def additional(); end

  def answer(); end

  def authority(); end

  def each_additional(); end

  def each_answer(); end

  def each_authority(); end

  def each_question(); end

  def each_resource(); end

  def encode(); end

  def id(); end

  def id=(id); end

  def initialize(id=T.unsafe(nil)); end

  def opcode(); end

  def opcode=(opcode); end

  def qr(); end

  def qr=(qr); end

  def question(); end

  def ra(); end

  def ra=(ra); end

  def rcode(); end

  def rcode=(rcode); end

  def rd(); end

  def rd=(rd); end

  def tc(); end

  def tc=(tc); end
end

class Resolv::DNS::Message::MessageDecoder
  def get_bytes(len=T.unsafe(nil)); end

  def get_label(); end

  def get_labels(); end

  def get_length16(); end

  def get_name(); end

  def get_question(); end

  def get_rr(); end

  def get_string(); end

  def get_string_list(); end

  def get_unpack(template); end

  def initialize(data); end
end

class Resolv::DNS::Message::MessageDecoder
end

class Resolv::DNS::Message::MessageEncoder
  def put_bytes(d); end

  def put_label(d); end

  def put_labels(d); end

  def put_length16(); end

  def put_name(d); end

  def put_pack(template, *d); end

  def put_string(d); end

  def put_string_list(ds); end
end

class Resolv::DNS::Message::MessageEncoder
end

class Resolv::DNS::Message
  def self.decode(m); end
end

class Resolv::DNS::Name
  def ==(other); end

  def [](i); end

  def eql?(other); end

  def length(); end

  def to_a(); end
end

module Resolv::DNS::OpCode
  IQuery = ::T.let(nil, ::T.untyped)
  Notify = ::T.let(nil, ::T.untyped)
  Query = ::T.let(nil, ::T.untyped)
  Status = ::T.let(nil, ::T.untyped)
  Update = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::OpCode
  extend ::T::Sig
end

class Resolv::DNS::Query
  def encode_rdata(msg); end
end

class Resolv::DNS::Query
  def self.decode_rdata(msg); end
end

module Resolv::DNS::RCode
  BADALG = ::T.let(nil, ::T.untyped)
  BADKEY = ::T.let(nil, ::T.untyped)
  BADMODE = ::T.let(nil, ::T.untyped)
  BADNAME = ::T.let(nil, ::T.untyped)
  BADSIG = ::T.let(nil, ::T.untyped)
  BADTIME = ::T.let(nil, ::T.untyped)
  BADVERS = ::T.let(nil, ::T.untyped)
  FormErr = ::T.let(nil, ::T.untyped)
  NXDomain = ::T.let(nil, ::T.untyped)
  NXRRSet = ::T.let(nil, ::T.untyped)
  NoError = ::T.let(nil, ::T.untyped)
  NotAuth = ::T.let(nil, ::T.untyped)
  NotImp = ::T.let(nil, ::T.untyped)
  NotZone = ::T.let(nil, ::T.untyped)
  Refused = ::T.let(nil, ::T.untyped)
  ServFail = ::T.let(nil, ::T.untyped)
  YXDomain = ::T.let(nil, ::T.untyped)
  YXRRSet = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::RCode
  extend ::T::Sig
end

class Resolv::DNS::Requester
  def close(); end

  def request(sender, tout); end

  def sender_for(addr, msg); end
end

class Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::ConnectedUDP::Sender
  def data(); end

  def send(); end
end

class Resolv::DNS::Requester::ConnectedUDP::Sender
end

class Resolv::DNS::Requester::ConnectedUDP
end

class Resolv::DNS::Requester::MDNSOneShot
end

class Resolv::DNS::Requester::MDNSOneShot
end

class Resolv::DNS::Requester::RequestError
end

class Resolv::DNS::Requester::RequestError
end

class Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Resolv::DNS::Requester::Sender
end

class Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::TCP::Sender
  def data(); end

  def send(); end
end

class Resolv::DNS::Requester::TCP::Sender
end

class Resolv::DNS::Requester::TCP
end

class Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host, port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
  def data(); end

  def initialize(msg, data, sock, host, port); end

  def send(); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
end

class Resolv::DNS::Requester::UnconnectedUDP
end

class Resolv::DNS::Requester
end

class Resolv::DNS::Resource
  def ==(other); end

  def eql?(other); end
  ClassHash = ::T.let(nil, ::T.untyped)
  ClassInsensitiveTypes = ::T.let(nil, ::T.untyped)
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::ANY
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::CNAME
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::Generic
  def self.create(type_value, class_value); end
end

class Resolv::DNS::Resource::HINFO
  TypeValue = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::Resource::IN
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::A
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::AAAA
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::ANY
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::ANY
end

class Resolv::DNS::Resource::IN::CNAME
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::CNAME
end

class Resolv::DNS::Resource::IN::HINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::HINFO
end

class Resolv::DNS::Resource::IN::LOC
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::LOC
end

class Resolv::DNS::Resource::IN::MINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::MINFO
end

class Resolv::DNS::Resource::IN::MX
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::MX
end

class Resolv::DNS::Resource::IN::NS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::NS
end

class Resolv::DNS::Resource::IN::PTR
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::PTR
end

class Resolv::DNS::Resource::IN::SOA
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::SOA
end

class Resolv::DNS::Resource::IN::SRV
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::TXT
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::TXT
end

class Resolv::DNS::Resource::IN::WKS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::Resource::IN
  extend ::T::Sig
end

class Resolv::DNS::Resource::LOC
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::MINFO
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::MX
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::NS
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::PTR
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::SOA
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::TXT
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource
  def self.get_class(type_value, class_value); end
end

class Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.random(arg); end

  def self.rangerand(range); end
end

class Resolv::Hosts
  def lazy_initialize(); end
end

class Resolv::IPv4
  def ==(other); end

  def eql?(other); end
end

class Resolv::IPv6
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Alt
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Coord
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Size
  def ==(other); end

  def eql?(other); end
end

module Resolv::LOC
  extend ::T::Sig
end

class Ripper
  def column(); end

  def encoding(); end

  def end_seen?(); end

  def error?(); end

  def filename(); end

  def initialize(*_); end

  def lineno(); end

  def parse(); end

  def state(); end

  def yydebug(); end

  def yydebug=(yydebug); end
  EVENTS = ::T.let(nil, ::T.untyped)
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  PARSER_EVENTS = ::T.let(nil, ::T.untyped)
  PARSER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  SCANNER_EVENTS = ::T.let(nil, ::T.untyped)
  SCANNER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Ripper::Filter
  def column(); end

  def filename(); end

  def initialize(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def lineno(); end

  def parse(init=T.unsafe(nil)); end

  def state(); end
end

class Ripper::Filter
end

class Ripper::Lexer
  def lex(); end

  def tokenize(); end
end

class Ripper::Lexer::Elem
  def event(); end

  def event=(_); end

  def initialize(pos, event, tok, state); end

  def pos(); end

  def pos=(_); end

  def state(); end

  def state=(_); end

  def tok(); end

  def tok=(_); end
end

class Ripper::Lexer::Elem
  def self.[](*_); end

  def self.members(); end
end

class Ripper::Lexer::State
  def &(i); end

  def ==(i); end

  def allbits?(i); end

  def anybits?(i); end

  def initialize(i); end

  def nobits?(i); end

  def pretty_print(q); end

  def to_i(); end

  def to_int(); end

  def to_int=(_); end

  def to_s=(_); end

  def |(i); end
end

class Ripper::Lexer::State
  def self.[](*_); end

  def self.members(); end
end

class Ripper::Lexer
end

class Ripper::SexpBuilder
  def on_BEGIN(*args); end

  def on_CHAR(tok); end

  def on_END(*args); end

  def on___end__(tok); end

  def on_alias(*args); end

  def on_alias_error(*args); end

  def on_aref(*args); end

  def on_aref_field(*args); end

  def on_arg_ambiguous(*args); end

  def on_arg_paren(*args); end

  def on_args_add(*args); end

  def on_args_add_block(*args); end

  def on_args_add_star(*args); end

  def on_args_new(*args); end

  def on_array(*args); end

  def on_assign(*args); end

  def on_assign_error(*args); end

  def on_assoc_new(*args); end

  def on_assoc_splat(*args); end

  def on_assoclist_from_args(*args); end

  def on_backref(tok); end

  def on_backtick(tok); end

  def on_bare_assoc_hash(*args); end

  def on_begin(*args); end

  def on_binary(*args); end

  def on_block_var(*args); end

  def on_blockarg(*args); end

  def on_bodystmt(*args); end

  def on_brace_block(*args); end

  def on_break(*args); end

  def on_call(*args); end

  def on_case(*args); end

  def on_class(*args); end

  def on_class_name_error(*args); end

  def on_comma(tok); end

  def on_command(*args); end

  def on_command_call(*args); end

  def on_comment(tok); end

  def on_const(tok); end

  def on_const_path_field(*args); end

  def on_const_path_ref(*args); end

  def on_const_ref(*args); end

  def on_cvar(tok); end

  def on_def(*args); end

  def on_defined(*args); end

  def on_defs(*args); end

  def on_do_block(*args); end

  def on_dot2(*args); end

  def on_dot3(*args); end

  def on_dyna_symbol(*args); end

  def on_else(*args); end

  def on_elsif(*args); end

  def on_embdoc(tok); end

  def on_embdoc_beg(tok); end

  def on_embdoc_end(tok); end

  def on_embexpr_beg(tok); end

  def on_embexpr_end(tok); end

  def on_embvar(tok); end

  def on_ensure(*args); end

  def on_excessed_comma(*args); end

  def on_fcall(*args); end

  def on_field(*args); end

  def on_float(tok); end

  def on_for(*args); end

  def on_gvar(tok); end

  def on_hash(*args); end

  def on_heredoc_beg(tok); end

  def on_heredoc_end(tok); end

  def on_ident(tok); end

  def on_if(*args); end

  def on_if_mod(*args); end

  def on_ifop(*args); end

  def on_ignored_nl(tok); end

  def on_ignored_sp(tok); end

  def on_imaginary(tok); end

  def on_int(tok); end

  def on_ivar(tok); end

  def on_kw(tok); end

  def on_kwrest_param(*args); end

  def on_label(tok); end

  def on_label_end(tok); end

  def on_lambda(*args); end

  def on_lbrace(tok); end

  def on_lbracket(tok); end

  def on_lparen(tok); end

  def on_magic_comment(*args); end

  def on_massign(*args); end

  def on_method_add_arg(*args); end

  def on_method_add_block(*args); end

  def on_mlhs_add(*args); end

  def on_mlhs_add_post(*args); end

  def on_mlhs_add_star(*args); end

  def on_mlhs_new(*args); end

  def on_mlhs_paren(*args); end

  def on_module(*args); end

  def on_mrhs_add(*args); end

  def on_mrhs_add_star(*args); end

  def on_mrhs_new(*args); end

  def on_mrhs_new_from_args(*args); end

  def on_next(*args); end

  def on_nl(tok); end

  def on_op(tok); end

  def on_opassign(*args); end

  def on_operator_ambiguous(*args); end

  def on_param_error(*args); end

  def on_params(*args); end

  def on_paren(*args); end

  def on_parse_error(*args); end

  def on_period(tok); end

  def on_program(*args); end

  def on_qsymbols_add(*args); end

  def on_qsymbols_beg(tok); end

  def on_qsymbols_new(*args); end

  def on_qwords_add(*args); end

  def on_qwords_beg(tok); end

  def on_qwords_new(*args); end

  def on_rational(tok); end

  def on_rbrace(tok); end

  def on_rbracket(tok); end

  def on_redo(*args); end

  def on_regexp_add(*args); end

  def on_regexp_beg(tok); end

  def on_regexp_end(tok); end

  def on_regexp_literal(*args); end

  def on_regexp_new(*args); end

  def on_rescue(*args); end

  def on_rescue_mod(*args); end

  def on_rest_param(*args); end

  def on_retry(*args); end

  def on_return(*args); end

  def on_return0(*args); end

  def on_rparen(tok); end

  def on_sclass(*args); end

  def on_semicolon(tok); end

  def on_sp(tok); end

  def on_stmts_add(*args); end

  def on_stmts_new(*args); end

  def on_string_add(*args); end

  def on_string_concat(*args); end

  def on_string_content(*args); end

  def on_string_dvar(*args); end

  def on_string_embexpr(*args); end

  def on_string_literal(*args); end

  def on_super(*args); end

  def on_symbeg(tok); end

  def on_symbol(*args); end

  def on_symbol_literal(*args); end

  def on_symbols_add(*args); end

  def on_symbols_beg(tok); end

  def on_symbols_new(*args); end

  def on_tlambda(tok); end

  def on_tlambeg(tok); end

  def on_top_const_field(*args); end

  def on_top_const_ref(*args); end

  def on_tstring_beg(tok); end

  def on_tstring_content(tok); end

  def on_tstring_end(tok); end

  def on_unary(*args); end

  def on_undef(*args); end

  def on_unless(*args); end

  def on_unless_mod(*args); end

  def on_until(*args); end

  def on_until_mod(*args); end

  def on_var_alias(*args); end

  def on_var_field(*args); end

  def on_var_ref(*args); end

  def on_vcall(*args); end

  def on_void_stmt(*args); end

  def on_when(*args); end

  def on_while(*args); end

  def on_while_mod(*args); end

  def on_word_add(*args); end

  def on_word_new(*args); end

  def on_words_add(*args); end

  def on_words_beg(tok); end

  def on_words_new(*args); end

  def on_words_sep(tok); end

  def on_xstring_add(*args); end

  def on_xstring_literal(*args); end

  def on_xstring_new(*args); end

  def on_yield(*args); end

  def on_yield0(*args); end

  def on_zsuper(*args); end
end

class Ripper::SexpBuilder
end

class Ripper::SexpBuilderPP
end

class Ripper::SexpBuilderPP
end

class Ripper::TokenPattern
  def initialize(pattern); end

  def match(str); end

  def match_list(tokens); end
  MAP = ::T.let(nil, ::T.untyped)
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::MatchData
  def initialize(tokens, match); end

  def string(n=T.unsafe(nil)); end
end

class Ripper::TokenPattern::MatchData
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern
  def self.compile(*_); end
end

class Ripper
  extend ::T::Sig
  def self.dedent_string(_, _1); end

  def self.lex(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def self.lex_state_name(_); end

  def self.parse(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def self.token_match(src, pattern); end
end

class RubyVM::InstructionSequence
  def absolute_path(); end

  def base_label(); end

  def disasm(); end

  def disassemble(); end

  def each_child(); end

  def eval(); end

  def first_lineno(); end

  def label(); end

  def path(); end

  def to_a(); end

  def to_binary(*_); end

  def trace_points(); end
end

class RubyVM::InstructionSequence
  extend ::T::Sig
  def self.compile(*_); end

  def self.compile_file(*_); end

  def self.compile_option(); end

  def self.compile_option=(compile_option); end

  def self.disasm(_); end

  def self.disassemble(_); end

  def self.load_from_binary(_); end

  def self.load_from_binary_extra_data(_); end

  def self.of(_); end
end

class RubyVM
  extend ::T::Sig
  def self.stat(*_); end
end

class RuntimeError
  extend ::T::Sig
end

ScanError = StringScanner::Error

class ScriptError
  extend ::T::Sig
end

module SecureRandom
end

module SecureRandom
  extend ::Random::Formatter
  extend ::T::Sig
  def self.bytes(n); end
end

class SecurityError
  extend ::T::Sig
end

module SemanticPuppet
  VERSION = ::T.let(nil, ::T.untyped)
end

module SemanticPuppet::Dependency
  def add_source(source); end

  def clear_sources(); end

  def fetch_releases(name); end

  def query(modules); end

  def resolve(graph); end

  def sources(); end
end

class SemanticPuppet::Dependency::Graph
  include ::SemanticPuppet::Dependency::GraphNode
  include ::Comparable
  def add_graph_constraint(source, &block); end

  def initialize(modules=T.unsafe(nil)); end

  def modules(); end

  def satisfies_graph?(solution); end
end

class SemanticPuppet::Dependency::Graph
end

module SemanticPuppet::Dependency::GraphNode
  include ::Comparable
  def <<(nodes); end

  def add_constraint(source, mod, desc, &block); end

  def add_dependency(name); end

  def children(); end

  def constraints(); end

  def constraints_for(name); end

  def dependencies(); end

  def dependency_names(); end

  def name(); end

  def populate_children(nodes); end

  def satisfied?(); end

  def satisfies_constraints?(release); end

  def satisfies_dependency?(node); end
end

module SemanticPuppet::Dependency::GraphNode
  extend ::T::Sig
end

class SemanticPuppet::Dependency::ModuleRelease
  include ::SemanticPuppet::Dependency::GraphNode
  include ::Comparable
  def ==(other); end

  def eql?(other); end

  def initialize(source, name, version, dependencies=T.unsafe(nil)); end

  def priority(); end

  def version(); end
end

class SemanticPuppet::Dependency::ModuleRelease
end

class SemanticPuppet::Dependency::Source
  def create_release(name, version, dependencies=T.unsafe(nil)); end

  def priority(); end
end

class SemanticPuppet::Dependency::Source
  def self.priority(); end
end

class SemanticPuppet::Dependency::UnsatisfiableGraph
  def graph(); end

  def initialize(graph); end
end

class SemanticPuppet::Dependency::UnsatisfiableGraph
end

module SemanticPuppet::Dependency
  extend ::SemanticPuppet::Dependency
  extend ::T::Sig
end

class SemanticPuppet::Version
  def ==(other); end

  def build(); end

  def compare_prerelease(other); end

  def eql?(other); end

  def initialize(major, minor, patch, prerelease=T.unsafe(nil), build=T.unsafe(nil)); end

  def major(); end

  def minor(); end

  def next(part); end

  def patch(); end

  def prerelease(); end

  def stable?(); end

  def to_stable(); end
  MAX = ::T.let(nil, ::T.untyped)
  MIN = ::T.let(nil, ::T.untyped)
  REGEX_BUILD = ::T.let(nil, ::T.untyped)
  REGEX_FULL = ::T.let(nil, ::T.untyped)
  REGEX_FULL_RX = ::T.let(nil, ::T.untyped)
  REGEX_NUMERIC = ::T.let(nil, ::T.untyped)
  REGEX_PRE = ::T.let(nil, ::T.untyped)
end

class SemanticPuppet::Version::ValidationFailure
end

class SemanticPuppet::Version::ValidationFailure
end

class SemanticPuppet::Version
  def self.parse(ver); end

  def self.parse_build(build); end

  def self.parse_prerelease(prerelease); end

  def self.valid?(ver); end
end

class SemanticPuppet::VersionRange
  def &(other); end

  def ==(range); end

  def ===(version); end

  def begin(); end

  def cover?(version); end

  def end(); end

  def eql?(range); end

  def exclude_begin?(); end

  def exclude_end?(); end

  def include?(version); end

  def initialize(ranges, string, exclude_end=T.unsafe(nil)); end

  def intersection(other); end

  def member?(version); end

  def ranges(); end
  ALL_RANGE = ::T.let(nil, ::T.untyped)
  EMPTY_RANGE = ::T.let(nil, ::T.untyped)
  HYPHEN = ::T.let(nil, ::T.untyped)
  HYPHEN_EXPR = ::T.let(nil, ::T.untyped)
  LOGICAL_OR = ::T.let(nil, ::T.untyped)
  LOWER_X = ::T.let(nil, ::T.untyped)
  NR = ::T.let(nil, ::T.untyped)
  PART = ::T.let(nil, ::T.untyped)
  PARTIAL = ::T.let(nil, ::T.untyped)
  PARTIAL_EXPR = ::T.let(nil, ::T.untyped)
  PARTS = ::T.let(nil, ::T.untyped)
  QUALIFIER = ::T.let(nil, ::T.untyped)
  QUALIFIER_NC = ::T.let(nil, ::T.untyped)
  RANGE_SPLIT = ::T.let(nil, ::T.untyped)
  SIMPLE = ::T.let(nil, ::T.untyped)
  SIMPLE_EXPR = ::T.let(nil, ::T.untyped)
  SIMPLE_WITH_EXTRA_WS = ::T.let(nil, ::T.untyped)
  SIMPLE_WITH_EXTRA_WS_EXPR = ::T.let(nil, ::T.untyped)
  STAR = ::T.let(nil, ::T.untyped)
  UPPER_X = ::T.let(nil, ::T.untyped)
  XR = ::T.let(nil, ::T.untyped)
  XR_NC = ::T.let(nil, ::T.untyped)
end

class SemanticPuppet::VersionRange::AbstractRange
  def ==(other); end

  def begin(); end

  def end(); end

  def eql?(other); end

  def exclude_begin?(); end

  def exclude_end?(); end

  def include?(_); end

  def intersection(range); end

  def lower_bound?(); end

  def merge(other); end

  def test_prerelease?(_); end

  def upper_bound?(); end
end

class SemanticPuppet::VersionRange::AbstractRange
end

class SemanticPuppet::VersionRange::AllRange
  def merge(range); end
  SINGLETON = ::T.let(nil, ::T.untyped)
end

class SemanticPuppet::VersionRange::AllRange
end

class SemanticPuppet::VersionRange::ComparatorRange
  def initialize(version); end

  def test_prerelease?(version); end

  def version(); end
end

class SemanticPuppet::VersionRange::ComparatorRange
end

class SemanticPuppet::VersionRange::EqRange
  def include?(version); end
end

class SemanticPuppet::VersionRange::EqRange
end

class SemanticPuppet::VersionRange::GtEqRange
  def include?(version); end
end

class SemanticPuppet::VersionRange::GtEqRange
end

class SemanticPuppet::VersionRange::GtRange
  def include?(version); end
end

class SemanticPuppet::VersionRange::GtRange
end

class SemanticPuppet::VersionRange::LtEqRange
  def include?(version); end
end

class SemanticPuppet::VersionRange::LtEqRange
end

class SemanticPuppet::VersionRange::LtRange
  def include?(version); end
  MATCH_NOTHING = ::T.let(nil, ::T.untyped)
end

class SemanticPuppet::VersionRange::LtRange
end

class SemanticPuppet::VersionRange::MinMaxRange
  def include?(version); end

  def initialize(min, max); end

  def max(); end

  def min(); end

  def test_prerelease?(version); end
end

class SemanticPuppet::VersionRange::MinMaxRange
  def self.create(*ranges); end
end

class SemanticPuppet::VersionRange
  def self.parse(range_string); end
end

module SemanticPuppet
  extend ::T::Sig
end

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

class Set
  extend ::T::Sig
end

module Signal
  extend ::T::Sig
end

class SignalException
  def signm(); end

  def signo(); end
end

class SignalException
  extend ::T::Sig
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class SimpleDelegator
  extend ::T::Sig
end

module SingleForwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_single_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_single_delegators(accessor, *methods); end

  def delegate(hash); end

  def single_delegate(hash); end
end

module SingleForwardable
  extend ::T::Sig
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton::SingletonClassMethods
  extend ::T::Sig
end

module Singleton
  extend ::T::Sig
  def self.__init__(klass); end
end

SizedQueue = Thread::SizedQueue

class Socket
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  SO_BPF_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class Socket::AncillaryData
  extend ::T::Sig
end

module Socket::Constants
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  SO_BPF_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  extend ::T::Sig
end

class Socket::Ifaddr
  extend ::T::Sig
end

class Socket::Option
  extend ::T::Sig
end

class Socket::UDPSource
  extend ::T::Sig
end

class Socket
  extend ::T::Sig
end

class SocketError
  extend ::T::Sig
end

class Sorbet::Private::ConstantLookupCache
  def all_module_aliases(); end

  def all_module_names(); end

  def all_named_modules(); end

  def class_by_name(name); end

  def name_by_class(klass); end
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def aliases(); end

  def aliases=(_); end

  def const(); end

  def const=(_); end

  def const_name(); end

  def const_name=(_); end

  def found_name(); end

  def found_name=(_); end

  def owner(); end

  def owner=(_); end

  def primary_name(); end

  def primary_name=(_); end
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::ConstantLookupCache
end

class Sorbet::Private::CreateConfig
  include ::Sorbet::Private::StepInterface
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::CreateConfig
  def self.main(); end

  def self.output_file(); end
end

class Sorbet::Private::FetchRBIs
  include ::Sorbet::Private::StepInterface
  HEADER = ::T.let(nil, ::T.untyped)
  RBI_CACHE_DIR = ::T.let(nil, ::T.untyped)
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
  SORBET_RBI_LIST = ::T.let(nil, ::T.untyped)
  SORBET_RBI_SORBET_TYPED = ::T.let(nil, ::T.untyped)
  SORBET_TYPED_REPO = ::T.let(nil, ::T.untyped)
  SORBET_TYPED_REVISION = ::T.let(nil, ::T.untyped)
  XDG_CACHE_HOME = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::FetchRBIs
  def self.fetch_sorbet_typed(); end

  def self.main(); end

  def self.matching_version_directories(root, version); end

  def self.output_file(); end

  def self.paths_for_gem_version(gemspec); end

  def self.paths_for_ruby_version(ruby_version); end

  def self.vendor_rbis_within_paths(vendor_paths); end
end

class Sorbet::Private::FindGemRBIs
  include ::Sorbet::Private::StepInterface
  GEM_DIR = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  RBI_CACHE_DIR = ::T.let(nil, ::T.untyped)
  XDG_CACHE_HOME = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::FindGemRBIs
  def self.main(); end

  def self.output_file(); end

  def self.paths_within_gem_sources(gemspec); end
end

module Sorbet::Private::GemGeneratorTracepoint
  include ::Sorbet::Private::StepInterface
  OUTPUT = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def defs(); end

  def defs=(_); end

  def id(); end

  def id=(_); end

  def klass(); end

  def klass=(_); end
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
  def initialize(files:, delegate_classes:); end

  def serialize(output_dir); end
  BAD_METHODS = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
  def self.add_to_context(item); end

  def self.disable_tracepoints(); end

  def self.finish(); end

  def self.install_tracepoints(); end

  def self.method_added(mod, method, singleton); end

  def self.module_created(mod); end

  def self.module_extended(extended, extender); end

  def self.module_included(included, includer); end

  def self.pre_cache_module_methods(); end

  def self.register_delegate_class(klass, delegate); end

  def self.start(); end

  def self.trace(); end

  def self.trace_results(); end
end

module Sorbet::Private::GemGeneratorTracepoint
  extend ::T::Sig
  def self.main(output_dir=T.unsafe(nil)); end

  def self.output_file(); end
end

class Sorbet::Private::GemLoader
  GEM_LOADER = ::T.let(nil, ::T.untyped)
  NO_GEM = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemLoader
  def self.my_require(gem); end

  def self.require_all_gems(); end

  def self.require_gem(gem); end
end

class Sorbet::Private::HiddenMethodFinder
  include ::Sorbet::Private::StepInterface
  def all_modules_and_aliases(); end

  def capture_stderr(); end

  def constant_cache(); end

  def gen_source_rbi(classes, aliases); end

  def looks_like_stub_name(name); end

  def main(); end

  def mk_dir(); end

  def read_constants(); end

  def real_name(mod); end

  def require_everything(); end

  def rm_dir(); end

  def serialize_alias(source_entry, rbi_entry, my_klass, source_symbols, rbi_symbols); end

  def serialize_class(source_entry, rbi_entry, klass, source_symbols, rbi_symbols, source_by_name); end

  def serialize_constants(source, rbi, klass, is_singleton, source_symbols, rbi_symbols); end

  def symbols_id_to_name(entry, prefix); end

  def write_constants(); end

  def write_diff(source, rbi); end
  BLACKLIST = ::T.let(nil, ::T.untyped)
  DIFF_RBI = ::T.let(nil, ::T.untyped)
  ERRORS_RBI = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  HIDDEN_RBI = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  RBI_CONSTANTS = ::T.let(nil, ::T.untyped)
  RBI_CONSTANTS_ERR = ::T.let(nil, ::T.untyped)
  SOURCE_CONSTANTS = ::T.let(nil, ::T.untyped)
  SOURCE_CONSTANTS_ERR = ::T.let(nil, ::T.untyped)
  TMP_PATH = ::T.let(nil, ::T.untyped)
  TMP_RBI = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::HiddenMethodFinder
  def self.main(); end

  def self.output_file(); end
end

module Sorbet::Private::Main
end

module Sorbet::Private::Main
  extend ::T::Sig
  def self.cyan(msg); end

  def self.emojify(emoji, msg); end

  def self.main(argv); end

  def self.make_step(step); end

  def self.parse_command(argv); end

  def self.yellow(msg); end
end

module Sorbet::Private::RealStdlib
end

module Sorbet::Private::RealStdlib
  extend ::T::Sig
  def self.real_ancestors(mod); end

  def self.real_autoload?(o, klass); end

  def self.real_const_get(obj, const, arg); end

  def self.real_constants(mod); end

  def self.real_eqeq(obj, other); end

  def self.real_hash(o); end

  def self.real_instance_methods(mod, arg); end

  def self.real_is_a?(o, klass); end

  def self.real_name(o); end

  def self.real_object_id(o); end

  def self.real_private_instance_methods(mod, arg); end

  def self.real_singleton_class(obj); end

  def self.real_singleton_methods(mod, arg); end

  def self.real_spaceship(obj, arg); end

  def self.real_superclass(o); end
end

class Sorbet::Private::RequireEverything
end

class Sorbet::Private::RequireEverything
  def self.excluded_rails_files(); end

  def self.load_bundler(); end

  def self.load_rails(); end

  def self.my_require(abs_path, numerator, denominator); end

  def self.patch_kernel(); end

  def self.rails?(); end

  def self.require_all_files(); end

  def self.require_everything(); end
end

class Sorbet::Private::Serialize
  def alias(base, other_name); end

  def ancestor_has_method(method, klass); end

  def blacklisted_method(method); end

  def class_or_module(class_name); end

  def comparable?(value); end

  def constant(const, value); end

  def from_method(method); end

  def initialize(constant_cache); end

  def serialize_method(method, static=T.unsafe(nil), with_sig: T.unsafe(nil)); end

  def serialize_sig(parameters); end

  def to_sig(kind, name); end

  def valid_class_name(name); end

  def valid_method_name(name); end
  BLACKLIST_CONSTANTS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::Serialize
  def self.header(typed=T.unsafe(nil), subcommand=T.unsafe(nil)); end
end

module Sorbet::Private::Status
end

module Sorbet::Private::Status
  extend ::T::Sig
  def self.done(); end

  def self.say(message, print_without_tty: T.unsafe(nil)); end
end

module Sorbet::Private::StepInterface
end

module Sorbet::Private::StepInterface
  extend ::T::Sig
  def self.main(); end

  def self.output_file(); end
end

class Sorbet::Private::SuggestTyped
  include ::Sorbet::Private::StepInterface
end

class Sorbet::Private::SuggestTyped
  def self.main(); end

  def self.output_file(); end

  def self.suggest_typed(); end
end

class Sorbet::Private::TodoRBI
  include ::Sorbet::Private::StepInterface
  HEADER = ::T.let(nil, ::T.untyped)
  OUTPUT = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::TodoRBI
  def self.main(); end

  def self.output_file(); end
end

module Sorbet::Private
  extend ::T::Sig
end

class Sorbet
  extend ::T::Sig
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  extend ::T::Sig
  def self.setup(); end
end

class StandardError
  extend ::T::Sig
end

class StopIteration
  def result(); end
end

class StopIteration
  extend ::T::Sig
end

class String
  include ::PSON::Pure::Generator::GeneratorMethods::String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def +@(); end

  def -@(); end

  def []=(*_); end

  def _fast_gettext_old_format_m(_); end

  def casecmp?(_); end

  def delete_prefix(_); end

  def delete_prefix!(_); end

  def delete_suffix(_); end

  def delete_suffix!(_); end

  def each_grapheme_cluster(); end

  def encode(*_); end

  def encode!(*_); end

  def grapheme_clusters(); end

  def match?(*_); end

  def reverse!(); end

  def shellescape(); end

  def shellsplit(); end

  def succ!(); end

  def undump(); end

  def unicode_normalize(*_); end

  def unicode_normalize!(*_); end

  def unicode_normalized?(*_); end

  def unpack1(_); end

end

class String
  extend ::T::Sig
  extend ::PSON::Pure::Generator::GeneratorMethods::String::Extend
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
end

class StringIO
  def length(); end

  def truncate(_); end

end

class StringIO
  extend ::T::Sig
end

class StringScanner
  def <<(_); end

  def [](_); end

  def beginning_of_line?(); end

  def bol?(); end

  def captures(); end

  def charpos(); end

  def check(_); end

  def check_until(_); end

  def clear(); end

  def concat(_); end

  def empty?(); end

  def exist?(_); end

  def get_byte(); end

  def getbyte(); end

  def initialize(*_); end

  def match?(_); end

  def matched(); end

  def matched?(); end

  def matched_size(); end

  def peek(_); end

  def peep(_); end

  def pointer(); end

  def pointer=(pointer); end

  def pos(); end

  def pos=(pos); end

  def post_match(); end

  def pre_match(); end

  def reset(); end

  def rest(); end

  def rest?(); end

  def rest_size(); end

  def restsize(); end

  def scan_full(_, _1, _2); end

  def scan_until(_); end

  def search_full(_, _1, _2); end

  def size(); end

  def skip(_); end

  def skip_until(_); end

  def string(); end

  def string=(string); end

  def terminate(); end

  def unscan(); end

  def values_at(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class StringScanner::Error
  extend ::T::Sig
end

class StringScanner
  extend ::T::Sig
  def self.must_C_version(); end
end

class Struct
  def [](_); end

  def []=(_, _1); end

  def dig(*_); end

  def each_pair(); end

  def length(); end

  def members(); end

  def select(*_); end

  def size(); end

  def to_a(); end

  def to_h(); end

  def values(); end

  def values_at(*_); end
end

Struct::Group = Etc::Group

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class Struct
  extend ::T::Sig
end

class Symbol
  def casecmp?(_); end

  def match?(*_); end

  def next(); end

end

class Symbol
  extend ::T::Sig
end

class Sync
  include ::Sync_m
  def exclusive?(); end

  def lock(m=T.unsafe(nil)); end

  def locked?(); end

  def shared?(); end

  def synchronize(mode=T.unsafe(nil)); end

  def try_lock(mode=T.unsafe(nil)); end

  def unlock(m=T.unsafe(nil)); end
end

class Sync
end

module Sync_m
  def initialize(*args); end

  def sync_ex_count(); end

  def sync_ex_count=(sync_ex_count); end

  def sync_ex_locker(); end

  def sync_ex_locker=(sync_ex_locker); end

  def sync_exclusive?(); end

  def sync_extend(); end

  def sync_inspect(); end

  def sync_lock(m=T.unsafe(nil)); end

  def sync_locked?(); end

  def sync_mode(); end

  def sync_mode=(sync_mode); end

  def sync_sh_locker(); end

  def sync_sh_locker=(sync_sh_locker); end

  def sync_shared?(); end

  def sync_synchronize(mode=T.unsafe(nil)); end

  def sync_try_lock(mode=T.unsafe(nil)); end

  def sync_unlock(m=T.unsafe(nil)); end

  def sync_upgrade_waiting(); end

  def sync_upgrade_waiting=(sync_upgrade_waiting); end

  def sync_waiting(); end

  def sync_waiting=(sync_waiting); end
  EX = ::T.let(nil, ::T.untyped)
  SH = ::T.let(nil, ::T.untyped)
  UN = ::T.let(nil, ::T.untyped)
end

class Sync_m::Err
end

class Sync_m::Err::LockModeFailer
  Message = ::T.let(nil, ::T.untyped)
end

class Sync_m::Err::LockModeFailer
  def self.Fail(mode); end
end

class Sync_m::Err::UnknownLocker
  Message = ::T.let(nil, ::T.untyped)
end

class Sync_m::Err::UnknownLocker
  def self.Fail(th); end
end

class Sync_m::Err
  def self.Fail(*opt); end
end

module Sync_m
  extend ::T::Sig
  def self.append_features(cl); end

  def self.define_aliases(cl); end

  def self.extend_object(obj); end
end

Synchronizer = Sync

Synchronizer_m = Sync_m

class SyntaxError
  extend ::T::Sig
end

module Syslog
  include ::Syslog::Constants
  include ::Syslog::Option
  include ::Syslog::Facility
  include ::Syslog::Level
  include ::Syslog::Macros
end

module Syslog::Constants
  include ::Syslog::Option
  include ::Syslog::Facility
  include ::Syslog::Level
  include ::Syslog::Macros
end

module Syslog::Constants
  extend ::Syslog::Macros
  extend ::T::Sig
end

module Syslog::Facility
  LOG_AUTH = ::T.let(nil, ::T.untyped)
  LOG_AUTHPRIV = ::T.let(nil, ::T.untyped)
  LOG_CRON = ::T.let(nil, ::T.untyped)
  LOG_DAEMON = ::T.let(nil, ::T.untyped)
  LOG_FTP = ::T.let(nil, ::T.untyped)
  LOG_KERN = ::T.let(nil, ::T.untyped)
  LOG_LOCAL0 = ::T.let(nil, ::T.untyped)
  LOG_LOCAL1 = ::T.let(nil, ::T.untyped)
  LOG_LOCAL2 = ::T.let(nil, ::T.untyped)
  LOG_LOCAL3 = ::T.let(nil, ::T.untyped)
  LOG_LOCAL4 = ::T.let(nil, ::T.untyped)
  LOG_LOCAL5 = ::T.let(nil, ::T.untyped)
  LOG_LOCAL6 = ::T.let(nil, ::T.untyped)
  LOG_LOCAL7 = ::T.let(nil, ::T.untyped)
  LOG_LPR = ::T.let(nil, ::T.untyped)
  LOG_MAIL = ::T.let(nil, ::T.untyped)
  LOG_NEWS = ::T.let(nil, ::T.untyped)
  LOG_SYSLOG = ::T.let(nil, ::T.untyped)
  LOG_USER = ::T.let(nil, ::T.untyped)
  LOG_UUCP = ::T.let(nil, ::T.untyped)
end

module Syslog::Facility
  extend ::T::Sig
end

module Syslog::Level
  LOG_ALERT = ::T.let(nil, ::T.untyped)
  LOG_CRIT = ::T.let(nil, ::T.untyped)
  LOG_DEBUG = ::T.let(nil, ::T.untyped)
  LOG_EMERG = ::T.let(nil, ::T.untyped)
  LOG_ERR = ::T.let(nil, ::T.untyped)
  LOG_INFO = ::T.let(nil, ::T.untyped)
  LOG_NOTICE = ::T.let(nil, ::T.untyped)
  LOG_WARNING = ::T.let(nil, ::T.untyped)
end

module Syslog::Level
  extend ::T::Sig
end

module Syslog::Macros
  def LOG_MASK(_); end

  def LOG_UPTO(_); end
end

module Syslog::Macros
  extend ::T::Sig
end

module Syslog::Option
  LOG_CONS = ::T.let(nil, ::T.untyped)
  LOG_NDELAY = ::T.let(nil, ::T.untyped)
  LOG_NOWAIT = ::T.let(nil, ::T.untyped)
  LOG_ODELAY = ::T.let(nil, ::T.untyped)
  LOG_PERROR = ::T.let(nil, ::T.untyped)
  LOG_PID = ::T.let(nil, ::T.untyped)
end

module Syslog::Option
  extend ::T::Sig
end

module Syslog
  extend ::Syslog::Macros
  extend ::T::Sig
  def self.alert(*_); end

  def self.close(); end

  def self.crit(*_); end

  def self.debug(*_); end

  def self.emerg(*_); end

  def self.err(*_); end

  def self.facility(); end

  def self.ident(); end

  def self.info(*_); end

  def self.instance(); end

  def self.log(*_); end

  def self.mask(); end

  def self.mask=(mask); end

  def self.notice(*_); end

  def self.open!(*_); end

  def self.opened?(); end

  def self.options(); end

  def self.reopen(*_); end

  def self.warning(*_); end
end

class SystemCallError
  def errno(); end
end

class SystemCallError
  extend ::T::Sig
end

class SystemExit
  def status(); end

  def success?(); end
end

class SystemExit
  extend ::T::Sig
end

class SystemStackError
  extend ::T::Sig
end

class TCPServer
  extend ::T::Sig
end

class TCPSocket
  extend ::T::Sig
end

class TSort::Cyclic
  extend ::T::Sig
end

module TSort
  extend ::T::Sig
end

class Thread
  def abort_on_exception(); end

  def abort_on_exception=(abort_on_exception); end

  def add_trace_func(_); end

  def backtrace(*_); end

  def backtrace_locations(*_); end

  def exit(); end

  def fetch(*_); end

  def group(); end

  def initialize(*_); end

  def join(*_); end

  def key?(_); end

  def keys(); end

  def name(); end

  def name=(name); end

  def pending_interrupt?(*_); end

  def priority(); end

  def priority=(priority); end

  def report_on_exception(); end

  def report_on_exception=(report_on_exception); end

  def run(); end

  def safe_level(); end

  def status(); end

  def stop?(); end

  def terminate(); end

  def thread_variable?(_); end

  def thread_variable_get(_); end

  def thread_variable_set(_, _1); end

  def thread_variables(); end

  def value(); end

  def wakeup(); end
end

class Thread::Backtrace::Location
  extend ::T::Sig
end

class Thread::Backtrace
  extend ::T::Sig
end

class Thread::ConditionVariable
  def broadcast(); end

  def marshal_dump(); end

  def signal(); end

  def wait(*_); end
end

class Thread::ConditionVariable
  extend ::T::Sig
end

class Thread::Mutex
  def lock(); end

  def locked?(); end

  def owned?(); end

  def synchronize(); end

  def try_lock(); end

  def unlock(); end
end

class Thread::Mutex
  extend ::T::Sig
end

class Thread::Queue
  def <<(_); end

  def clear(); end

  def close(); end

  def closed?(); end

  def deq(*_); end

  def empty?(); end

  def enq(_); end

  def length(); end

  def marshal_dump(); end

  def num_waiting(); end

  def pop(*_); end

  def push(_); end

  def shift(*_); end

  def size(); end
end

class Thread::Queue
  extend ::T::Sig
end

class Thread::SizedQueue
  def <<(*_); end

  def enq(*_); end

  def initialize(_); end

  def max(); end

  def max=(max); end

  def push(*_); end
end

class Thread::SizedQueue
  extend ::T::Sig
end

class Thread
  extend ::T::Sig
  def self.abort_on_exception(); end

  def self.abort_on_exception=(abort_on_exception); end

  def self.exclusive(&block); end

  def self.exit(); end

  def self.fork(*_); end

  def self.handle_interrupt(_); end

  def self.kill(_); end

  def self.list(); end

  def self.pass(); end

  def self.pending_interrupt?(*_); end

  def self.report_on_exception(); end

  def self.report_on_exception=(report_on_exception); end

  def self.start(*_); end

  def self.stop(); end
end

class ThreadError
  extend ::T::Sig
end

class ThreadGroup
  def add(_); end

  def enclose(); end

  def enclosed?(); end

  def list(); end
  Default = ::T.let(nil, ::T.untyped)
end

class ThreadGroup
  extend ::T::Sig
end

class Time
  extend ::T::Sig
end

class Timeout::Error
  extend ::T::Sig
end

module Timeout
  extend ::T::Sig
end

class TracePoint
  def event(); end
end

class TracePoint
  extend ::T::Sig
end

class TrueClass
  include ::PSON::Pure::Generator::GeneratorMethods::TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

class TrueClass
  extend ::T::Sig
end

class TypeError
  extend ::T::Sig
end

class UDPSocket
  extend ::T::Sig
end

class UNIXServer
  extend ::T::Sig
end

class UNIXSocket
  extend ::T::Sig
end

module URI
  include ::URI::RFC2396_REGEXP
end

class URI::BadURIError
  extend ::T::Sig
end

class URI::Error
  extend ::T::Sig
end

module URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

module URI::Escape
  extend ::T::Sig
end

class URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
end

class URI::FTP
  extend ::T::Sig
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::Generic
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
end

class URI::Generic
  extend ::T::Sig
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class URI::HTTP
  def request_uri(); end
end

class URI::HTTP
  extend ::T::Sig
end

class URI::HTTPS
  extend ::T::Sig
end

class URI::InvalidComponentError
  extend ::T::Sig
end

class URI::InvalidURIError
  extend ::T::Sig
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::LDAP
  extend ::T::Sig
end

class URI::LDAPS
  extend ::T::Sig
end

class URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
end

class URI::MailTo
  extend ::T::Sig
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class URI::RFC2396_Parser
  extend ::T::Sig
end

module URI::RFC2396_REGEXP::PATTERN
  extend ::T::Sig
end

module URI::RFC2396_REGEXP
  extend ::T::Sig
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

class URI::RFC3986_Parser
  extend ::T::Sig
end

module URI::Util
  extend ::T::Sig
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::T::Sig
  extend ::URI::Escape
  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.get_encoding(label); end
end

class UnboundMethod
  def clone(); end

  def original_name(); end
end

class UnboundMethod
  extend ::T::Sig
end

class UncaughtThrowError
  def tag(); end

  def value(); end
end

class UncaughtThrowError
  extend ::T::Sig
end

module UnicodeNormalize
end

module UnicodeNormalize
  extend ::T::Sig
end

Visitor = Psych::Visitors::Visitor

module Warning
  def warn(_); end
end

module Warning
  extend ::T::Sig
  extend ::Warning
end

YAML = Psych

YAMLTree = Psych::Visitors::YAMLTree

class ZeroDivisionError
  extend ::T::Sig
end

module Zlib
  ASCII = ::T.let(nil, ::T.untyped)
  BEST_COMPRESSION = ::T.let(nil, ::T.untyped)
  BEST_SPEED = ::T.let(nil, ::T.untyped)
  BINARY = ::T.let(nil, ::T.untyped)
  DEFAULT_COMPRESSION = ::T.let(nil, ::T.untyped)
  DEFAULT_STRATEGY = ::T.let(nil, ::T.untyped)
  DEF_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  FILTERED = ::T.let(nil, ::T.untyped)
  FINISH = ::T.let(nil, ::T.untyped)
  FIXED = ::T.let(nil, ::T.untyped)
  FULL_FLUSH = ::T.let(nil, ::T.untyped)
  HUFFMAN_ONLY = ::T.let(nil, ::T.untyped)
  MAX_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  MAX_WBITS = ::T.let(nil, ::T.untyped)
  NO_COMPRESSION = ::T.let(nil, ::T.untyped)
  NO_FLUSH = ::T.let(nil, ::T.untyped)
  OS_AMIGA = ::T.let(nil, ::T.untyped)
  OS_ATARI = ::T.let(nil, ::T.untyped)
  OS_CODE = ::T.let(nil, ::T.untyped)
  OS_CPM = ::T.let(nil, ::T.untyped)
  OS_MACOS = ::T.let(nil, ::T.untyped)
  OS_MSDOS = ::T.let(nil, ::T.untyped)
  OS_OS2 = ::T.let(nil, ::T.untyped)
  OS_QDOS = ::T.let(nil, ::T.untyped)
  OS_RISCOS = ::T.let(nil, ::T.untyped)
  OS_TOPS20 = ::T.let(nil, ::T.untyped)
  OS_UNIX = ::T.let(nil, ::T.untyped)
  OS_UNKNOWN = ::T.let(nil, ::T.untyped)
  OS_VMCMS = ::T.let(nil, ::T.untyped)
  OS_VMS = ::T.let(nil, ::T.untyped)
  OS_WIN32 = ::T.let(nil, ::T.untyped)
  OS_ZSYSTEM = ::T.let(nil, ::T.untyped)
  RLE = ::T.let(nil, ::T.untyped)
  SYNC_FLUSH = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  ZLIB_VERSION = ::T.let(nil, ::T.untyped)
end

class Zlib::BufError
end

class Zlib::BufError
end

class Zlib::DataError
end

class Zlib::DataError
end

class Zlib::Deflate
  def <<(_); end

  def deflate(*_); end

  def flush(*_); end

  def initialize(*_); end

  def params(_, _1); end

  def set_dictionary(_); end
end

class Zlib::Deflate
  def self.deflate(*_); end
end

class Zlib::Error
end

class Zlib::Error
end

class Zlib::GzipFile
  def close(); end

  def closed?(); end

  def comment(); end

  def crc(); end

  def finish(); end

  def level(); end

  def mtime(); end

  def orig_name(); end

  def os_code(); end

  def sync(); end

  def sync=(sync); end

  def to_io(); end
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::Error
  def input(); end
end

class Zlib::GzipFile::Error
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile
  def self.wrap(*_); end
end

class Zlib::GzipReader
  include ::Enumerable
  def bytes(); end

  def each(*_); end

  def each_byte(); end

  def each_char(); end

  def each_line(*_); end

  def eof(); end

  def eof?(); end

  def external_encoding(); end

  def getbyte(); end

  def getc(); end

  def initialize(*_); end

  def lineno(); end

  def lineno=(lineno); end

  def lines(*_); end

  def pos(); end

  def read(*_); end

  def readbyte(); end

  def readchar(); end

  def readpartial(*_); end

  def rewind(); end

  def tell(); end

  def ungetbyte(_); end

  def ungetc(_); end

  def unused(); end
end

class Zlib::GzipReader
end

class Zlib::GzipWriter
  def <<(_); end

  def comment=(comment); end

  def flush(*_); end

  def initialize(*_); end

  def mtime=(mtime); end

  def orig_name=(orig_name); end

  def pos(); end

  def tell(); end

  def write(*_); end
end

class Zlib::GzipWriter
end

class Zlib::Inflate
  def <<(_); end

  def add_dictionary(_); end

  def inflate(_); end

  def initialize(*_); end

  def set_dictionary(_); end

  def sync(_); end

  def sync_point?(); end
end

class Zlib::Inflate
  def self.inflate(_); end
end

class Zlib::MemError
end

class Zlib::MemError
end

class Zlib::NeedDict
end

class Zlib::NeedDict
end

class Zlib::StreamEnd
end

class Zlib::StreamEnd
end

class Zlib::StreamError
end

class Zlib::StreamError
end

class Zlib::VersionError
end

class Zlib::VersionError
end

class Zlib::ZStream
  def adler(); end

  def avail_in(); end

  def avail_out(); end

  def avail_out=(avail_out); end

  def close(); end

  def closed?(); end

  def data_type(); end

  def end(); end

  def ended?(); end

  def finish(); end

  def finished?(); end

  def flush_next_in(); end

  def flush_next_out(); end

  def reset(); end

  def stream_end?(); end

  def total_in(); end

  def total_out(); end
end

class Zlib::ZStream
end

module Zlib
  extend ::T::Sig
  def self.adler32(*_); end

  def self.adler32_combine(_, _1, _2); end

  def self.crc32(*_); end

  def self.crc32_combine(_, _1, _2); end

  def self.crc_table(); end

  def self.deflate(*_); end

  def self.gunzip(_); end

  def self.gzip(*_); end

  def self.inflate(_); end

  def self.zlib_version(); end
end
